;
;BMON - THE BIG (BRIAN'S) MONITOR (8K VERSION TEC-1F)
;BY BRIAN CHIHA AND JIM ROBINSON
;
;THIS IS A MODIFIED VERSION OF JMON (JIM'S MONITOR).  IT KEEPS ALL THE GOOD THINGS OF
;THE MONITOR, LIKE AUTO INCREMENT, MENU AND PERIMETER HANDLERS, BREAK POINTS AND 
;SINGLE STEPPER.  WHAT HAS BEEN CHANGED IS THAT THE TAPE HANDLING ROUTINES HAVE BEEN
;REPLACED WITH 'BIT BANGED' SERIAL COMMUNICATION, A KEYBOARD MOD FEATURE AND ASCII
;BANNER FOR THE SEVEN SEGMENTS.
;
;BMON HAS BEEN WRITTEN FOR THE TEC-1F WITH INTERGRATED SERIAL COMMUNICATION.  THE CONCEPT
;IS THAT PROGRAMMING/DEBUGGING IS DONE ON AN EXTERNAL Z80 COMIPLER AND THE PROGRAM IS THEN 
;TRANSFERED TO THE TEC-1F VIA THE SERIAL COMMUNICATION PORT.  COMMUNICATION IS DONE 
;VIA BIT 7 OF THE KEYBOARD BUFFER (IN PORT 0) AND BIT 6 OF THE SEVEN SEGEMENT ACTIVE PORT (OUT PORT 1)
;
;TO ENTER THE FEATURES, PRESS "SHIFT-0" ON THE KEYPAD.  CHOOSE THE MENU ITEM BY PRESSING
;PLUS OR MINUS, THEN HIT GO TO RUN THE ROUTINE.  (HIT ADDRESS TO ESCAPE).  THE NEW MENU
;ITEMS ARE:
;
;SIO-IN - SERIAL INPUT.  SELECT START AND END ADDRESS TO LOAD FROM YOUR COMPUTER TO THE TEC
;SIO-OT - SERIAL OUTPUT. SELECT START AND END ADDRESS TO SEND TEC DATA TO YOUR COMPUTER
;INTEL - INTEL HEX FILE INPUT.  SEND AN INTEL HEX FILE FROM YOUR COMPUTER TO THE TEC
;ALTKEY - CHANGE BETWEEN STANDARD KEYBOARD LAYOUT OR MARK JELIC'S ALTERNATE KEYPAD LAYOUT
;BANNER - ASCII BANNER TICKER DISPLAY, SELECT A START ADDRESS AND A BANNER WILL BE DISPLAYED
;
;SO THAT THE ALTERNATE KEYBOARD WILL RETAIN ON A RESET, A HARD RESET WILL ONLY OCCUR ON 
;FIRST START UP AND WHEN THE RESET BUTTON IS PRESSED AT THE SAME TIME ANOTHER KEY IS PRESSED
;OTHERWISE ALL RESETS WILL BE SOFT AND RETAIN ANY USER SET UPS OR FLAGS.
;
;BIT BANG SERIAL ROUTINES 'TRANSMIT BYTE' AND 'RECEIVE BYTE' CAN BE CALLED EXTERNALLY BY
;DOING A CALL 004A AND CALL 004D.  SERIAL TRANSMISSION IS SET AT 4800-8-N-2
;
;THE FOLLOWING IS FROM THE JMON INSTRUCTIONS.
;
;GLOSSARY
;
;CURRENT EDITING LOCATION (3F2E)
;THIS IS THE ADDRESS THAT IS USUALLY DISPLAYED IN THE ADDRESS SECTION ON THE TEC LED
;DISPLAY. IT IS THE ADDRESS THAT IS SUBJECT TO MODIFICATION BY JMON.
;
;MONITOR CONTROL BYTE (MCB) (3F2B)
;THIS BYTE CONTAINS THE INFORMATION OF THE CURRENT WORKING STATE OF JMON. THE INFORMATION
;HELD IN THIS BYTE IS:
;1 - THE CURRENT MODE OF JMON.
;E.G. DATA, ADDRESS OR FUNCTION (NOT SHIFT AS SHIFT IS TESTED AND HANDLED DURING THE DATA
;KEY HANDLER ROUTINE). BITS 4 AND 5 ENCODE THE CURRENT MODE IN THE FOLLOWING WAY. BOTH
;BITS ARE LOW FOR THE DATA MODE, BIT 4 IS HIGH FOR THE ADDRESS MODE, BITS 4 AND 5 ARE HIGH
;FOR THE FUNCTION MODE. BIT 4 IS CALLED THE ADDRESS/FUNCTION BIT As THE SOFTWARE ONLY
;NEEDS TO TEST THIS BIT TO FIND IF EITHER THE ADDRESS OR FUNCTION MODE IS ACTIVE. BIT 5
;IS THE FUNCTION MODE ENABLED BIT.
;2 - THE NUMBER OF THE CURRENT FUNCTION I.E. 1,2 OR 3.
;THIS IS ENCODED IN BITS 2 AND 3. IF NO FUNCTION OR FUNCTION-1 IS ENABLED THEN BOTH BITS
;ARE LOW. IF FUNCTION-2 IS SELECTED THEN BIT 2 IS HIGH AND BIT 3 IS LOW. IF FUNCTION-3 IS
;SELECTED THEN BIT 3 IS HIGH AND BIT 2 IS LOW.
;3 - THE NUMBER OF NIBBLES ENTERED
;THIS IS ENCODED IN BITS 0 AND 1. IF NO NIBBLES HAVE BEEN ENTERED IN THE CURRENT EDITING
;LOCATION THEN BOTH BIT ARE LOW. IF ONE NIBBLE HAS BEEN ENTERED THEN BIT 0 IS HIGH AND
;BIT 1 IS LOW IS TWO NIBBLES HAVE BEEN ENTERED THEN BIT 0 IS LOW AND BIT 1 IS HIGH. JMON
;USES THESE BITS WHEN DECIDING ON THE AUTO-INCREMENT FEATURE. BITS 6 AND 7 ARE NOT USED.
;
;DISPLAY BUFFER ADDRESS - (3F2C/D)
;THE CONTENTS OF 3F2C/D POINTS TO THE LOCATION IN MEMORY OF THE 6 BYTE DISPLAY BUFFER
;(3F00 FOR JMON AND 3F06 FOR THE STEPPER). THE DISPLAY BUFFER ADDRESS POINTS TO THE LOWEST
;ADDRESS OF THE DISPLAY BUFFER WHICH CONTAINS THE LOW ORDER DATA DISPLAY BYTE.
;
;KEY PLANT
;THE KEY PLANT IS A FAKE KEY STROKE THAT MAY BE GENERATED BY THE "DURING SCAN/REY LOOP"
;USER PATCH. THE PLANT ALLOWS JMON'S MONITOR FUNCTIONS TO BE SOFTWARE CONTROLLED E.G. YOU
;MAY WISH TO VIEW THE CONTENTS ,OF MEMORY BYTE BY BYTE. WITH THE KEY PLANT YOU CAN SET JMON
;UP TO AUTOMATICALLY INCREMENT THE CURRENT EDIT LOCATION EVERY FEW SECONDS.
;THE PLANT IS IDENTIFIED BY THE USER PATCH STORING THE REQUIRED KEY VALUE IN, AND SETTING
;BIT 7 OF THE INPUT KEY BUFFER (3F20).
;
;AUTO KEY STATUS BYTE (3F2A)
;THIS BYTE HOLDS THE INFORMATION REQUIRED FOR THE AUTO KEY REPEAT SECTION. THE INFORMATION
;HELD IN THIS BYTE IS EITHER ONE OF THE FOLLOWING:
;A "NEXT KEY DETECTION WILL BE A FIRST DETECTION" SO JMON WILL PROCESS THE KEY IMMEDIATELY
;(BIT 7 HIGH) . A TIMER (BITS 0-6) THAT COUNTS, A DELAY FOR THE AUTO. REPEAT TIMING.
;
;KEY PRESS FLAG (3F25)
;THIS FLAG IS USED TO REMEMBER IF THE ONE KEY PRESS HAS ALREADY BEEN DETECTED AND PROCESSED.
;THIS PREVENTS THE SAME KEY BEING PROCESSED EACH TIME THE SOFTWARE FINDS THAT IT IS PUSHED.
;THIS IS THE WAY IT WORKS:
;THE KEY PRESS FLAG 1S ZEROED BY THE JMON DEFAULT VARIABLES AND THIS FLAGS A "NO KEY
;PRESSED" STATE. WHEN A KEY IS DETECTED THEN THIS FLAG IS TESTED AND IF ZERO THEN THE KEY
;IS ACCEPTED AS A FIRST KEY PRESS. IN THIS CASE THE KEY PRESS FLAG IS THEN SET TO FF TO
;REMEMBER THAT THE KEY PRESS HAS BEEN DETECTED. IF A KEY IS DETECTED AND THIS FLAG BYTE
;IS NOT ZERO, THEN THE KEY IS IGNORED. WHEN THE SOFTWARE FINDS THAT NO KEY IS BEING PRESSED,
;THEN THIS FLAG IS CLEARED TO ALLOW THE NEXT KEY PRESS DETECTED TO BE PROCESSED.
;THIS FLAG IS USED BY THE RST 08, RST 10 RST 18 AND RST 20 KEYBOARD ROUTINES AS DESCRIBED
;IN ISSUE 15 TALKING ELECTRONICS AND ALSO THE STEPPER SOFTWARE.
;THE AUTO KEY REPEAT ROUTINE DOES NOT USE THIS FLAG BYTE, DO NOT CONFUSE THIS FLAG WITH
;THE AUTO KEY STATUS BYTE WHICH IS USED BY THE AUTO KEY REPEAT SECTION.
;
;"NEXT PC" BUFFER
;THIS IS A TEMPORARY PLACE TO SAVE THE RETURN ADDRESS WHICH IS THEN USED AS THE ACTUAL PC
;VALUE FOR THE NEXT INSTRUCTION STEPPED.
;
;FORCED HARD RESET
;THIS IS ACHIEVED BY HOLDING DOWN A KEY WHEN RELEASING THE RESET. THE HARD RESET CAUSES
;JMON TO RE-BOOT ITS VARIABLES AND ALSO MASK OFF ALL THE USER PATCHES (EXCEPT THE RESET
;PATCH). THE MAIN PURPOSE OF A FORCED HARD RESET IS TO RECOVER THE TEC IF A USER PATCH
;ENTERS A CONTINUOUS LOOP.
;
;
;PRECOMPILE SETUP FOR STANDARD TEC-1D (OR BELOW) OR TEC-1F
;** NOTE: USER MUST CHANGE THE MACHINE LABEL FOR TARGET MACHINE **
TEC_1F:     EQU     0x1F                                ;TEC 1F MACHINE
TEC_1D:     EQU     0x1D                                ;TEC 1D MACHINE
TEC_1C:     EQU     0x1C                                ;TEC 1C MACHINE
TEC_1B:     EQU     0x1B                                ;TEC 1B MACHINE
TEC_1A:     EQU     0x1A                                ;TEC 1A MACHINE
TEC_1:      EQU     0x01                                ;TEC 1 MACHINE

;BIT BANG BAUD RATES CONSTANTS FOR 4MHz
B300:	    EQU	    0x220                               ;BAUD 0300
B1200:	    EQU	    0x80                                ;BAUD 1200
B2400:	    EQU	    0x3F                                ;BAUD 2400
B4800:	    EQU	    0x1B                                ;BAUD 4800
B9600:	    EQU	    0x0B                                ;BAUD 9600
DEF_BAUD:   EQU     B4800                               ;DEFAULT BAUD TO 4800

REG_TBL:    EQU     0797H - 2                           ;BASE OF REGISTER NAME TABLE
DISP_BUFF:  EQU     3F00H                               ;Current displayed Address Buffer
DISP_DBUFF: EQU     3F04H                               ;Current displayed Data Buffer
DISP_D2BUF: EQU     3F05H                               ;Character #2 of the Data Display Buffer
DISP_STEP:  EQU     3F06H                               ;Stepper's 6 Byte Display Buffer

;USER VARIABLE START LOCATION
V_KEY:      EQU     3F20H                               ;KEY BUFFER
V_LCD:      EQU     3F21H                               ;LCD ON/OFF FLAG
V_BEEP:     EQU     3F22H                               ;SOUND ON/OFF
V_ALT_ADDF: EQU     3F23H                               ;GO AT ALTERNATE GO ADDRESS IF AA
V_STEP_TMR: EQU     3F24H                               ;STEPPER KEY CONTROL/TIMER
V_KEY_PRES: EQU     3F25H                               ;KEY PRESS FLAG
V_ALT_KEYB: EQU     3F26H                               ;ALTERNATIVE KEYBOARD LAYOUT FLAG
V_AUTO:     EQU     3F27H                               ;AUTO INCREMENT ON/OFF
V_ALT_ADDR: EQU     3F28H                               ;ALT GO ADDR/SOFT RESET EDIT LOCATION
V_KAUTO:    EQU     3F2AH                               ;AUTO KEY STATUS BYTE
V_MCB:      EQU     3F2BH                               ;MONITOR CONTROL BYTE (MCB)
V_DISPLAY:  EQU     3F2CH                               ;DISPLAY BUFFER ADDRESS (using 7seg Display codes)
V_CEL:      EQU     3F2EH                               ;CURRENT EDITING LOCATION (CEL)

;The following are the JUMP addresses that a CALLED by JMON,
;after they are copied from the ROM (starting @ 071Fh) to the RAM @ 3F30h, on a Hard Reset.
;They point back to routines in the ROM, so not sure why this was done.
HL_2_DIS:   EQU     3F30H                               ;CONVERT HL TO DISPLAY CODE @ 01D5h
A_2_DISP:   EQU     3F33H                               ;CONVERT A TO DISPLAY CODE @ 01DAh
LED_SCAN:   EQU     3F36H                               ;LED SCAN ROUTINE @ 01BAh
SET_DOTS:   EQU     3F39H                               ;SET LED DOTS @ 01EEh
BEEPBEEP:   EQU     3F3CH                               ;RESET TONES @ 0224h (TWO BEEPS)
BEEP:       EQU     3F3FH                               ;TONE @ 0227h
SCAN_IO:    EQU     3F42H                               ;SCAN/KEY/LCD/PATCH LOOP @ 0181h
DO_DISP:    EQU     3F45h                               ;SOFT JMON ENTRY L3F45 @ 00B2h
LCD_DISP:   EQU     3F48H                               ;LCD ROUTINE @ 023Ch

;Various other Monitor Locations to help with its functionality
PATCH_BEF:  EQU     3F4BH                               ;PRE-SCAN USER PATCH
PATCH_DUR:  EQU     3F4EH                               ;USER "DURING LOOP" PATCH
PATCH_AFT:  EQU     3F51H                               ;USER "AFTER KEY" PATCH
PATCH_KEY:  EQU     3F54H                               ;USER "KEYBOARD" PATCH
STEP_NEXT:  EQU     3F58H                               ;ADDRESS OF INSTRUCTION JUST STEPPED
STEP_CREG:  EQU     3F5AH                               ;CURRENT REG No. BUFFER
RE_ENTRY:   EQU     3F60H                               ;RE-ENTRY ADDRESS BUFFER
STEP_PREV:  EQU     3F68H                               ;"NEXT PC" BUFFER
STEP_REGS:  EQU     3F6Ah                               ;SHIFT 7 ROUTINE START (REG DISPLAY)
HL_SAVE:    EQU     3F6EH                               ;HL SAVE ON RESET
STEP_HL:    EQU     3F70H                               ;STEPPER INITIAL HL
STEP_SP:    EQU     3F7EH                               ;Stack Pointer Save Buffer
PERI_SETUP: EQU     3F80H                               ;PERIMITER MENU SETUP
PERI_D_TBL: EQU     3F82H                               ;PERIMITER DATA SEGMENT TABLE
PERI_W_ADD: EQU     3F84H                               ;PERIMITER WINDOW ENTRY START LOCATION
PERI_W_CUR: EQU     3F86H                               ;CURRENT PERIMETER WINDOW
PERI_W_MAX: EQU     3F87H                               ;TOTAL PERIMETER WINDOWS
PERI_J_ADR: EQU     3F88H                               ;PERIMITER GO JUMP ADDRESS
PERI_W_AC1: EQU     3F8CH                               ;PERIMITER ACTIVE WINDOW + 1
MENU_SETUP: EQU     3F8DH                               ;MENU SETUP START
MENU_NO:    EQU     3F8FH                               ;MENU ENTRY NUMBER
MENU_J_TBL: EQU     3F91H                               ;MENU JUMP TABLE
MENU_A_TBL: EQU     3F93H                               ;MENU ADDRESS SEGMENT TABLE
MENU_D_TBL: EQU     3F95H                               ;MENU DATA SEGMENT TABLE
MENU_KEYRN: EQU     3F97H                               ;MENU DATA KEY RETURN HANDLER (USE C9 IF N/A)
SIO_START:  EQU     3F98H                               ;START OF SIO TRANSFER ADDRESS
SIO_END:    EQU     3F9AH                               ;SEND OF SIO TRANSFER ADDRESS

BAUD:       EQU     3FA4H                               ;BAUD RATE DELAY FOR SIO
HEX_ADDR:   EQU     3FA6H                               ;INTEL HEX START ADDRESS
HEX_CHKSUM: EQU     3FA8H                               ;INTEL HEX CHECKSUM
PATCH_REQ:  EQU     3FB0H                               ;RESET PATCH REQUIRED IF 0xAA IS HERE
PATCH_STA:  EQU     3FB1H                               ;RESET PATCH START ADDRESS. 0x3FB1-0x3FB2
PATCH_VAR:  EQU     3FB3H                               ;RESET PATCH VARIABLE.  0X3FB4 Size of Patch
PATCH_CHK:  EQU     3FB5h                               ;RESET PATCH CHECKSUM
PATCH_ADR:  EQU     3FB6H                               ;RESET PATCH ADDRESS. 0x3FB6-0x3FB7
USER_TBL:   EQU     3FC0H - 2                           ;User Table -2
RST_FLAG:   EQU     3FFFH                               ;Reset Flag
JMON_DISS:  EQU     4000H                               ;JMON DISSASEMBLER ADDRESS START LOCATION 
JMON_JUMP:  EQU     381EH                               ;START OF THE JUMP TABLE IN THE JMON UTILITIES
J_MINT:     EQU     0800H                               ;MINT LOCATION FOR BMON
J_BASIC:    EQU     1000H                               ;TINY BASIC LOCATION FOR BMON
J_GAMES:    EQU     18E0H                               ;GAMES LOCATION FOR BMON
PLAY_TUNE:  EQU     1D60H                               ;TUNE ROUTINE

;IO Port ASSIGNMENTS
KEYBOARD:   EQU     0x00                                ;KEYBOARD ENCODER
DSCAN:      EQU     0x01                                ;DISPLAY CATHODE DRIVER LATCH
DSEGMENT:   EQU     0x02                                ;DISPLAY SEGMENT DRIVER LATCH

;DAT BOARD
P_DAT:      EQU     0x00                                ;DAT BOARD LATCH COMBINED ON KEYBOARD LATCH
P_LCDDATA:  EQU     0x84                                ;LCD DATA REGISTER
P_LCDINST:  EQU     0x04                                ;LCD INSTRUCTION REGISTER

;KEYBOARD REFERENCES
K_PLUS:     EQU     0x10                                ;+ KEY
K_MINUS:    EQU     0x11                                ;- KEY
K_GO:       EQU     0x12                                ;GO KEY
K_ADDR:     EQU     0x13                                ;ADDRESS KEY


;AT THE START OF JMON, HL IS SAVED IN ITS SINGLE STEPPER BUFFER ADD THE SOFT RESET DISPLAY
;VALUE IS PLACED IN THE CURRENT EDIT LOCATION BUFFER. THE ROUTINE THEN IS CONTINUED AT $0068.
ORG     $0000
            LD      (HL_SAVE), HL                       ;SAVE HL PART OF REGISTER SAVE
            LD      HL, (V_ALT_ADDR)                    ;GET SOFT RESET INITIAL EDIT
            JR      MON_START                           ;LOCATION AND CONTINUE AT 006B

;RST 08 AND RST 10 (CF AND D7)
;THESE TWO COMBINE TOGETHER TO SIMULATE A HALT INSTRUCTION. THIS IS DONE BY LOOPING UNTIL
;THE CURRENT (IF ANY) KEY PRESS IS RELEASED (RST 08), AND THEN LOOPING UNTIL A NEW KEY
;PRESS IS DETECTED (RST 10).

RST08:      RST     20H                                 ;TEST FOR KEY PRESS
            JR      Z, RST08                            ;LOOP IF KEY PRESSED
            NOP                                         ;ELSE
            NOP                                         ;MOVE
            NOP                                         ;TO
            NOP                                         ;NEXT
            NOP                                         ;RST
RST10:      RST     20H                                 ;TEST FOR KEY AGAIN
            JR      NZ, RST10                           ;LOOP IF KEY NOT PRESSED
            AND     0x1F                                ;MASK OFF JUNK BITS
            LD      I, A                                ;STORE IN INTERRUPT REGISTER
            RET                                         ;DONE

;RST 18 (DF) AND RST 20 (E7)
;RST 18 CALLS THE LED SCAN ROUTINE ONCE THEN MOVES ON INTO RST 20 THAT THEN CALLS A KEYBOARD
;READ ROUTINE.
;THE KEYBOARD MUST BE READ CONTINUOUSLY OVER A PERIOD OF TIME, AS THE DATA AVAILABLE SIGNAL
;(BIT 6, PORT 3) (USUALLY) PULSES, WHEN A KEY IS PRESSED, IN TIME WITH THE KEY ENCODER
;CHIP'S SCANNING. IF THE KEY BOARD IS READ ONLY ONCE EVERY SECOND, THEN THE SOFTWARE MAY
;AND PROBABLY) WILL TARE SEVERAL SECONDS TO DETECT THE KEY.
;THE NUMBER OF READ CYCLES FOR THE KEYBOARD IS LOADED INTO B.

RST18:      PUSH    HL                                  ;SAVE HL
            PUSH    DE                                  ;AND DE
            CALL    LED_SCAN                            ;CALL SCAN ROUTINE
            POP     DE                                  ;RECOVER DE
            POP     HL                                  ;AND HL
            NOP                                         ;NEXT RST
RST20:      PUSH    BC                                  ;SAVE BC
            LD      B, 0x20                             ;B = NUMBER OF KEYBOARD SCAN LOOPS
            CALL    KEY_READ                            ;CALL KEY READER/VALIDATER
            POP     BC                                  ;RECOVER BC
            RET                                         ;DONE

;RST 28 (EF)
;START STEPPING FROM THE INSTRUCTION FOLLOWING THE RST 28
RST28:      EX      (SP), HL                            ;GET RETURN ADDRESS FROM THE STACK
            LD      (STEP_NEXT), HL                     ;PUT IN "NEXT PC" BUFFER
            EX      (SP), HL                            ;FIX UP STACK
            EI                                          ;ENABLE INTERRUPTS
            RET                                         ;STEPPING WILL OCCUR AFTER RETURN
            DB      0xFF                                ;SPARE

;RST 30 (F7)
;TEST THE BUSY STATE OF THE LCD AND LOOP WHILE BUSY
RST30:      IN      A, (P_LCDINST)                      ;READ STATUS BIT FROM LCD
            RLCA                                        ;PUT IN CARRY
            JR      C, RST30                            ;LOOP IF LCD BUSY
            RET                                         ;DONE
            DB      0xFF,0xFF                           ;SPARE

;RST 38 (FF)
;INTERRUPT HANDLER FOR STEPPER AND BREAK-POINTS
RST38:      JP      STEPPER                             ;JUMP TO STEPPER ROUTINE
            DB      0xFF,0xFF,0xFF,0xFF,0xFF,0xFF       ;SPARE

;JUMP TABLE FOR EXTERNAL SOFTWARE TO USE JMON ROUTINES
L0041:      JP      MENU_RTN                            ;MENU ROUTINE
L0044:      JP      PERI_RTN                            ;PERIMETER HANDLER ENTRY
L0047:      JP      MENU_SFT                            ;SOFT MENU ENTRY
L004A:      JP      TXCHAR                              ;TRANSMIT BYTE
L004D:      JP      RXCHAR                              ;RECIEVE BYTE
L0050:      JP      PERI_SFT                            ;SOFT PERIMETER HANDLER ENTRY
L0053:      JP      BITIME                              ;BIT TIME DELAY
L0056:      JP      ASCII_SCRL                          ;ASCII SCROLL ROUTINE
L0059:      JP      PLAY_TUNE                           ;PLAY TUNE ROUTINE
            DB      0xFF,0xFF                           ;SPARE

;SHIFT-2 ROUTINE
;THIS STORES THE CURRENT EDIT LOCATION IN THE "NEXT PC" BUFFER. THE INTERRUPTS ARE THEN
;ENABLED AND THE PROGRAM JUMPS TO THE USER ROUTINE TO BE STEPPED. STEPPING OCCURS AT THE
;CURRENT EDIT LOCATION (CEL).
FN_STEPPER: LD      HL, (V_CEL)                         ;PUT CURRENT EDIT LOCATION IN
            LD      (STEP_NEXT), HL                     ;"NEXT PC" BUFFER
            EI                                          ;ENABLE INTERRUPTS
            JP      (HL)                                ;START STEPPING

;NMI HANDLER (IMMEDIATE RETURN)
            RETN                                        ;IGNORE NMI
            RST     38H                                 ;RESERVED
            RST     38H                                 ;FOR A "Post Burn"
            RST     38H                    

;CONTINUATION OF MONITOR
MON_START:  IM      1                                   ;SET INTERRUPT MODE 1 FOR STEPPER
            LD      (V_CEL), HL                         ;STORE SOFT RESET INITIAL CEL
            LD      HL, MON_START2                      ;LOAD HL WITH RE-ENTRY ADDRESS
            JP      SAVE_REGS                           ;JUMP TO SAVE REGISTERS


;RE-ENTRY POINT AFTER SAVING REGISTERS
MON_START2: LD      SP, V_KEY                           ;SET STACK (to the Keyboard Buffer??)
            ;CALL    RST_PATCH                           ;CALL RESET PATCH HANDLER
            NOP
            NOP
            RST     20H                                 ;LOOK FOR FORCED HARD RESET
            JR      Z, HARD_RST                         ;JUMP KEY PRESSED TO HARD RESET
            LD      A, (RST_FLAG)                       ;CHECK HARD/RESET FLAG
            CP      0xAA                                ;FOR AA
            JR      Z, SOFT_RST                         ;JUMP TO SOFT RESET IF AA

;HARD RESET
;MONITOR DEFAULT VARIABLES ARE RE-BOOTED AND USER PATCHES MASKED OFF.

HARD_RST:   LD      HL, DEF_VARS                        ;LOAD HL WITH START OF JMON DEFAULT
            LD      DE, V_KEY                           ;VARIABLES ROM TABLE
            LD      BC, 0x002B                          ;DE IS THE RAM DE(stination)
            LDIR                                        ;AND BC THE COUNT: MOVE TABLE
            LD      B, 0x04                             ;MASK OF THE FOUR USER PATCHES
            LD      A, 0xC9                             ;BY PUTTING A RETURN AT THE FIRST
L0095:      LD      (DE), A                             ;LOCATION OF EACH
            INC     DE                                  ;
            INC     DE                                  ;
            INC     DE                                  ;
            DJNZ    L0095                               ;
            CALL    LCD_RESET                           ;INITIALIZE/TEST FOR THE LCD
            LD      A, 0xAA
           ; XOR     A                                   ;CLEAR HARD/SOFT
            LD      (RST_FLAG), A                       ;RESET FLAG

;THIS SECTION IS THE SOFT RESET SECTION. IT IS ALSO PART OF THE HARD RESET SECTION.
SOFT_RST:   LD      HL, JMON_DISS                       ;TEST FOR JMON DISASSEBLER ROM
            LD      A, (HL)
            CP      0x21                                ;AND CALL ITS RESET ROUTINE
            CALL    Z, JMON_DISS                        ;IF REQUIRED
            CALL    BEEPBEEP                            ;CALL RESET TONE ROUTINE (BEEP BEEP)
FN_S_RST:   XOR     A                                   ;CLEAR MONITOR CONTROL BYTE
            LD      (V_MCB), A                          ;0 = DATA MODE, NO NIBBLES ENTERED

;EACH TIME A KEYBOARD INPUT OR USER PATCH "PLANT", IS PROCESSED, THE PROGRAM JUMPS BACK
;TO HERE SO THE DISPLAYS MAY BE UP-DATED.

J_DISPUPD:  LD      HL, (V_CEL)                         ;GET CURRENT EDIT LOCATION (CEL)
            LD      BC, (V_DISPLAY)                     ;AND DISPLAY BUFFER ADDRESS
            CALL    HL_2_DIS                            ;AND CONVERT CEL TO DISPLAY CODE
            LD      A, (HL)                             ;AND THEN CONVERT CONTENTS OF
            CALL    A_2_DISP                            ;CEL TO DISPLAY CODE
            CALL    SET_DOTS                            ;CALL THE SET DOTS ROUTINE
            CALL    SCAN_IO                             ;CALL SCAN/KEY/LCD/PATCH ROUTINE

;THE SECTION BELOW IS EXECUTED WHEN EITHER A KEY OR KEY "PLANT" IS DETECTED IN THE
;SCAN/KEY/LCD/PATCH ROUTINE ROUTINE
KEY_MGMT:
            LD      HL, (V_CEL)                         ;POINT HL TO CURRENT EDIT LOCATION
            LD      C, A                                ;PRESERVE INPUT KEY IN C
            LD      A, (V_MCB)                          ;GET MONITOR CONTROL BYTE (MCB)
            BIT     4, A                                ;TEST FOR ADDRESS OR FUNCTION MODE
            LD      B, A                                ;STORE MCB IN B
            LD      A, C                                ;GET INPUT KEY BACK IN A
            JR      NZ, KEY_ADDR                        ;JUMP IF ADDRESS OR FUNCTION MODE
KEY_PLUS:   CP      K_PLUS                              ;TEST FOR "+"
            JR      NZ, KEY_MINUS                       ;JUMP IF NOT TO TEST FOR "-"

;"+" KEY HANDLER-(WHEN IN DATA MODE ONLY)

            INC     HL                                  ;ADD 1 TO CURRENT EDIT LOCATION

;COMMON CEL AND MCB UP-DATER
;SEVERAL SECTIONS JUMP HERE TO STORE AN UP-DATED CEL AND CLEAR THE NIBBLE COUNTER.

L00D8:      LD      (V_CEL), HL                         ;STORE CEL
            LD      A, B                                ;GET MCB

;COMMON MCB UP-DATER
;SOME KEY HANDLER SECTION THAT DON'T REQUIRE.A NEW CEL (OR HAVE ALREADY STORED IT) JUMP HERE.

L00DC:      AND     0xFC                                ;CLEAR NIBBLE COUNTER
            LD      (V_MCB), A                          ;STORE MCB
L00E1:      JR      J_DISPUPD                           ;JUMP BACK TO UPDATE DISPLAY
KEY_MINUS:  CP      K_MINUS                             ;TEST FOR "-"
            JR      NZ, KEY_GO                          ;JUMP IF NOT TO TEST FOR "GO"

;"-" KEY HANDLER (WHEN IN DATA MODE ONLY)
            DEC     HL                                  ;DECREASE CEL ADDRESS BY ONE
            JR      L00D8                               ;JUMP TO COMMON CEL AND MCB UP-DATER
KEY_GO:     CP      K_GO                                ;TEST FOR GO
            JR      NZ, KEY_ADDR                        ;JUMP IF NOT TO TEST FOR "AD"

;"GO" HANDLER (WHEN IN DATA MODEONLY)
            LD      A, (V_ALT_ADDF)                     ;TEST FOR ALTERNATE GO ADDRESS
            CP      0xAA                                ;IF (3F23)=AA
            JR      Z, L00FA                            ;JUMP IF SET FOR ALTERNATE GO ADDR
            LD      HL, (V_CEL)                         ;ELSE GET CURRENT EDIT LOCATION
            JR      L00FD                               ;SKIP ALTERNATE JUMP ADDRESS FETCH
L00FA:      LD      HL, (V_ALT_ADDR)                    ;GET ALTERNATE GO ADDRESS
L00FD:      LD      DE, DO_DISP                         ;PUT RETURN ADDRESS ON STACK
            PUSH    DE
            JP      (HL)                                ;START USER EXECUTION

;TEST HERE FOR ADDRESS KEY. IF THE KEY PRESSED IS NOT THE ADDRESS KEY, THEN A JUMP IS
;PERFORMED. OTHERWISE THE ADDRESS KEY IS PROCESSED.

KEY_ADDR:   CP      0x13                                ;TEST FOR ADDRESS KEY
            JR      NZ, L0111                           ;0= IF NOT TO DATA KEY HANDLER
            LD      A, B                                ;GET MONITOR CONTROL BYTE (MCB)
            BIT     5, B                                ;TEST FOR FUNCTION MODE AND JUMP TO
            JR      NZ, L010D                           ;CLEAR FUNCTION MODE BITS IF SO
            XOR     0x10                                ;ELSE TOGGLE ADDRESS MODE BIT
L010D:      AND     0xD3                                ;CLEAR ALL FUNCTION MODE BITS
            JR      L00DC                               ;LOOP BACK TO COMMON MCB UP-DATER

;A TEST FOR ADDRESS/FUNCTION MODE IS DONE. IF IN ADDRESS OR FUNCTION MODE A JUMP IS PERFORMED.
L0111:      LD      A, B                                ;GET MCB
            BIT     4, A                                ;TEST FOR ADDRESS OR FUNCTION MODE
            JR      NZ, KEY_CTRL                        ;JUMP IF EITHER MODE

;A TEST FOR SHIFT IS DONE AND A JUMP IS PERFORMED IF IN THE SHIFT MODE TO THE FUNCTION/SHIFT HANDLER.
            IN      A, (KEYBOARD)                       ;TEST FOR THE SHIFT KEY
            BIT     5, A                                ;AND JUMP IF SHIFT IS PRESSED
            JR      Z, KEY_FUNC                         ;TO THE FUNCTION HANDLER

;ANY TIME A DATA KEY IS PRESSED WHILE IN THE DATA MODE, IT IS PROCESSED STARTING HERE.
KEY_DATA:   LD      A, B                                ;GET MCB
            AND     0x03                                ;MASK IT DOWN TO BYTE COUNTER
            CP      0x02                                ;AND TEST FOR TWO NIBBLES ENTERED
            LD      A, B                                ;INPUT KEY VALUE BACK IN A
            JR      NZ, L0132                           ;JUMP IF NOT READY FOR AUTO INC
            PUSH    AF                                  ;SAVE MCB
            LD      A, (V_AUTO)                         ;TEST AUTO INC MASK
            OR      A                                   ;IF NOT ZERO THEN JUMP AS USER
            JR      NZ, L012F                           ;HAS SWITCHED OFF AUTO INC MODE
            INC     HL                                  ;ELSE INCREMENT CEL BEFORE ENTERING
            LD      (V_CEL), HL                         ;NEW NIBBLE AND STORE NEW CEL
L012F:      POP     AF                                  ;RECOVER MON CONTROL BYTE IN A
            AND     0xFC                                ;CLEAR BYTE COUNTER (BITS 0 AND 1)
L0132:      INC     A                                   ;ADD ONE TO NIBBLE COUNTER
            LD      (V_MCB), A                          ;STORE IT
            LD      A, (V_KEY)                          ;GET INPUT KEY FROM INPUT BUFFER
            JR      L014C                               ;JUMP TO ENTER IT

;TEST HERE FOR A CONTROL KEY WHILE IN EITHER THE ADDRESS OR FUNCTION MODE AND JUMP TO
;ENCODE THE FUNCTION NUMBER BITS (2 AND 3 OF MCB). IF NOT A CONTROL KEY, THEN TEST FOR
;THE FUNCTION MODE AND JUMP TO FUNCTION JUMP CONTROL IF SO, ELSE SERVICE DATA KEY FOR
;ADDRESS MODE.

KEY_CTRL:   LD      A, (V_KEY)                          ;GET INPUT KEY FROM INPUT BUFFER
            BIT     4, A                                ;TEST FOR CONTROL KEY (+,- OR GO)
            JR      NZ, ENC_FUNC                        ;JUMP IF CONTROL TO FUNCTION ENCODER
            BIT     5, B                                ;TEST FUNCTION MODE
            JR      NZ, KEY_FUNC                        ;JUMP IF SO TO FUNCTION JUMP CONTROL

;DATA KEY PRESS WHILE IN THE ADDRESS MODE
            LD      HL, V_CEL                           ;POINT HL TO CEL BUFFER
            RLD                                         ;AND SHIFT IN THE NEW NIBBLE
            INC     HL                                  ;AND MOVE THE OTHERS ACROSS
L014C:      RLD                                         ;THIS RLD USED BY DATA MODE ALSO
L014E:      JR      L00E1                               ;JUMP (VIA A JUMP) TO UP-DATE DISPLAYS

;FUNCTION AND SHIFT JUMP CONTROL
;BITS 2 AND 3 OF THE MONITOR CONTROL BYTE (MCB) ARE THE FUNCTION IDENTIFIER BITS.
;IF BOTH ARE ZERO THEN EITHER FUNCTION 1 IS SELECTED OR NO FUNCTION IS SELECTED. BECAUSE
;THIS IS THE ALSO THE NO FUNCTION MODE ENABLED STATE, THE SHIFT KEY, WHICH DOES NOT AFFECT
;THE MONITOR CONTROL BYTE, WILL ALSO WILL INVOKE FUNCTION 1. (THEREFORE THIS ROUTINE DOES
;NOT NEED TO TEST FOR THE SHIFT KEY).
;IF BIT 2 IS HIGH THEN FUNCTION 2 IS SELECTED AND IF BIT 3 IS HIGH THEN FUNCTION 3 IS
;SELECTED.
;DURING THIS ROUTINE, HL IS LOADED TO THE BASE OF THE REQUIRED JUMP TABLE MINUS TWO BYTES
;(ONE ENTRY). THIS IS BECAUSE THE OFFSET PROVIDED FROM THE KEYBOARD HAS BEEN INCREMENTED
;BY ONE. THIS SAVES TESTING FOR ZERO INPUT WHICH WOULD NOT ALLOW THE TABLE ACCESSING TO
;WORK CORRECTLY. THE REQUIRED BASE IS FOUND BY EXAMINING THE STATE OF THE BITS 2 AND 3 OF
;THE MONITOR CONTROL BYTE (MCB) AND LOADING HI, ACCORDINGLY.
;AS EACH ENTRY IS TWO BYTES LONG, THE TABLE POINTER (THE VALUE INSIDE HL), IS INCREMENTED
;TWICE FOR EACH DECREMENT OF THE INPUT VALUE (FROM THE KEYBOARD). WHEN THE REQUIRED TABLE
;ENTRY IS FOUND, 17 IS PUT' INSIDE CEL (VIA_ DE) AND THE ROUTINE JUMPS TO PART OF THE "GO"
;KEY ROUTINE TO CREATE A RETURN ADDRESS ON THE STACK AND EXECUTE THE SELECTED ROUTINE.

KEY_FUNC:   LD      A, B                                ;PUT MONITOR CONTROL BYTE IN A
            AND     0x0C                                ;MASK IT DOWN TO FUNCTION BITS
            LD      HL, L07E0 - 2                       ;JMON FUNCTION JUMP TABLE BASE -2
            JR      Z, L0162                            ;JUMP IF FUNCTION 1 OR SHIFT
            LD      HL, USER_TBL                        ;LOAD HL WITH USER TABLE -2
                                                        ;*** Value is 3FBE as User Table is at 3FC0
            CP      0x04                                ;TEST FOR FUNCTION 2
            JR      Z, L0162                            ;JUMP IF FUNCTION 2 (USER FUNCTION)
            LD      HL, JMON_JUMP                       ;OTHERWISE MUST BE FUNCTION 3
L0162:      LD      A, (V_KEY)                          ;GET INPUT KEY FROM INPUT BUFFER
            INC     A                                   ;ADD ONE IN CASE IT WAS ZERO
            LD      B, A                                ;PUT IN B TO USE AS A LOOP COUNTER
L0167:      INC     HL                                  ;LOOK THROUGH TABLE
            INC     HL                                  ;FOR RIGHT JUMP VECTOR
            DJNZ    L0167
            LD      E, (HL)                             ;PUT IT IN HL
            INC     HL                                  ;VIA DE
            LD      D, (HL)
            EX      DE, HL                              ;JUMP TO CREATE RETURN ADDRESS AND
            JR      L00FD                               ;EXECUTE SELECTED ROUTINE

;FUNCTION NUMBER ENCODER
;THIS SECTION ENCODES THE FUNCTION IDENTIFIER BITS (BITS 2 AND 3) IN THE MONITOR CONTROL
;BYTE (BITS 2 AND 3) THEN SETS THE FUNCTION ENABLE BIT (BIT 5).
;THE FUNCTION IDENTIFIER BITS ARE DERIVED FROM THE LEAST TWO SIGNIFICANT BITS OF THE INPUT
;CONTROL KEY (+, AND GO). THESE ARE SHIFTED LEFT TWICE TO ALIGN THEM TO THE FUNCTION
;SELECT BITS (BITS 2 AND 3) IN THE MCB. THE INPUT CONTROL KEY IS IN THE ACCUMULATOR ON
;ENTRY AND THE MONITOR CONTROL BYTE (MCB) IN B.

ENC_FUNC:   AND     0x03                                ;MASK DOWN CONTROL KEY
            RLCA                                        ;SHIFT IT LEFT TWICE TO ALIGN BITS 0
            RLCA                                        ;AND 1 TO FUNCTION IDENTITY BITS IN MCB
            OR      0x20                                ;SET FUNCTION MODE ENABLED FLAG
            LD      C, A                                ;SAVE IN C
            LD      A, B                                ;GET CURRENT MCB
            AND     0xD3                                ;CLEAR ANY PREVIOUS FUNCTION BITS
            OR      C                                   ;MERGE TOGETHER
            LD      (V_MCB), A                          ;STORE MCB
            JR      L014E                               ;JUMP VIA JUMPS TO UP-DATE DISPLAYS

;THIS IS THE SCAN/KEY/LCD/PATCH ROUTINE. THIS ROUTINE LOOPS SCANNING THE LED DISPLAY AND
;SERVICING THE "DURING LOOP" USER PATCH UNTIL A KEY PRESS IS VALIDATED BY THE AUTO-KEY
;REPEAT SECTION. THE INPUT KEY IS RETURNED IN THE ACCUMULATOR AND IN THE INPUT BUFFER AT
;3F20 WITH THE ZERO FLAG SET AND CARRY CLEARED.
;THREE PATCHES ARE SUPPORTED IN THIS ROUTINE. THEY ARE A PATCH BEFORE LOOP, A PATCH DURING
;THE LOOP AND A PATCH AFTER A VALID KEY PRESS.
;THE "PLANT" IS A VALUE INSERTED INTO THE INPUT BUFFER (3F20) BY THE DURING LOOP PATCH.
;THE "PLANT" VALUE IS IDENTIFIED BY BIT 7 OF THE INPUT BUFFER BEING SET. BIT 7 IS RESET
;BEFORE RETURNING TO SERVICE THE PLANT.
;THIS ROUTINE USES A BYTE AT 3F2A, CALLED THE AUTO KEY STATUS BYTE AS A FLAG AND TIMER
;TO GENERATE THE AUTO REPEAT DELAY.
J_SCANKEY:
            CALL    LCD_DISP                            ;CALL LCD ROUTINES
            CALL    PATCH_BEF                           ;CALL PRE-SCAN USER PATCH
L0187:      CALL    LED_SCAN                            ;CALL SCAN
            CALL    PATCH_DUR                           ;CALL USER "DURING LOOP" PATCH
            LD      HL, V_KEY                           ;TEST KEY INPUT BUFFER BIT 7 FOR A
            BIT     7, (HL)                             ;"PLANT" INSERTED BY USER DURING
            RES     7, (HL)                             ;PATCH: RESET BIT 7 RETURN TO
            RET     NZ                                  ;SERVICE "PLANT" IF BIT 7 NOT ZERO
            RST     20H                                 ;TEST FOR KEY PRESS VIA RST 20
            LD      HL, V_KAUTO                         ;SET HL TO POINT TO AUTO KEY STATUS
            JR      C, L019F                            ;JUMP IF A KEY IS PRESSED
            LD      (HL), 0x80                          ;ELSE SET AUTO KEY STATUS TO
            JR      L0187                               ;NO KEY STATE AND CONTINUE LOOP
L019F:      CALL    KEY_GET                             ;CALL UNIVERSAL KEY INPUTTER
            BIT     7, (HL)                             ;TEST AUTO KEY STATUS FOR FIRST KEY
            JR      NZ, L01B6                           ;JUMP IF SO TO SET LONG KEY DELAY
            DEC     (HL)                                ;ELSE COUNT DOWN KEY DELAY
            JR      NZ, L0187                           ;LOOP IF NOT READY FOR KEY REPEAT
            LD      (HL), 0x0C                          ;ELSE SET SHORT TIME DELAY BETWEEN
L01AB:      CALL    PATCH_AFT                           ;KEYS: CALL USER "AFTER KEY" PATCH
            CALL    BEEP                                ;CALL KEY TONE
            XOR     A                                   ;SET ZERO FLAG AND CLEAR CARRY
            LD      A, (V_KEY)                          ;PUT INPUT KEY IN A
            RET                                         ;AND RETURN FOR KEY SERVICE
L01B6:      LD      (HL), 0x70                          ;SET KEY TIMER FOR LONG DELAY
            JR      L01AB                               ;JUMP TO SERVICE PATCH, TONE ETC.

;THIS IS THE LED SCAN ROUTINE.
J_LEDSCAN:
            LD      B, 20H                              ;B IS THE SCAN BIT
            LD      HL, (V_DISPLAY)                     ;GET ADDRESS OF DISPLAY BUFFER
L01BF:      LD      A, (HL)                             ;GET FIRST BYTE
            OUT     (DSEGMENT), A                       ;AND OUTPUT IT TO SEGMENTS
            LD      A, B                                ;GET SCAN BIT
            OUT     (DSCAN), A                          ;OUTPUT IT TO COMMONS
            LD      B, 40H                              ;CREATE SHORT
L01C7:      DJNZ    L01C7                               ;DELAY IN B
            INC     HL                                  ;INCREASE HL TO NEXT DISPLAY BYTE
            LD      B, A                                ;GET SCAN BIT BACK IN B
            XOR     A                                   ;CLEAR THE LAST PORT OUTPUTTED TO
            OUT     (DSCAN), A                          ;TO PREVENT "GHOSTING"
            RRC     B                                   ;SHIFT SCAN BIT ACROSS TO NEXT
            JR      NC, L01BF                           ;COMMON: WHEN SCAN BIT FALLS INTO
            OUT     (DSEGMENT), A                       ;CARRY SCAN IS TERMINATED: CLEAR
            RET                                         ;PORT 2 AND RETURN

;THIS ROUTINE CONVERTS HL TO DISPLAY CODE AND STORE THE DISPLAY CODE IN A BUFFER POINTED
;TO BY BC.
J_HL2CODE:
            LD      A, H                                ;PUT H IN A
            CALL    A_2_DISP                            ;CONVERT A TO DISPLAY CODE
            LD      A, L                                ;NOW DO FOR L

;THIS SECTION CONVERTS THE BYTE IN A TO TWO DISPLAY BYTES.
J_A2CODE:
            PUSH    AF                                  ;SAVE A
            RLCA                                        ;SHIFT MSN TO LSN PLACE
            RLCA                                        ;FOR NIBBLE AT A TIME CONVERSION
            RLCA
            RLCA
            CALL    L01E3                               ;CONVERT FIRST NIBBLE
            POP     AF                                  ;RECOVER A TO CONVERT SECOND NIBBLE
L01E3:      AND     0x0F                                ;MASK OF HIGH NIBBLE
            LD      DE, SEG_TBL                         ;SET DE TO BASE OF CONVERSION
            ADD     A, E                                ;TABLE: ADD A TO BASE
            LD      E, A                                ;UPDATE POINTER
            LD      A, (DE)                             ;GET DISPLAY CODE
            LD      (BC), A                             ;STORE IN DISPLAY BUFFER
            INC     BC                                  ;INCREMENT DISPLAY BUFFER POINTER
            RET                                         ;NIBBLE CONVERSION DONE

;SET DOTS
;THIS ROUTINE SETS THE DOTS IN THE DISPLAY BUFFER. IF IN ADDRESS MODE THEN 4 DOTS ARE SET
;IN THE ADDRESS DISPLAY BUFFER, IF IN A FUNCTION MODE, THEN ONE DOT IN THE ADDRESS DISPLAY
;- RIGHT MOST FOR FUNCTION 1 SECOND RIGHT FOR FUNCTION 2 AND THIRD RIGHT FOR FUNCTION 3.
;IF IN THE DATA MODE THEN 2 DOTS IN THE DATA DISPLAY BUFFER OR ONE DOT, ON THE RIGHTMOST
;DISPLAY, IF TWO NIBBLES HAVE BEEN ENTERED AND IN THE AUTO-INCREMENT MODE.
J_SETDOTS:
            LD      B, 0x02                             ;SET B FOR 2 DOTS
            LD      HL, (V_DISPLAY)                     ;PUT DISPLAY BUFFER IN HL
            LD      A, (V_MCB)                          ;GET MONITOR CONTROL BYTE (MCB)
            BIT     4, A                                ;TEST FOR ADDRESS OR FUNCTION MODE
            JR      Z, L0214                            ;JUMP IF NOT TO DO DATA DOTS
            BIT     5, A                                ;TEST ONLY FOR FUNCTION MODE
            JR      NZ, L0206                           ;JUMP IF FUNCTION MODE
            LD      B, 4                                ;ADDRESS MODE SO SET B FOR 4 DOTS
L0200:      SET     4, (HL)                             ;SET DOT IN DISPLAY BUFFER
            INC     HL                                  ;NEXT LOCATION
            DJNZ    L0200                               ;DO 4 TIMES
            RET                                         ;DONE

L0206:      DEC     B                                   ;FUNCTION MODE: SET B FOR ONE DOT
            BIT     3, A                                ;TEST FOR FUNCTION 3
            JR      NZ, L0211                           ;JUMP IF FUNCTION 3 TO ADD HL+1
            BIT     2, A                                ;TEST FOR FUNCTION 2
            JR      NZ, L0210                           ;JUMP IF FUNCTION 2 TO ADD HL+2
L020F:      INC     HL                                  ;INCREMENT HL TO POINT TO THE
L0210:      INC     HL                                  ;REQUIRED DISPLAY BYTE
L0211:      INC     HL                                  ;
            JR      L0200                               ;JUMP TO SET DOT
L0214:      INC     HL                                  ;DATA MODE: HL NOW POINTS TO SECOND
            LD      C, A                                ;LEFT MOST DISPLAY BUFFER: SAVE MCB
            LD      A, (V_AUTO)                         ;IN C: TEST AUTO INCREMENT ENABLE
            OR      A                                   ;FLAG
            JR      NZ, L020F                           ;JUMP IF NO AUTO INCREMENT TO SET BOTH
            BIT     1, C                                ;DATA DOTS: TEST BYTE COUNTER FOR 2
            JR      Z, L020F                            ;NIBBLES: JUMP IF NOT TO SET BOTH DATA
            INC     HL                                  ;DOTS: ELSE SKIP DOT ON ONE DISPLAY
            DEC     B                                   ;AND DECREASE DOT COUNT FROM 2 TO 1
            JR      L020F                               ;JUMP TO ADJUST HL AND SET DOTS

;MASKABLE RESET TONE ROUTINE
;IF 3F22 IS NOT ZERO THEN NO TONE
J_TONEX2:
            CALL    BEEP                                ;CALL TONE

J_TONE:
;MASKABLE TONE ROUTINE
            LD      A, (V_BEEP)                         ;TEST SOUND MASK
            OR      A                                   ;
            RET     NZ                                  ;NO TONE IF NOT ZERO
            LD      C, 0x40                             ;LOAD C WITH PERIOD
            LD      L, 0x31                             ;LOAD L WITH NUMBER OF CYCLES
            XOR     A                                   ;CLEAR A
L0231:      OUT     (DSCAN), A                          ;OUT TO SPEAKER
            LD      B, C                                ;
L0234:      DJNZ    L0234                               ;DELAY FOR PERIOD
            XOR     0x80                                ;TOGGLE SPEAKER BIT
            DEC     L                                   ;DECREMENT CYCLE COUNT
            JR      NZ, L0231                           ;LOOP UNTIL ZERO
            RET                                         ;DONE

;LCD ROUTINE
;IF 3F21 IS NOT ZERO, THEN LCD HAS BEEN MASKED OFF BY EITHER THE USER OR THE LCD
;INTIALIZER/TESTER ROUTINE AND NO ACTION IS TAKEN ON THE LCD. THE RST 30 (F7) IS USED
;EXTENSIVELY TO TEST AND WAIT FOR THE LCD BUSY FLAG. THROUGHOUT THESE NOTES, THE INVISIBLE
;INTERNAL CURSOR ON THE LCD IS REFERRED TO AS THE CURSOR, WHILE THE ">" ON THE LCD IS
;REFERRED TO AS THE PROMPT.
J_LCD:
            LD      A, (V_LCD)                          ;TEST LCD MASK
            OR      A
            RET     NZ                                  ;NOT ZERO = LCD NOT REQUIRED OR FITTED
            LD      A, 0x80                             ;SET LCD CURSOR TO HOME
            OUT     (P_LCDINST), A
            RST     30H                                 ;WAIT UNTIL LCD READY
            CALL    LCD_LINE1                           ;CALL SET-UP AND OUTPUT FIRST LINE
            LD      A, 0xC0                             ;SET CURSOR TO BOTTOM LINE
            OUT     (P_LCDINST), A
            RST     30H                                 ;WAIT
            CALL    LCD_LINE2                           ;CALL ROUTINE TO OUTPUT BOTTOM LINE
            JR      LCD_PROMPT                          ;JUMP TO PROMPT ROUTINE

;SET-UP
;MODIFY CURRENT EDIT LOCATION ADDRESS IN HL SO THAT IT POINTS TO A BYTE AT AN ADDRESS
;ENDING IN EITHER 0 OR 8.

LCD_LINE1:  LD      HL, (V_CEL)                         ;GET CEL AND PUT LOW BYTE IN A
            LD      A, L                                ;THEN MASK OFF THE 3 LOWEST BITS
            AND     0xF8                                ;AS THE ADDR OF THE FIRST BYTE ON
            LD      L, A                                ;THE LCD WILL END WITH 0 OR 8

;OUTPUT A LINE.  FIRST DISPLAY BASE ADDRESS THEN THE NEXT FOUR BYTES. EG:
;   0900>FF AA FF FF
;WHERE A RIGHT ARROW WILL BE PLACED ON THE CURRENT ADDRESS BYTE
LCD_LINE2:  CALL    HL_2_LCD                            ;CALL "HI TO ASCII OUTPUT"
            LD      B, 04                               ;SET B FOR 4 BYTES ON A LINE
L025F:      LD      A, 0x20                             ;LOAD A WITH ASCII SPACE
            OUT     (P_LCDDATA), A                      ;CHARATER AND OUTPUT IT
            RST     30H                                 ;WAIT
            LD      A, (HL)                             ;GET BYTE TO DISPLAY
            CALL    A_2_LCD                             ;CONVERT AND OUTPUT IT
            INC     HL                                  ;POINT TO NEXT BYTE
            DJNZ    L025F                               ;DO FOR 4 BYTES
            RET                                         ;DONE

;CONVERT HL TO ASCII (VIA CONVERT A) AND OUTPUT IT
HL_2_LCD:   LD      A, H                                ;CONVERT AND
            CALL    A_2_LCD                             ;OUTPUT H
            LD      A, L                                ;THEN L

;CONVERT A TO ASCII AND OUTPUT IT
A_2_LCD:    PUSH    AF                                  ;SAVE A FOR SECOND NIBBLE
            RRCA                                        ;SHIFT HIGH NIBBLE ACROSS
            RRCA                                        ;
            RRCA                                        ;
            RRCA                                        ;
            CALL    LCD_NIBBLE                          ;CALL NIBBLE CONVERTER
            POP     AF                                  ;RECOVER LOW NIBBLE
LCD_NIBBLE: AND     0x0F                                ;MASK OFF HIGH NIBBLE
            ADD     A, 0x90                             ;CONVERT TO
            DAA                                         ;ASCII
            ADC     A, 0x40                             ;USING THIS
            DAA                                         ;AMAZING ROUTINE
LCD_OUT:    OUT     (P_LCDDATA), A                      ;OUTPUT IT
            RST     30H                                 ;WAIT
            RET                                         ;DONE

;LCD PROMPT AND MODE WORD OUTPUT
;THE 3 LOWEST BITS OF THE CURRENT EDIT LOCATION (CEL) ARE USED AS A DISPLACEMENT WHICH IS
;ADDED TO A TABLE BASE. THE TABLE ENTRIES ARE THE LCD ADDRESSES OF THE PROMPT LOCATIONS.
;IF THE AUTO INCREMENT MODE IS ON AND 2 NIBBLES HAVE BEEN ENTERED, THE DISPLACEMENT IS
;INCREMENTED SO THAT THE NEXT PROMPT ADDRESS TABLE ENTRY WILL BE ACCESSED TO MOVE THE
;PROMPT TO ITS NEXT SCREEN LOCATION. THE TABLE IS 9 ENTRIES LONG. 8 ARE FOR THE SPACES
;BETWEEN THE DATA BYTES AND THE NINTH IS TO PARK THE PROMPT AT THE TOP LEFT-HAND CORNER
;WHEN A SCREEN CHANGE IS DUE

LCD_PROMPT: LD      A, (V_CEL)                          ;GET LOW BYTE OF CEL
            AND     0x07                                ;MASK IT DOWN TO THE 3 LOWEST BITS
            LD      C, A                                ;SAVE IN C
            LD      A, (V_AUTO)                         ;TEST FOR AUTO INCREMENT MODE
            OR      A                                   ;O=ON
            LD      A, (V_MCB)                          ;GET MCB
            LD      D, A                                ;PUT MCB IN D
            JR      NZ, L029B                           ;JUMP IF AUTO INCREMENT MODE OFF
            BIT     1, A                                ;TEST FOR 2 NIBBLES ENTERED: JUMP
            JR      Z, L029B                            ;IF NOT: ELSE INCREMENT
            INC     C                                   ;DISPLACEMENT TO ADVANCE TO
L029B:      LD      A, C                                ;NEXT PROMPT LOCATION ADDRESS
            LD      HL, LCDPMT_TBL                      ;LOAD HL WITH BASE OF PROMPT
            ADD     A, L                                ;TABLE AND ADD DISPLACEMENT
            LD      L, A                                ;PUT LOW BYTE OF TABLE ADDRESS
            LD      A, (HL)                             ;IN L AND GET PROMPT ADDRESS IN A
            OUT     (P_LCDINST), A                      ;AND OUTPUT PROMPT ADDRESS TO LCD
            RST     30H                                 ;WAIT
            LD      A, 0x3E                             ;LOAD A WITH ASCII FOR ">"
            OUT     (P_LCDDATA), A                      ;OUTPUT PROMPT
            RST     30H                                 ;WAIT

;OUTPUT MODE WORD TO BOTTOM LEFT CORNER OF THE LCD.
;IF THE MODE IS EITHER DATA OR ADDR, THEN THE FOUR ASCII BYTES ARE OUTPUTTED. IF IN THE
;FUNCTION MODE, THEN ONLY THREE BYTES FROM THE TABLE ARE OUTPUTTED AND THEN THE FUNCTION
;NUMBER IS CALCULATED AND OUTPUTTED.
;NOTICE THAT FROM THE TABLE BASE THE FIRST ENTRY (DATA) HAS A ZERO DISPLACEMENT WHILE THE
;SECOND (ADDR) HAS A DISPLACEMENT OF 4 AND THE THIRD (Fs-) HAS A DISPLACEMENT OF 12.
;IF YOU LOOK AT THE TABLE AT 07AD, YOU WILL SEE THAT IT IS STAGGERED WITH THE THIRD ENTRY
;12 BYTES AWAY FROM THE BASE.

            LD      A, 0xC0                             ;SET CURSOR TO BOTTOM LINE
            OUT     (P_LCDINST), A                      ;OUTPUT
            RST     30H                                 ;AND WAIT
            LD      A, D                                ;PUT MONITOR CONTROL BYTE (MCB) IN A
            RRCA                                        ;SHIFT MODE BITS TO BITS 2 AND 3
            RRCA                                        ;TO USE AS TABLE DISPLACEMENT
            LD      D, A                                ;SAVE IN D AND MASK OFF ALL BITS
            AND     0x0C                                ;EXCEPT THE 2 THAT FLAG BETWEEN DATA,
            LD      HL, LCDFNC_TBL                      ;ADDR AND FUNCTION: A=0 IF DATA, 4 IF
            ADD     A, L                                ;ADDR, 12 IF FUNCTION, NOTE THAT TABLE
            LD      L, A                                ;IS STAGGERED (SEE 07AD): ADD A TO BASE
            CP      0xBC                                ;IF A=BC THEN MODE IS FUNCTION MODE
            LD      BC, 0484H                           ;LOAD C WITH PORT, B WITH BYTE COUNT
            JR      Z, L02C7                            ;JUMP IF FUNCTION MDDE TO OUT 3 BYTES
L02C1:      OUTI                                        ;OUT (HL) TO (C) B=B-1
            RST     30H                                 ;HL=HL+1: WAIT FOR LCD BUSY FLAG
            JR      NZ, L02C1                           ;LOOP UNTIL B=0
            RET                                         ;DONE

L02C7:      LD      B, 0x03                             ;ONLY THREE BYTES FOR FUNCTION MODE
            CALL    L02C1                               ;CALL THE OUTPUT ROUTINE ABOVE
            LD      A, D                                ;PUT MCB (SHIFTED RIGHT TWICE) IN A
            AND     0x03                                ;MASK IT DOWN TO GET JUST THE FUNCTION
            ADD     A, 0x31                             ;NUMBER BITS: ADD ASCII "1"
            JR      LCD_OUT                             ;JUMP TO OUTPUT FUNCTION NUMBER

;-END OF MONITOR ROUTINES- (EXCEPT KEYBOARD READER AT 06AD)

;LCD PROMPT MOVING ROUTINES. (SHIFT AND FUNCTION 1)
;THESE ROUTINES ALTER THE CURRENT EDIT LOCATION ADDRESS AND STORE IT IN ITS BUFFER. WHEN
;THE RETURN IS DONE, JMON IS RE-ENTERED AT 00132 (VIA THE SOFT RE-ENTRY JUMP AT L3F45, THE
;ADDRESS OF WHICH HAS BEEN PLACED ON THE STACK BY PART OF THE "GO" ROUTINE).
FN_FORW4:   LD      DE, 0x0004                          ;DE= +4
L02D6:      LD      HL, (V_CEL)                         ;PUT CEL IN HL
            ADD     HL, DE                              ;ADD TO GET NEW CEL
            LD      (V_CEL), HL                         ;STORE IN CEL BUFFER
            RET                                         ;DONE

FN_BACK4:   LD      DE, 0xFFFC                          ;DE= -4
            JR      L02D6                               ;JUMP TO ADD
FN_BACK1:   LD      DE, 0xFFFF                          ;DE= -1
            JR      L02D6                               ;JUMP TO ADD
FN_FORW1:   LD      DE, 0x0001                          ;DE= +1
            JR      L02D6                               ;JUMP TO ADD
FN_FORW8:   LD      DE, 0x0008                          ;DE= +8
            JR      L02D6                               ;JUMP TO ADD
FN_BACK8:   LD      DE, 0xFFF8                          ;DE= -8
            JR      L02D6                               ;JUMP TO ADD

;RESET PATCH CHECKER.
;TESTS FOR PATCH REQUIREMENT AND UP TO THE FIRST 256 BYTES OF THE PATCH ROUTINE. THE
;CHECKSUM FEATURE ENSURES A WAY TO CHECK THAT THE PATCH OR PATCH VARIABLES HAVE NOT BEEN
;CORRUPTED BY A SYSTEM CRASH, OTHERWISE YOU MAY NEVER REGAIN CONTROL OF THE COMPUTER UNLESS
;YOU TURN IT OFF, (AND LOSE THE CONTENTS OF YOUR MEMORY - YOU CANNOT RECOVER IT BY A FORCED
;HARD RESET AS THE USER PATCH IS EXECUTED BEFORE THE FORCED HARD RESET TEST). (A FORCED
;HARD RESET IS WHEN A KEY IS HELD DOWN WHEN THE RESET KEY IS RELEASED).
;IF YOU HAVE A NON VOLATILE MEMORY AT 2000 THE SITUATION WOULD BE ABSOLUTELY HOPELESS
;WITHOUT THIS CHECKER ROUTINE.
;A VARIABLE CAN BE PASSED TO YOUR PATCH ROUTINE IN THE "C" REGISTER. TO DO THIS THE VARIABLE
;IS PLACED AT ADDRESS LOCATION 3FB3.

RST_PATCH:  LD      A, (PATCH_REQ)                      ;TEST FOR RESET PATCH REQUIRED
            CP      0xAA
            RET     NZ                                  ;RETURN IF NOT
            LD      BC, (PATCH_VAR)                     ;PUT NO OF BYTES IN B VARIABLE IN C
            LD      HL, (PATCH_STA)                     ;START IN HL
            XOR     A                                   ;CLEAR A
L0305:      ADD     A, (HL)                             ;ADD CHECKSUM
            INC     HL
            DJNZ    L0305                               ;UNTIL B=0
            LD      HL, PATCH_CHK                       ;POINT TO REQUIRED CHECKSUM
            CP      (HL)                                ;TEST FOR EQUAL
            RET     NZ                                  ;ABORT IF NOT
            LD      HL, (PATCH_ADR)                     ;ELSE GET START ADDR
            JP      (HL)                                ;AND DO RESET PATCH

;STEPPER ROUTINE
;THE STEPPER ROUTINE IS BROKEN UP INTO SEVERAL SECTIONS. THE FIRST IS THE REGISTER SAVE,
;WHERE ALL THE Z80 USER REGISTERS ARE STORED IN MEMORY.

STEPPER:    LD      (STEP_HL), HL                       ;STORE HL IN ITS REGISTER STACK SPOT
            LD      HL, STEP_CONT                       ;LOAD HL WITH RETURN ADDRESS - Was 0x0344

;MONITOR JUMPS TO HERE ON RESET TO PRESERVE USER REGISTERS.
SAVE_REGS:  LD      (RE_ENTRY), HL                      ;STORE RE-ENTRY ADDRESS IN BUFFER
            LD      HL, (STEP_NEXT)                     ;GET ADDRESS OF INSTRUCTION JUST
            LD      (STEP_PREV), HL                     ;STEPPED AND PUT IT IN "NEXT PC"
            LD      (STEP_SP), SP                       ;BUFFER: SAVE STACK POINTER VALUE
            POP     HL                                  ;GET RETURN ADDR, THIS IS THE ADDRESS
            LD      (STEP_NEXT), HL                     ;OF NEXT BYTE TO STEP: STORE IN
            LD      SP, STEP_SP                         ;"NEXT PC" BUFFER: LOAD REGISTER DUMP
            EX      AF, AF'                             ;STACK: PUSH ALTERNATE REGISTERS
            EXX                                         ;FIRST
            PUSH    HL                                  ;SAVE ALL REGISTERS
            PUSH    DE
            PUSH    BC
            PUSH    AF
            PUSH    IY
            PUSH    IX
            EX      AF, AF'
            EXX
            DEC     SP
            DEC     SP
            PUSH    DE
            PUSH    BC
            PUSH    AF
            LD      HL, (RE_ENTRY)                      ;RE-ENTER CALLING ROUTINE VIA
            JP      (HL)                                ;THE ADDRESS IT SUPPLIED AT 3F60
FN_REGDIS:
            LD      SP, STEP_REGS                       ;SHIFT 7 ROUTINE START (REG DISPLAY)

;THE REGISTERS HAVE BEEN SAVED. NOW THE DISPLAY AND KEYBOARD HANDLER IS SET UP. THE STACK
;IS DECREMENTED BY TWO TO POINT TO THE "PC" BUFFER. THE ADDRESS IN THE "PC" BUFFER IS THE
;ADDRESS OF THE INSTRUCTION JUST STEPPED.
;THE NUMBER OF THE FIRST REGISTER (1 FOR "PC") IS PUT INTO THE CURRENT REGISTER NUMBER
;BUFFER.

STEP_CONT:  LD      HL, DISP_STEP                       ;CREATE NEW DISPLAY BUFFER
            LD      (V_DISPLAY), HL                     ;
            DEC     SP                                  ;DECREASE SP BY 2 TO POINT TO THE
            DEC     SP                                  ;"PC" BUFFER

;WHEN UP-DATING THE DISPLAY, THE ROUTINE MAY JUMP BACK TO HERE IF THE FIRST DISPLAY IS REQUIRED.
L034C:      LD      A, 0x01                             ;SET UP FOR THE FIRST REGISTER (PC)
            LD      (STEP_CREG), A                      ;DISPLAY

;OR HERE IF IT HAS ALTERED THE CURRENT REGISTER NUMBER IN ITS STORAGE LOCATION (3F5A).
L0351:      LD      A, (STEP_CREG)                      ;DISPLAY LOOP STARTS HERE

;HL IS LOADED WITH THE STACK POINTER VALUE, (WHICH POINTS TO THE "PC" BUFFER), MINUS TWO.
;THE TWO IS SUBTRACTED BECAUSE AN EXTRA TWO WILL BE ADDED TO HL DURING THE REGISTER BUFFER
;CALCULATOR (IMMEDIATELY BELOW) AS THE NUMBER OF THE FIRST REGISTER IS 1 AND NOT ZERO.
            LD      HL, 0xFFFE                          ;HL=-2
            ADD     HL, SP                              ;HL=SP-2
L0358:      INC     HL                                  ;INCREMENT HL TO POINT TO THE
            INC     HL                                  ;CURRENT REGISTER BUFFER
            DEC     A                                   ;INDICATED BY THE NUMBER IN A
            JR      NZ, L0358

;HL NOW POINTS TO THE CURRENT REGISTER BUFFER. THIS SECTION PUTS THE REGISTER(S) CONTENT(S)
;INTO HL AND CONVERTS IT TO DISPLAY CODE AND STORE THE DISPLAY CODE IN THE DISPLAY BUFFER.

            LD      A, (HL)                             ;GET 16 BIT VALUE
            INC     HL                                  ;AND PUT IT
            LD      H, (HL)                             ;BACK INTO
            LD      L, A                                ;HL
            LD      BC, (V_DISPLAY)                     ;PUT DISPLAY BUFFER ADDRESS IN BC
            CALL    HL_2_DIS                            ;CALL HL TO DISPLAY CODE ROUTINE

;THIS SECTION CALCULATES THE ADDRESS OF THE REGISTER NAME FOR THE DATA DISPLAYS. THESE
;ARE STORED IN A TABLE. THE REQUIRED REGISTER NAME IS THEN TRANSFERRED TO THE DISPLAY
;BUFFER.

            LD      A, (STEP_CREG)                      ;GET REGISTER NUMBER
            PUSH    BC                                  ;PUT NEXT DISPLAY BUFFER
            POP     DE                                  ;LOCATION INTO DE(stination)
            LD      BC, 0x0002                          ;BC IS THE NUMBER OF DATA DISPLAYS
            LD      HL, REG_TBL                         ;HL=THE BASE OF THE NAME TABLE (MINUS 2)
L0373:      ADD     HL, BC                              ;ADD TO HL 2 FOR EACH
            DEC     A                                   ;REGISTER NUMBER TO ACCESS THE
            JR      NZ, L0373                           ;CURRENT REGISTER NAME
            LDIR                                        ;MOVE REGISTER NAME INTO RAM

;THE SCAN AND KEYBOARD ROUTINE ARE NOW CALLED (VIA THE RST 18). IF A VALID KEY IS PRESSED,
;THEN THE ZERO FLAG IS SET WHEN THE RST RETURNS.

STEP_DISP:  RST     18H                                 ;SCAN/KEY READ RST
            LD      HL, V_STEP_TMR                      ;(HL)=AUTO STEP CONTROL/TIMER BYTE
            JR      Z, STEP_KEY                         ;JUMP IF VALID KEY PRESSED

;NO KEY IS PRESSED SO THE ROUTINE CHECKS FOR THE AUTO REPEAT MODE ENABLED FLAG (BIT 7 AUTO
;STEP CONTROL/TIMER BYTE, ZERO IS AUTO STEP ENABLED) AND DECREMENTS THE COUNTER IF IT IS.
;IF THE COUNTER REACHES ZERO, THEN IT IS RELOADED AND THE ROUTINE JUMPS TO RECOVER THE
;REGISTERS AND STEP THE NEXT INSTRUCTION. IF NOT IN THE AUTO MODE OR THE COUNTER DOES NOT
;REACH ZERO, THEN THE ROUTINE LOOPS BACK TO SCAN THE DISPLAY AND WAIT FOR EITHER A KEY
;PRESS OR FOR THE COUNTER TO REACH ZERO.

            BIT     7, (HL)                             ;TEST FOR AUTO INCREMENT JUMP IF NOT
            JR      NZ, STEP_DISP                       ;ENABLED TO SCAN/KEY READ LOOP
            DEC     (HL)                                ;DECREMENT COUNTER: LOOP TO
            JR      NZ, STEP_DISP                       ;SCAN/KEY READ UNTIL COUNT=0

;AT THIS POINT THE AUTO-STEP DELAY HAS REACHED ZERO AND IS RELOADED WITH THE DELAY VALUE.
;A JUMP IS THEN DONE TO RECOVER THE REGISTERS AND STEP THE NEXT INSTRUCTION.
            LD      (HL), 0x30                          ;RESET AUTO STEP DELAY, JUMP TO RECOVER
            JR      STEP_DO_GO                          ;REGISTERS AND STEP NEXT INSTRUCTION

;KEY PROCESSING STARTS HERE
;THE AUTO-STEP IS DISABLED AND THEN THE KEY IS IDENTIFIED AND HANDLED.
;THE AUTO-STEP WILL BE RE-ENABLED IF THE KEY PRESSED IS A DATA KEY.

STEP_KEY:   LD      B, A                                ;SAVE KEY
            LD      (HL), 0xFF                          ;SET AUTO STEP CONTROL/TIMER BIT 7
            LD      HL, STEP_CREG                       ;THUS DISABLING THE AUTO REPEAT MODE
            LD      A, B                                ;POINT HI, TO CURRENT REG No. BUFFER
STEP_PLUS:  CP      K_PLUS                              ;PUT INPUT IN A,TEST IT FOR "+"
            JR      NZ, STEP_MINUS                      ;JUMP IF NOT TO TEST FOR "-"

;"+" KEY HANDLER
;THE CURRENT REGISTER NUMBER IS INCREMENTED AND THEN CHECK TO SEE THAT IT HAS NOT EXCEEDED
;THE HIGHEST REGISTER NUMBER (OC). IF IT HAS, THE ROUTINE JUMPS TO RESET THE CURRENT
;REGISTER NUMBER WITH 1, OTHERWISE IT JUMPS TO THE DISPLAY LOOP.

            INC     (HL)                                ;INCREMENT REGISTER NUMBER
            LD      A, (HL)                             ;AND CHECK TO SEE IF IT LARGER
            CP      0x0D                                ;THAN HIGHEST REG No. (0C): IF LOWER
            JR      C, L0351                            ;THAN OD JUMP TO DISPLAY LOOP ELSE
            JR      L034C                               ;JUMP TO SET REGISTER NUMBER TO 1

STEP_MINUS: CP      K_MINUS                             ;TEST FOR "-"
            JR      NZ, STEP_GO                         ;JUMP IF NOT

;"-" HANDLER
;ONE IS TAKEN FROM THE CURRENT REGISTER NUMBER AND THEN IT IS CHECKED FOR ZERO. IF IT
;BECOMES ZERO, THEN THE CURRENT REGISTER NUMBER IS SET TO THE HIGHEST REGISTER NUMBER (OC)
;TO WRAP-AROUND TO DISPLAY THE LAST REGISTER.
            DEC     (HL)                                ;SUBTRACT 1 FROM REGISTER NUMBER
            JR      NZ, L0351                           ;JUMP IF NOT 0 TO UP-DATE DISPLAY
            LD      (HL), 0x0C                          ;ELSE SET TO LAST REGISTER
            JR      L0351                               ;AND UP-DATE

;TEST FOR "GO"
STEP_GO:    CP      K_GO                                ;TEST FOR "GO" AND JUMP IF NOT
            JR      NZ, STEP_AD                         ;TO TEST FOR "AD" OR DATA KEY

;"GO" KEY
;THE GO KEY CAUSES STEPPING EXECUTION TO CONTINUE.
;BEFORE STEPPING IS CONTINUED THOUGH, THE KEYBOARD IS READ AND THE PROGRAM LOOPS UNTIL
;ALL KEYS ARE RELEASED. THIS IS TO SEPARATE KEY PRESSES MEANT FOR THE STEPPER AND THOSE
;FOR THE ROUTINE BEING STEPPED. ONCE ALL KEYS ARE RELEASED, ALL THE REGISTERS ARE POPPED
;OF THE REGISTER DISPLAY STACK, THE STACK IS RESTORED TO ITS "REAL" POSITION AND THE
;INTERRUPTS RE-ENABLED. THE RETURN ADDRESS FOR THE ROUTINE BEING STEPPED, STILL THERE ON
;THE TOP OF THE REAL STACK, IS USED AS THE RETURN ADDRESS.

STEP_DO_GO: RST     20H                                 ;WAIT UNTIL ALL KEYS ARE RELEASED
            JR      Z, STEP_DO_GO                       ;BEFORE RESTARTING
            POP     HL                                  ;RECOVER ALL
            POP     AF                                  ;REGISTERS
            POP     BC                                  ;IN
            POP     DE                                  ;THE
            POP     HL                                  ;REVERSE
            POP     IX                                  ;ORDER
            POP     IY                                  ;TO
            EX      AF, AF'                             ;HOW
            EXX                                         ;THEY
            POP     AF                                  ;STORED
            POP     BC
            POP     DE
            POP     HL
            EX      AF, AF'
            EXX
            LD      SP, (STEP_SP)                       ;AND STACK POINTER
            EI                                          ;RE-ENABLE THE INTERRUPTS
            RET                                         ;RET TO STEP NEXT INSTRUCTION

;TEST FOR "AD" KEY (RETURN TO JMON)
STEP_AD:    CP      K_ADDR                              ;TEST FOR "ADDR" KEY
            JR      NZ, STEP_DATA                       ;JUMP IF NOT TO ASSUME DATA KEY
            RST     00H                                 ;RETURN TO MONITOR

;DATA KEY HANDLER (ENABLE AUTO STEP)
STEP_DATA:  LD      A, 0x20                             ;SET AND ENABLE AUTO STEP IN THE
            LD      (V_STEP_TMR), A                     ;CONTROL/TIMER BYTE (BIT 7 LOW, 20
            JR      STEP_DISP                           ;CYCLES): JUMP TO DISPLAY LOOP
;-END OF STEPPER-

;START OF MENU
;MAIN MENU IS SET-UP HERE
;THE VARIABLES ARE MOVED FROM ROM TO RAM AND THE DISPLAY BUFFER IS SET TO 3F00.

;THE MENU CAN BE USED ANYWHERE PROVIDED THAT MENU VARIABLES ARE SET UP AT 0x880
FN_MENU:
            LD      HL, SIO_P_DRIVER                    ;LOAD HL WITH START OF MAIN MENU + SIO PERM
            LD      DE, PERI_SETUP                      ;VARIABLES: DE IS RAM DE(stination)
            LD      BC, 0018H                           ;BC IS THE COUNT
            LDIR                                        ;SHIFT VARIABLES

MENU_RTN:   LD      HL, DISP_BUFF                       ;PUT DISPLAY BUFFER AT 3F00
            LD      (V_DISPLAY), HL

;MENU DISPLAY LOOP STARTS HERE
;THE MENU ENTRY NUMBER (MEN), HOLDS THE NUMBER OF THE CURRENT MENU ENTRY ON THE DISPLAY.
;ALL ACTIONS OF THE MENU DRIVER CENTRE AROUND THIS BYTE.
;THE DISPLAY ON THE TEC LED DISPLAY IS GENERATED BY SHIFTING BOTH THE DATA AND ADDRESS
;DISPLAY CODES INTO THE RAM DISPLAY BUFFER.
;ALL THE POSSIBLE DATA AND ADDRESS DISPLAY CODES ARE STORED IN SEPARATE TABLES IN ROM,
;THE BASE OF EACH IS ADDRESSED BY THE CONTENTS OF MEMORY LOCATIONS 3F95 (DATA TABLE), AND
;3F93 (ADDRESS TABLE).
;THE FIRST MENU ENTRY IS DENOTED BY A ZERO VALUE IN THE MENU ENTRY NUMBER (MEN). THIS
;MEANS THAT THE POSSIBLE ZERO CONDITION MUST BY DETECTED AND THE TABLE ENTRY CALCULATOR
;SECTION SKIPPED OVER. WHEN ACCESSING THE DISPLAY TABLES, THE MENU ENTRY NUMBER IS
;DECREMENTED UNTIL ZERO AND EACH TIME AN OFFSET EQUAL TO THE LENGTH OF EACH TABLE ENTRY
;(4 FOR ADDR AND 2 FOR DATA TABLES) IS ADDED TO THE POINTERS.
;AFTER THE REQUIRED ENTRIES ARE FOUND, THEY ARE MOVED INTO THE RAM DISPLAY BUFFER.

MENU_DISP:  LD      A, (MENU_NO)                        ;GET MENU ENTRY NUMBER (MEN)
MENU_RTNT:  LD      DE, (MENU_D_TBL)                    ;DE POINTS TO DATA DISPLAY TABLE
            LD      HL, (MENU_A_TBL)                    ;HL POINTS TO ADDR DISPLAY TABLE
MENU_SFT:   LD      BC, 0004H                           ;BC IS BOTH AN INDEX OFFSET AND
            OR      A                                   ;BYTE COUNTER (USED BELOW): TEST
            JR      Z, L03F9                            ;A AND SKIP CALCULATOR IF ZERO
L03F3:      ADD     HL, BC                              ;ADD 4 TO HL TO POINT TO NEXT ADDR
            INC     DE                                  ;DISPLAY AND 2 TO DE FOR NEXT DATA
            INC     DE                                  ;DISPLAY
            DEC     A                                   ;DO UNTIL A=0
            JR      NZ, L03F3
L03F9:      PUSH    HL                                  ;SAVE ADDR POINTER (not required)
            PUSH    DE                                  ;AND DATA POINTER
            LD      DE, DISP_BUFF                       ;SHIFT ACROSS ADDR DISPLAY
            LDIR                                        ;TO 3F00 (BC-0004 FROM ABOVE)
            POP     HL                                  ;POP (DE) DATA DISPLAY ADDR INTO HL
            LD      C, 0x02                             ;SET PC TO SHIFT DATA DISPLAY BYTES
            LDIR                                        ;SHIFT THE BYTES TO DISPLAY RAM
            POP     HL                                  ;CLEAN UP STACK

;THIS SECTION CALLS THE SCAN/KEY/LCD/PATCH ROUTINE.
;WHEN A KEY IS DETECTED A KEY HANDLER ROUTINE IS CALLED. THIS KEY HANDLER IS COMMON TO
;BOTH THE MENU DRIVER AND THE PERIMETER HANDLER AND IS DOCUMENTED ON FURTHER.
;IF THE "GO" KEY WAS PRESSED, THE ZERO FLAG WILL BE SET WHEN THE COMMON KEY HANDLER RETURNS
;AND THE ROUTINE JUMPS TO THE GO HANDLER. IF NOT, THEN A (UNUSED BY JMON) ROUTINE (AT
;3F97) IS CALLED AND FINDS AN IMMEDIATE RETURN.
;THE RETURN INSTRUCTION WAS PLACED AT 3F97 WHEN THE SIO'S MENU VARIABLES WERE SHIFTED
;FROM ROM TO RAM (SEE 0793).
;A JUMP THEN LOOPS BACK TO THE MAIN DISPLAY LOOP TO UP-DATE THE DISPLAYS IN CASE OF A NEW
;MENU ENTRY NUMBER (MEN) BEING PROVIDED BY THE KEY HANDLER.
;THE GO HANDLER IS A SIMPLE TABLE ENTRY CALCULATOR THAT USES THE MENU ENTRY NUMBER TO
;INDEX THROUGH A TABLE OF THREE BYTE JUMPS. LIKE THE DISPLAY CALCULATOR, THE ZERO POSSIBILITY
;IS TESTED FOR AND THE CALCULATOR SECTION IS SKIPPED OVER IF ZERO. WHEN THE REQUIRED TABLE
;ENTRY IS POINTED TO BY HL, IT IS THEN JUMPED TO VIA JP (HL), AND THE TABLE ENTRY,,,ITSELF
;BEING A 3 BYTE JUMP THEN JUMPS TO THE SELECTED MENU ENTRY'S ROUTINE.

            CALL    SCAN_IO                             ;CALL SCAN/KEY/LCD/PATCH ROUTINE
            LD      HL, MENU_NO                         ;POINT HL TO MENU ENTRY NUMBER
            CALL    MENU_KEY                            ;CALL COMMON KEY HANDLER
            JR      Z, MENU_GO                          ;JUMP IF KEY WAS "GO" ELSE CALL TO
            CALL    MENU_KEYRN                          ;RETURN INSTRUCTION (UNUSED BY JMON)
            JR      MENU_DISP                           ;LOOP TO MAIN DISPLAY LOOP

;MENU "GO" KEYHANDLER
MENU_GO:    LD      HL, (MENU_J_TBL)                    ;POINT HL TO BASE OF JUMP TABLE
            LD      A, (MENU_NO)                        ;GET MENU ENTRY NUMBER
            OR      A                                   ;TEST FOR ZERO
            JR      Z, L0425                            ;SKIP CALCULATOR IF ZERO
L041F:      INC     HL                                  ;FIND JUMP VECTOR FOR THE CURRENT
            INC     HL                                  ;MENU HEADING
            INC     HL
            DEC     A
            JR      NZ, L041F
L0425:      JP      (HL)                                ;AND JUMP TO THE REQUIRED ROUTINE

;MAIN MENU ROUTINES
;------------------

ORG     $0426
;GENERAL SIO TRANSMISION ENTRY POINT.  THIS ROUTINE WILL EXECUTE EITHER THE TRANSMIT OR RECEIVE SIO
;ROUTINE BASED ON THE MENU NUMBER.
J_SIO_TRANS:
            LD      HL, DEF_BAUD                        ;SET BAUD 4800
            LD      (BAUD), HL                          ;SET UP THE BAUD RATE
            
;CONTINUE WITH PERIMETER SETUP FOR SIO
            LD      A, (MENU_NO)                        ;GET MENU ENTRY NUMBER
            OR      A                                   ;TEST FOR ZERO
            JR      Z, L0437                            ;SET FOR INPUT ROUTINE
            LD      HL, TRANS_RTN                       ;SET FOR TRANSMIT
            JR      L043A
L0437:
            LD      HL, RECV_RTN                        ;SET FOR RECEIVE
L043A:
            LD      (PERI_J_ADR), HL                    ;SAVE PERIMETER CALL
            JP      0044H                               ;CALL PERIMETER TO GET ADDRESS/LENGTH

;TRANSMIT DATA TO SERIAL.  USES START AND END ADDRESS SET IN PERIMETER HANDLER.
;FIRST INITIALISE THE SERIAL TRANSMIT LINE TO BE PULLED HIGH.  THEN TRANSMIT THE DATA
TRANS_RTN:
            LD      HL, 2000H                           ;POWER UP DELAY
            CALL    BITIME                              ;BIT DELAY
            LD      A, 0x40                             ;SET A TO BIT 6 
            OUT	    (DSCAN), A                          ;OUTPUT D6 TO HIGH

            CALL    SET_START_END                       ;SET HL TO START AND DE TO END
TRANS_BYTE:
            LD      A, (HL)                             ;GET BYTE
            CALL    TXCHAR                              ;TRANSMIT IT
            INC     HL                                  ;MOVE TO NEXT LOCATION
            OR      A                                   ;CLEAR CARRY FLAG
            SBC     HL, DE                              ;CHECK IF ANY MORE DATA TO MOVE
            ADD     HL, DE                              ;RESTORE HL
            JR      NZ, TRANS_BYTE                      ;MORE BYTES TO SEND
            RST     00H                                 ;RESET

;RECEIVE DATA FROM SERIAL.  USES START AND END ADDRESS SET IN PERIMETER HANDLER
RECV_RTN:
            CALL    SET_START_END                       ;SET HL TO START AND DE TO END
RECV_BYTE:
            CALL    RXCHAR                              ;GET BYTE
            LD      (HL), A                             ;LOAD BYTE INTO HL
            INC     HL                                  ;MOVE TO NEXT LOCATION
            SBC     HL, DE                              ;CHECK IF ANY MORE DATA TO MOVE
            ADD     HL, DE                              ;RESTORE HL
            JR      NZ, RECV_BYTE                       ;MORE BYTES TO RECEIVE
            RST     00H                                 ;RESET

;ROUTINE TO SET HL TO THE SIO START ADDRESS AND DE TO THE SIO_END ADDRESS.  IF START ADDRESS
;IS GREATER THAN THE END ADDRESS, THEN ADDRESSES ARE SWAPPED.  IF THEY ARE THE SAME, THE END
;ADDRESS IN INCREMENTED BY ONE.
SET_START_END:
            LD      HL, (SIO_START)                     ;GET START ADDRESS
            LD      DE, (SIO_END)                       ;GET END ADDRESS OF DATA TO TRANSMIT
            OR      A                                   ;RESET CARRY FLAG
            SBC     HL, DE                              ;SEE WHICH IS LARGER
            ADD     HL, DE                              ;RESTORE HL
            JR      Z, L0477                            ;IF THEY ARE THE SAME INC DE BY ONE
            RET     C                                   ;CARRY IS SET SO HL < DE
            EX      DE, HL                              ;MAKE HL < DE
            RET
L0477:
            INC     DE                                  ;ADD ONE TO DE TO MAKE IT LARGER THAN HL
            RET

;PERIMETER HANDLER
;THE PERIMETER HANDLER ROUTINE IS SIMILAR TO THE MENU DRIVER. THE MAJOR DIFFERENCES ARELISTED BELOW:
;THE PERIMETER HANDLER CREATES ITS OWN ADDRESS DISPLAY CODES BY CONVERTING THE CONTENTS
;OF THE ACTIVE WINDOW TO DISPLAY CODE AND THEREFORE DOES NOT REQUIRE A TABLE OF ADDRESS DISPLAY CODES.
;ANOTHER DIFFERENCE IS THE ADDRESS OF THE ROUTINE TO BE EXECUTED ON A "GO" PRESS IS SUPPLIED
;BY THE CALLING ROUTINE. THEREFORE THE PERIMETER HANDLER DOESN'T REQUIRE A JUMP TABLE AND
;ASSOCIATED CALCULATER.
;THE ONLY OTHER MAJOR DIFFERENCE IS THAT THE PERIMETER HANDLER HAS ITS OWN BUILT IN DATA
;KEY HANDLER WHILE THE MENU DOES NOT.
;THE FRONT SECTION BELOW CALCULATES THE ADDRESS OF THE ACTIVE WINDOW AND THE ADDRESS OF
;THE DATA DISPLAY FROM THE DISPLAY TABLE.
;THE MENU ENTRY NUMBER FROM THE MENU DRIVER HAS AN EQUIVALENT HERE. IT IS THE ACTIVE WINDOW
;NUMBER AND IS USEDIN IDENTICAL FASHION.

ORG     $0479
PERI_RTN:   LD      A, (PERI_W_CUR)                     ;GET NUMBER OF ACTIVE WINDOW
            LD      HL, (PERI_W_ADD)                    ;GET ADDRESS OF FIRST (FILE) WINDOW+1
            LD      DE, (PERI_D_TBL)                    ;GET BASE OF DATA DISPLAY TABLE
            OR      A                                   ;TEST ACTIVE WINDOW NUMBER FOR ZERO
            JR      Z, L048D                            ;SKIP CALCULATOR IF ZERO
L0486:      INC     DE                                  ;FINE CURRENT DATA DISPLAY
            INC     DE                                  ;AND WINDOW
            INC     HL
            INC     HL
            DEC     A
            JR      NZ, L0486

;AFTER THE ADDRESS+1 OF THE ACTIVE WINDOW IS CALCULATED, IT IS STORED IN A BUFFER (AT
;3F8C). EACH TIME A DATA KEY 1S PRESSED, HL IS LOADED FROM THIS BUFFER AND THEREFORE POINTS
;TO THE ACTIVE WINDOW. THE DATA CAN THEN BE SHIFTED INTO THE ACTIVE WINDOW IMMEDIATELY.

L048D:      LD      (PERI_W_AC1), HL                    ;STORE ACTIVE WINDOW ADDRESS+l

;BELOW THE DATA DISPLAY BYTES ARE PUT INTO THE DATA SECTION OF THE DISPLAY BUFFER VIA HL.
            EX      DE, HL                              ;PUT DATA DISPLAY ADDRESS IN HL
            LD      A, (HL)                             ;GET RIGHT-HAND DISPLAY BYTE IN A
            INC     HL                                  ;AND LEFT-HAND IN H
            LD      H, (HL)                             ;PUT RIGHT-HAND BYTE IN L
            LD      L, A                                ;HL HOLDS THE DATA DISPLAY BYTES
            LD      (DISP_DBUFF), HL                    ;STORE DATA DISPLAY IN BUFFER

;BELOW THE 16 BIT CONTENTS OF THE ACTIVE WINDOW ARE CONVERTED TO DISPLAY CODE ARE PLACED
;IN THE ADDRESS SECTION OF THE DISPLAY BUFFER.

            EX      DE, HL                              ;GET ACTIVE WINDOW ADDRESS FROM DE
            LD      A, (HL)                             ;AND TRANSFER
            DEC     HL                                  ;THE 16 BIT CONTENTS OF THE ACTIVE
            LD      L, (HL)                             ;WINDOW INTO HL
            LD      H, A                                ;READY TO COVERT TO DISPLAY CODE
            LD      BC, DISP_BUFF                       ;BC=DISPLAY BUFFER START
            CALL    HL_2_DIS                            ;CALL CONVERSION HL TO DISPLAY CODE

;THE DISPLAY BUFFER IS NOW SET-UP AND THE SCAN/KEY LOOP IS CALLED. WHEN A KEY IS PRESSED,
;A COMMON KEY HANDLER IS CALLED.
;THE COMMON KEY HANDLER DOES ALL THE REQUIRED PROCESSING FOR THE "+", "- " AND "AD" KEYS.
;IF EITHER THE "GO" OR A DATA KEY IS PRESSED, THEN THE HANDLER RETURNS WITH THE FLAGS SET
;TO SIGNIFY THESE KEYS.
;IF "GO" IS PRESSED THEN THE ZERO FLAG IS SET AND THE "GO" HANDLER BELOW IS EXECUTED. IF
;A DATA KEY IS PRESSED THEN THE ZERO FLAG IS CLEAR (NOT ZERO) AND CARRY FLAG IS CLEAR THE
;DATA KEY HANDLER IS EXECUTED IF THESE CONDITIONS ARE MET.

PERI_SFT:   CALL    SCAN_IO                             ;CALL SCAN/KEY/LCD/PATCH ROUTINE
            LD      HL, PERI_W_CUR                      ;POINT HL TO ACTIVE WINDOW NUMBER
            CALL    MENU_KEY                            ;CALL COMMON KEY HANDLER
            JR      NZ, PERI_D_KEY                      ;JUMP IF NOT GO KEY TO TEST FOR DATA
            LD      HL, (PERI_J_ADR)                    ;OR CONTROL KEY: ELSE GET JUMP ADDRESS
            JP      (HL)                                ;STORED BY SET-UP AND GO

;COMMON KEY HANDLER
;BECAUSE THE PERIMETER HANDLER AND THE MENU DRIVER ARE VERY SIMILAR, THEY ARE ABLE TO
;SHARE A COMMON KEY HANDLER.
;THE ACTION OF THE KEY HANDLER IS AS FOLLOWS:
;IF THE "AD" KEY IS PRESSED, THEN THE RETURN ADDRESS IS POPPED OFF THE STACK AND A RETURN
;IS DONE TO THE CALLING ROUTINE (USUALLY JMON). IF THE "GO" KEY IS PRESSED, THEN THE ZERO
;FLAG WILL BE SET AND A RETURN DONE. IT IS THEN UP TO THE CALLING ROUTINE TO SERVICE THE
;"GO" KEY.
;A DATA KEY WILL BE FLAGGED BY SETTING THE CARRY FLAG AND CLEARING THE ZERO FLAG. LIKE
;THE "GO" KEY, THE CALLING ROUTINE MUST DECIDE WHAT IT IS TO DO WITH THE DATA KEY (THERE
;IS A BUILT IN DATA KEY HANDLER FOR THE PERIMETER HANDLER).
;IF EITHER THE "+" OR "-" KEYS ARE PRESSED THEN A SPECIAL ROUTINE IS CALLED. THIS ROUTINE
;WILL ALTER THE CURRENT NUMBER OF THE ACTIVE WINDOW OR MENU ENTRY. THE RESULT IS THAT WHEN
;THE DISPLAY IS UP-DATED, THE DISPLAYS WILL BE SHIFTED TO EITHER THE NEXT DISPLAY FOR "+"
;OR TO THE PREVIOUS ONE FOR "- " AND WRAP-AROUND IF REQUIRED.

MENU_KEY:   CP      K_PLUS                              ;IS THE KEY
            JR      Z, MENU_K_HDL                       ;JUMP IF SO TO "+" HANDLER
            CP      K_MINUS                             ;IS IT "-"
            JR      Z, MENU_K_HDL                       ;JUMP IF SO TO "-" HANDLER
            CP      K_ADDR                              ;IS IT "AD"
            JR      NZ, L04C0                           ;JUMP IF NOT TO TEST FOR "GO"
            POP     HL                                  ;CLEAN UP STACK
            RET                                         ;RETURN TO JMON (OR CALLING ROUTINE)
L04C0:      CP      K_GO                                ;IS IT "GO"
            CCF                                         ;CLEAR CARRY IF NOT IF GO C=1 Z=1
            RET                                         ;IF DATA SET Z=0 C=0: RETURN

;BELOW IS THE PERIMETER HANDLER DATA KEY HANDLER/DISCRIMINATOR
;IF THE KEY WAS "+" OR "-" THEN IT HAS ALREADY BEEN HANDLED AND THIS CONDITION IS FLAGGED
;BY THE CARRY BEING SET. IN THIS CASE, A JUMP IS DONE BACK TO THE MAIN BODY TO UP-DATE
;THE DISPLAY OTHERWISE THE DATA KEY VALUE IS SHIFTED INTO THE ACTIVE WINDOW.

PERI_D_KEY: JR      C, PERI_RTN                         ;JUMP IF KEY WAS "+" OR "-”
            LD      HL, (PERI_W_AC1)                    ;POINT HL TO ACTIVE WINDOW+1
            DEC     HL                                  ;POINT TO LOW ORDER BYTE
            RLD                                         ;SHIFT IN DATA KEY VALUE
            INC     HL                                  ;AND SHIFT OTHER NIBBLES
            RLD                                         ;ACROSS
            JR      PERI_RTN                            ;JUMP BACK TO UP-DATE DISPLAY

;THIS ROUTINE IS CALLED FROM THE COMMON KEY HANDLER IF EITHER "+" OR "-" HAVE BEEN PUSHED.
;THIS ROUTINE WILL EITHER INCREMENT OR DECREMENT THE MEMORY LOCATION ADDRESSED BY HL FOR
;THE "+" AND "-" KEY RESPECTIVELY. HL WAS LOADED BY THE CALLING ROUTINE TO POINT TO ITS
;MAIN CONTROLLING BYTE. THIS IS EITHER THE CURRENT MENU ENTRY NUMBER (MENU DRIVER), OR
;THE ACTIVE WINDOW NUMBER (PERIMETER HANDLER) , BOTH OF WHICH HAVE BEEN DESCRIBED PREVIOUSLY.
;AFTER INCREMENTING OR DECREMENTING (HL), THIS ROUTINE THEN CHECKS THAT THE VALUE IN (HL)
;IS NOT GREATER THAT THE BYTE AT HL+1 (WHICH IS THE MAXIMUM NUMBER OF DISPLAYS LESS 1).
;KEEP IN MIND, IF IT UNDERFLOWED FROM ZERO IT WILL BECOME FF AND BE HIGHER THAN (HL). THIS
;SECOND BYTE (AT HL+1) IS THE NUMBER OF ALLOWABLE DISPLAYS-1 AND WAS PROVIDED BY THE ROM
;TABLE FOR THE (SIO) MENU DRIVER, AND PROVIDED BY THE PERIMETER HANDLER SET-UP ROUTINES
;(REFER TO 042A AND 0442).
;IF THE FIRST BYTE BECOMES HIGHER THAN THE SECOND., THEN THE ROUTINE CHECKS TO SEE WHICH
;KEY WAS PRESSED. IF THE "+" KEY WAS, THEN (HL) IS CLEARED. THIS WILL CAUSE MENU OR
;PERIMETER HANDLER TO SHOW ITS FIRST DISPLAY WHEN RE-ENTERED.
;IF THE KEY WAS "-", THEN THE MAXIMUM NUMBER OF DISPLAYS-1 (WHICH IS THE SAME AS THE NUMBER
;OF THE FINAL DISPLAY) IS TRANSFERRED INTO (HL) (THE NUMBER OF THE CURRENT DISPLAY). THIS
;WILL CAUSE THE LAST DISPLAY TO BE SHOWN WHEN THE MENU DRIVER OR PERIMETER HANDLER IS
;RE-ENTERED.
;IF THERE IS NO UNDERFLOW OR OVERFLOW THEN THE ROUTINE RETURNS JUST AFTER IT HAS EITHER
;INCREMENTED OR DECREMENTED THE CURRENT NUMBER OF THE MENU ENTRY NUMBER OR ACTIVE WINDOW
;NUMBER.
;WHEN THE MENU DRIVER OR PERIMETER HANDLER ARE RE-ENTERED, THEY WILL SHOW THE NEXT DISPLAY
;FOR "+" OR THE PREVIOUS FOR "-" AND WRAP-AROUND AUTOMATICALLY IF REQUIRED.

ORG     $04D1
MENU_K_HDL: LD      C, A                                ;SAVE INPUT KEY VALUE IN C
            INC     HL                                  ;PUT MAX NUMBER OF DISPLAYS-1
            LD      B, (HL)                             ;IN B
            DEC     HL                                  ;RESET HL TO POINT TO CURRENT NUMBER
            RRCA                                        ;WAS KEY "+" OR "-"? BIT 0 WILL TELL
            LD      A, (HL)                             ;PUT CURRENT NUMBER IN A
            JR      C, L04DB                            ;JUMP IF KEY WAS "-"
            INC     A                                   ;INCREASE A BY 2
            INC     A                                   ;
L04DB:      DEC     A                                   ;DECREASE A BY ONE
            INC     B                                   ;ADD 1 TO MAX NUMBER-1: IS CURRENT
            CP      B                                   ;NUMBER EQUAL OR GREATER THAN MAX?
            JR      NC, L04E5                           ;JUMP IF SO TO UNDER/OVERFLOW HANDLER
L04E0:      LD      (HL), A                             ;ELSE STORE UPDATED CURRENT NUMBER
            XOR     A                                   ;SET ZERO FLAG
            DEC     A                                   ;CHANGE ZERO FLAG TO 0
            SCF                                         ;AND SET CARRY
            RET                                         ;DONE
L04E5:      BIT     0, C                                ;TEST FOR "+" OR "-"
            JR      NZ, L04EC                           ;JUMP IF "-" TO SET CURRENT NUMBER
            XOR     A                                   ;TO LAST DISPLAY: ELSE SET FIRST
            JR      L04E0                               ;DISPLAY: JUMP TO STORE NEW NUMBER
L04EC:      DEC     B                                   ;CORRECT MAX NUMBER-1
            LD      A, B                                ;SET A TO LAST DISPLAY NUMBER
            JR      L04E0                               ;JUMP TO STORE LAST DISPLAY NUMBER

ORG     $04F0

;BIT BANG SERIAL TRANSMIT ROUTINE.  THIS ROUTINE WILL SEND ONE BYTE VIA THE SERIAL PORT
;(DSCAN BIT 6).  IT FIRST TRANSMITS A START BIT BUT PULLING D6 LOW, THEN EACH BIT OF THE
;BYTE TO TRANSMIT.  WHEN ALL EIGHT BITS ARE SENT, A STOP BIT IS SENT BY PULLING D6 HIGH
;REGISTER 'A' IS THE BYTE TO BE SENT
TXCHAR:
            PUSH	AF                                  ;SAVE AF, BC AND HL
            PUSH	BC
            PUSH	HL
            LD	    HL,(BAUD)                           ;HL HOLDS THE BIT TIME DELAY
            LD	    C,A                                 ;SAVE BYTE TO TRANSMIT IN C

            XOR	    A                                   ;TRANSMIT THE START BIT
            OUT	    (DSCAN), A                          ;BY PULLING D6 LOW
            CALL	BITIME                              ;CALL BAUD DELAY

            LD	    B, 0x08                             ;TRANSMIT 8 BITS
            RRC	    C                                   ;MOVE FIRST BIT INTO CARRY AND D7
NXTBIT:	
            RRC	    C	                                ;SHIFT BIT TO D6
            LD	    A,C	                                ;COPY C TO A FOR SENDING
            AND	    0x40                                ;MASK OUT ALL BUT D6
            OUT	    (DSCAN), A                          ;OUTPUT THE BIT
            CALL	BITIME                              ;CALL BAUD DELAY
            DJNZ	NXTBIT                              ;DO EIGHT TIMES

            LD	    A, 0x40                             ;SEND THE STOP BITS
            OUT	    (DSCAN), A                          ;OUTPUT D6 TO HIGH
            CALL	BITIME                              ;CALL BAUD DELAY
            CALL	BITIME                              ;CALL BAUD DELAY X 2
            POP   	HL                                  ;RESTORE AF, BC AND HL
            POP  	BC
            POP 	AF
            RET

;BIT BANG SERIAL RECEIVED ROUTINE.  THIS ROUTINE WILL RECEIVE ONE BYTE VIA THE SERIAL PORT
;(KEYBOARD BIT 7).  IT WAITS FOR A START BIT (BIT 7) TO GO LOW.  THEN IT WILL GET THE 8 BITS AND
;CONSTRUCT ONE BYTE FROM THE BITS.  WHEN ALL BITS ARE RECIEVED, REGISTER A IS RETURNED WITH THE 
;BYTE.
RXCHAR:
            PUSH	BC                                  ;SAVE BC AND HL
            PUSH	HL
STARTBIT:
            IN	    A, (KEYBOARD)                       ;WAIT FOR THE START BIT 
            BIT	    7, A                                ;HIGH TO LOW TRANSISION
            JR	    NZ, STARTBIT                        ;NO START BIT YET

;START BIT DETECTED
            LD	    HL, (BAUD)                          ;DELAY FOR HALF A
            SRL	    H                                   ;BIT TIME TO SAMPLE THE MIDDLE
            RR	    L 	                                ;OF THE BIT CELL
            CALL	BITIME                              ;CALL BAUD DELAY
            IN	    A, (KEYBOARD)                       ;GET THE START BIT
            BIT	    7, A                                ;CHECK THE START BIT IS STILL LOW
            JR	    NZ, STARTBIT                        ;START BIT TOO SHORT, TRY AGAIN

;VALID START BIT DETECTED
            LD	    B, 0x08                             ;RECEIVE EIGHT BITS
GETBITS:	
            LD	    HL, (BAUD)                          ;SET BAUD DELAY
            CALL	BITIME                              ;CALL BAUD DELAY
            IN	    A, (KEYBOARD)                       ;GET BIT
            RL    	A                                   ;PUT BIT 7 IN CARRY FLAG
            RR	    C                                   ;SHIFT BIT INTO OUTPUT REGISTER
            DJNZ	GETBITS                             ;GET MORE BITS
            LD	    A, C                                ;LOAD OUTPUT REGISTER TO A
            OR	    A                                   ;CLEAR CARRY FLAG
            POP	    HL                                  ;RESTORE HL AND BC
            POP	    BC
            RET

;BIT TIME DELAY IS THE MANAGE THE DELAY TIME FOR ONE BIT SENT/RECEIVED BASED ON
;BAUD RATE.  HL = IS THE DELAY TIME
BITIME:
            PUSH    HL                                  ;SAVE HL AND DE
            PUSH    DE
            LD      DE, 0001H                           ;SET DE TO 1 TO SUBTRACT FROM HL
BITIME1:  
            SBC     HL, DE                              ;SUBTRACT 1 FROM DELAY TIME
            JP      NC, BITIME1                         ;KEEP GOING UNTL DELAY TIME IS ZERO
            POP     DE                                  ;RESTORE HL AND DE
            POP     HL
            RET

;ASCII TO SEVEN SEGMENT LOOKUP TABLE,  PLACED HERE SO TO BE SITTING IN THE SAME PAGE
;OF MEMORY, 0555H TO 055B4H
ASCII_SEG_TBL:
            DB      0x00, 0x18, 0x0A, 0xEE, 0xA7, 0x5C, 0x2C, 0x02 ;  ! " # $ % & '
            DB      0x83, 0x89, 0xA3, 0x46, 0x40, 0x04, 0x10, 0x4C ;( ) * + , - . /
            DB      0xEB, 0x28, 0xCD, 0xAD, 0x2E, 0xA7, 0xE7, 0x29 ;0 1 2 3 4 5 6 7
            DB      0xEF, 0xAF, 0x81, 0xA1, 0x07, 0x84, 0x0D, 0x5D ;8 9 : ; < = > ?
            DB      0xED, 0x6F, 0xE6, 0xC3, 0xEC, 0xC7, 0x47, 0xE3 ;@ A B C D E F G
            DB      0x6E, 0x42, 0xE8, 0x67, 0xC2, 0x61, 0x6B, 0xEB ;H I J K L M N O
            DB      0x4F, 0x8F, 0x4B, 0xA7, 0xC6, 0xEA, 0xEA, 0x8A ;P Q R S T U V W
            DB      0x6E, 0xAE, 0xCD, 0xC3, 0x26, 0xA9, 0x0B, 0x80 ;X Y Z [ \ ] ^ _
            DB      0x08, 0xED, 0xE6, 0xC4, 0xEC, 0xCF, 0x47, 0xAF ;` a b c d e f g
            DB      0x66, 0x40, 0xA0, 0x67, 0x42, 0x60, 0x64, 0xE4 ;h i j k l m n o
            DB      0x4F, 0x2F, 0x44, 0xA7, 0xC6, 0xE0, 0xE0, 0x60 ;p q r s t u v w
            DB      0x6E, 0xAE, 0xCD, 0x2C, 0x42, 0x46, 0x01       ;x y z { | } ~  

;THIS ROUTINE DISPLAYS ASCII CHARACTERS ON THE SEVEN SEGMENTS AND SCROLLS THE MESSAGE 
;FROM RIGHT TO LEFT.  TO CREATE A MESSAGE, ENTER IN ASCII IN HEXADECIMAL AND ONCE
;COMPLETE, TERMINATE WITH A CARRIAGE RETURN (0x0D), THEN CALL THIS ROUTINE AND 
;ENTER THE START ADDRESS OF THE ASCII DATA.  HIT 'GO' AND THE ASCII
;WILL BE DISPLAYED AND SCROLLED.  THE MESSAGE WILL REPEAT ONCE A CARRIAGE RETURN IS
;SEEN.  THIS IS 0x0D.
J_MSG_SCRL:
            LD      HL, ASCII_SCRL                      ;SET THE PERIMITER GO CALL
            LD      (PERI_J_ADR), HL                    ;SAVE PERIMETER CALL
            JP      0044H                               ;CALL PERIMETER TO GET START/END

ASCII_SCRL:
            LD      HL, DISP_BUFF                       ;PUT DISPLAY BUFFER AT 3F00
            LD      (V_DISPLAY), HL
            XOR     A                                   ;RESET A TO BLANK
            LD      B, 06H                              ;ALL SIX DISPLAYS
SL1:
            LD      (HL), A                             ;CLEAR DISPLAY
            INC     HL                                  ;MOVE TO NEXT DISPLAY
            DJNZ    SL1                                 ;REPEAT SIX FIVE TIMES

            LD      HL, (SIO_START)                     ;GET START ADDRESS
ASCII_SHIFT:
            LD      B,05H                               ;SHIFT DOWN DISPLAY
            LD      IX, DISP_BUFF                       ;POINT IX TO DISPLAY BUFFER START
SL2:
            LD      A,(IX+1)                            ;GET THE NEXT VALUE TO THE RIGHT 
            LD      (IX+0),A                            ;PLACE IT IN THE POSITION TO THE LEFT
            INC     IX                                  ;MOVE TO NEXT SEGMENT
            DJNZ    SL2                                 ;REPEAT SO THAT ALL FIVE SEGMENTS HAVE MOVE 
            LD      A,(HL)                              ;GET THE NEXT ASCII VALUE
            CP      0x0D                                ;IS IT A CARRIAGE RETURN?
            JR      Z, ASCII_SCRL                       ;YES, GO BACK TO START AND REPEAT MESSAGE
            SUB     0x20                                ;ADJUST FOR ASCII TABLE LOOKUP
            LD      DE, ASCII_SEG_TBL                   ;POINT DE TO BASE OF TABLE
            ADD     A, E                                ;INDEX E REGISTER WITH ASCII VALUE
            LD      E, A                                ;UPDATE E WITH INDEXED VALUE
            LD      A, (DE)                             ;RETRIEVE ASCII VALUE FOR SEVEN SEGMENT
            LD      (DISP_BUFF + 5), A                  ;PLACE IN RIGHT MOST SPOT IN THE DISPLAY
            PUSH    HL                                  ;SAVE HL TO RETAIN ASCII INDEX POSITION
            LD      C, 0xFF                             ;DELAY TO SLOW DOWN SCROLL
SL3:
            RST     18H                                 ;CALL SEGMENT SCAN/KEY ROUTINE
            JR      Z,SL4                               ;KEY PRESS, SO EXIT
            DEC     C                                   ;DECREASE C
            JR      NZ,SL3                              ;REPEAT SCAN
            INC     C                                   ;MAKE NON ZERO
SL4:
            POP     HL                                  ;RESTORE ASCII INDEX POSITION
            RET     Z                                   ;IF KEY HIT THEN EXIT
            INC     HL                                  ;MOVE TO NEXT ASCII CHARACTER
            JR      ASCII_SHIFT                         ;LOOP TO SCROLL MESSAGE

;THIS ROUTINE USES THE SERIAL IO TO RECIEVE AN INTEL HEX FILE.  CONNECT THE SERIAL TERMINAL
;AS 4800-8-N-2. INTEL HEX FILE FORMAT IS A STRING OF ASCII WITH THE FOLLOWING PARTS
; MARK | LENGTH | ADDRESS | RECORD TYPE | DATA | CHECKSUM
; :10200000210621CD7D20CD98203A00213C320021AF <- EXAMPLE LINE
;THE MARK IS A COLON CHARACTER ':', LENGTH IS THE NUMBER OF DATA BYTES PER LINE, ADDRESS
;IS THE 2 BYTE ADDRESS OF WHERE THE DATA IS TO BE STORED.  RECORD TYPE IS 00 FOR DATA AND
;01 FOR END OF FILE. DATA IS THE DATA OF UPTO 16 BYTES AND THE CHECKSUM IS THE ADDITION OF 
;ALL BYTES.
J_INTEL_IN:
            LD      HL, DEF_BAUD                        ;SET BAUD 4800
            LD      (BAUD), HL                          ;SET UP THE BAUD RATE

            CALL    INTEL_LOADER                        ;CALL THE LOADER ROUTINE
            JP      NZ, INTEL_ERR                       ;IF RETURNS NON ZERO, ERROR
            LD      DE, LOAD_DA_P                       ;LOAD PASS
            LD      HL, LOAD_AD_P                       ;MESSAGE
            JR      INTEL_RET                           ;DISPLAY MESSAGE
INTEL_ERR:
            LD      DE, LOAD_DA_F                       ;LOAD FAIL
            LD      HL, LOAD_AD_F                       ;MESSAGE
INTEL_RET:
            XOR     A                                   ;RESET A AND ZERO FLAG
            JP      MENU_SFT                            ;DIPSLAY MENU WITH EITHER PASS/FAIL MESSAGE

;THIS IS THE MAIN LOADING ROUTINE.  IT WILL LOAD ONE LINE OF INTEL HEX.  WHILE THE LOAD IS 
;HAPPENING, THE ADDRESS WHERE THE DATA IS BEING SAVED WILL DISPLAY ON THE SCREEN. 
INTEL_LOADER:
        	XOR	    A                                   ;ZERO A
	        LD      C, A	                            ;CLEAR CHECKSUM
INTEL_MARK:
	        CALL	RXCHAR	                            ;WAIT FOR THE MARK
	        CP	    ':'	                                ;TO BE TRANSMITTED
	        JR      NZ, INTEL_MARK	                    ;LOOP UNTIL START OF LINE FOUND
        	CALL	ASCII_2_BYTE                        ;GET LINE LENGTH IN BYTES
	        LD	    B, A                                ;STORE NUMBER OF DATA BYTES IN B
        	CALL	ASCII_2_BYTE                        ;GET ADDRESS HIGH BYTE
            LD      H, A                                ;STORE HIGH ADDRESS IN H
        	CALL	ASCII_2_BYTE                        ;GET ADDRESS LOW BYTE
            LD      L, A                                ;STORE LOW ADDRESS IN L

            PUSH    BC                                  ;SAVE BC
            LD      BC, (V_DISPLAY)                     ;PUT DISPLAY BUFFER ADDRESS IN BC
            CALL    HL_2_DIS                            ;CALL HL TO DISPLAY CODE ROUTINE
            POP     BC                                  ;RESTORE BC

        	CALL	ASCII_2_BYTE                        ;GET RECORD TYPE
            JR      NZ, CHECKSUM                        ;IF 01 THEN END OF FILE
INTEL_DATA:
            PUSH    BC
            RST     18H                                 ;SCAN THE DISPLAY TO SHOW CURRENT LOADING ADDRESS
            POP     BC  
        	CALL	ASCII_2_BYTE                        ;GET DATA
            LD      (HL), A                             ;STORE DATA BYTE IN HL
        	INC     HL                                  ;MOVE TO NEXT ADDRESS
            DJNZ    INTEL_DATA                          ;LOAD MORE BYTES

        	CALL    CHECKSUM                            ;COMPARE CHECK SUM
	        JR      Z, INTEL_LOADER	                    ;CHECKSUM OK,NEXT RECORD            
            RET                                         ;EXIT FOR ERROR

CHECKSUM:                                               ;THE SUM OF ALL BYTES INCLUDING CHECKSUM SHOULD EQUAL ZERO
            CALL    ASCII_2_BYTE                        ;GET CHECKSUM BYTE
            LD      A, C         	                    ;CONVERT CHECKSUM TO
            OR      A                                   ;CHECK IF A=0, CHECKSUM IS OKAY
            RET                                         ;RETURN ZERO FLAG

;GET HEX ASCII CHARACTER FROM SERIAL PORT AND CONVERT IT TO A BYTE.  THIS ALSO
;UPDATES THE HEX_CHECKSUM FOR USE LATER ON
ASCII_2_BYTE:
            CALL    A_2_BYTE                            ;GET 2 ASCII CHARS AND CONVERT TYPE BYTE
            OR      D                                   ;ADD IT TO A TO COMPLETE THE BYTE
            PUSH    AF                                  ;SAVE BYTE
            ADD     A, C                                ;ADD CHECKSUM TO BYTE
            LD	    C, A	                            ;STORE BACK IN CHECKSUM
            POP     AF                                  ;RESTORE BYTE
            RET
;THIS ROUTINE GETS THE NEXT TWO ASCII CHARACTERS AND CONVERTS THEM INTO ONE BYTE,  D HOLDS
;THE FIRST CHARACTER IN THE UPPER NIBBLE, A HOLDS THE LOW NIBBLE.  GET NIBBLE IS CALLED TWICE WITH
;A FALL TRHOUGH
A_2_BYTE:
            CALL    GET_NIBBLE                          ;GET THE CHARACTER FROM THE SIO
            RLCA                                        ;MOVE TO UPPER NIBBLE
            RLCA
            RLCA
            RLCA
	        LD      D, A                                ;STORE IN HIGH NIBBLE OF D
GET_NIBBLE:
	        CALL    RXCHAR                              ;GET ONE CHARACTER
	        BIT     6, A                                ;IS THE CHARACTER BETWEEN 30-39 (0-9) OR 41-46 (A-F)
	        JR      Z, NOTA2F                           ;0-9 JUST MASK OUT UPPER BITS
	        ADD     A, 0x09                             ;ADD 0x09 TO FIX FOR A-F
NOTA2F:
	        AND	    0x0F                                ;MASK OUT HIGH NuBBLE AND CONVERT TO BINARY
            RET

;THIS ROUTINE SWITCHES BETWEEN THE STANDARD TEC KEYBOARD LAYOUT AND MARK JELIC'S ALTERNATE ONE.  IT
;CAN BE MODIFED TO SUIT YOUR OWN LAYOUT.  IT WORKS BY USING SETTING THE KEYBOARD PATCH IN THE KEYBOARD
;ROUTINE TO THE J_KEY_MOD ROUTINE.  THIS WILL MODIFY THE CURRENT KEY PRESSED BEFORE THE KEYBOARD HANDLER
;RETURNS. 
J_ALT_KEY:
            LD      HL, V_ALT_KEYB                      ;GET THE ALTERNATIVE KEYBOARD FLAG
            RRC     (HL)                                ;ROTATE A CARRY CHECK
            LD      HL, PATCH_KEY                       ;LOAD HL WITH THE PATCH KEYBOARD ENTRY
            JR      C,SET_ALTK                          ;IF NOT NORNAL, SET ALTERATE
            LD      (HL), 0xC9                          ;JUST SET KEYBOARD PATCH TO EXIT
EXIT_KEY:
            RET                                         ;EXIT 
SET_ALTK:
            LD      (HL), 0xC3                          ;SET THE KEYBOARD PATCH TO CALL
            LD      BC, J_KEY_MOD                       ;THE J_KEY_MOD ROUTINE
            LD      (PATCH_KEY+1), BC 
            JR      EXIT_KEY                            ;DO A SOFT RESET

;HERE IS THE KEYBOARD MOD ROUTINE.  IT TAKES IN THE KEY KEY PRESSED STORED IN THE 'A'
;REGISTER AND USES THIS KEY TO INDEX A TABLE TO MODIFY IT TO AN ALTERNATE KEY.  HERE ARE
;THE TWO KEYBOARD LAYOUT FOR REFERENCE.  ARGUABLY THE ALTERNATE LAYOUT MAKES MORE SENSE.
;FEEL FREE TO CHANGE THIS TO SUIT YOUR OWN SETUP!
;
;    STANDARD LAYOUT           ALTERNATE LAYOUT
; |----|---|---|---|---|    |----|---|---|---|---|
; | AD | 3 | 7 | B | F |    | AD | 7 | 8 | 9 | A | 
; |----|---|---|---|---|    |----|---|---|---|---|
; | GO | 2 | 6 | A | E |    | GO | 4 | 5 | 6 | B | 
; |----|---|---|---|---|    |----|---|---|---|---|
; | -  | 1 | 5 | 9 | D |    | -  | 1 | 2 | 3 | C | 
; |----|---|---|---|---|    |----|---|---|---|---|
; | +  | 0 | 4 | 8 | C |    | +  | 0 | F | E | D | 
; |----|---|---|---|---|    |----|---|---|---|---|
J_KEY_MOD:
            PUSH    HL                                  ;SAVE HL
            LD      HL, ALT_KEY_TBL                     ;POINT HL TO ALTERNATE KEYBOARD TABLE
            ADD     A, L                                ;INDEX L WITH A
            LD      L, A                                ;SAVE L
            LD      A, (HL)                             ;RETRIEVE NEW KEY
            POP     HL                                  ;RESTORE HL
            RET                                         ;EXIT

ALT_KEY_TBL:
            DB      0x00, 0x01, 0x04, 0x07, 0x0F, 0x02, 0x05, 0x08 ; 0 1 4 7 F 2 5 8
            DB      0x0E, 0x03, 0x06, 0x09, 0x0D, 0x0C, 0x0B, 0x0A ; E 3 6 9 D C B A
            DB      0x10, 0x11, 0x12, 0x13                         ; + - GO AD

            DB      0xFF, 0xFF                          ;SPARE
            DB      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF  ;FILL 
            

;THIS ROUTINE IS THE KEYBOARD READER/VALIDATER
;THE ACTION IS AS FOLLOWS:
;A SHORT LOOP LOOKS FOR A KEY PRESS. IF NO KEY IS PRESSED, THEN THE KEY PRESS BUFFER (3F25)
;IS CLEARED THE ZERO AND THE CARRY FLAG CLEARED AND THE ROUTINE RETURNS.
;IF A KEY IS FOUND, THEN THE REMAINING LOOP COUNTS ARE WORKED OFF IN A DUMMY LOOP TO ENSURE
;EQUAL TIME IN EXECUTING THE ROUTINE.
;IF IT IS THE FIRST TIME.THAT THE KEY HAS BEEN DETECTED, THEN THE KEY PRESS FLAG WILL BE
;CLEAR. (IT WAS CLEARED BY THE MONITOR VARIABLES ON RESET). THE ROUTINE TESTS FOR THIS
;CONDITION AND IF TRUE THEN THE KEY IS ACCEPTED AS "VALID" AND FLAGGED BY A SET CARRY AND
;SET ZERO FLAG AND THE KEY PRESS FLAG IS SET TO INDICATE THE A KEY HAS BEEN DETECTED. THE
;INPUT IS THEN PLACED IN BOTH THE "I" REGISTER AND THE ACCUMULATOR. IF A KEY IS DETECTED
;BUT FOUND NOT TO BE VALID, I.E. IT HAS ALREADY BEEN DETECTED AND PROCESSED, THEN THE
;CARRY WILL BE SET BUT THE ZERO CLEARED. THIS ALLOWS THE AUTO KEY REPEAT SECTION TO KNOW
;THAT A KEY IS STILL BEING HELD DOWN. THE AUTO KEY REPEAT SECTION MAKE UP ITS OWN MIND
;WHETHER IT IS VALID OR NOT.

ORG     $06AD
KEY_READ:   IN      A, (P_DAT)                          ;TEST FOR KEY PRESSED
            BIT     6, A
            JR      Z, L06BB                            ;DA IS LOW = KEYPRESS
            DJNZ    KEY_READ                            ;LOOP LOOKING FOR KEY UNTIL B=0
            XOR     A                                   ;CLEAR KEY PRESS FLAG
            LD      (V_KEY_PRES), A
            DEC     A                                   ;SET A TO FF AND CLEAR ZERO FLAG
L06BA:      RET                                         ;DONE
L06BB:      LD      A, (V_KEY_PRES)                     ;GET KEY PRESS FLAG
            OR      A                                   ;TEST FOR ZERO
            JR      NZ, L06C1                           ;DUMMY JUMP TO EQUALIZE TIME
L06C1:      DJNZ    L06BB                               ;FINISH LOOP
            SCF                                         ;SET CARRY
            JR      NZ, L06BA                           ;DUMMY JUMP TO RETURN
            DEC     A                                   ;SET KEY PRESS FLAG TO FF
            LD      (V_KEY_PRES), A
KEY_GET:    IN      A, (KEYBOARD)                       ;GET INPUT KEY FROM ENCODER CHIP
            AND     0x1F                                ;MASK OFF UNUSED BITS
            CALL    PATCH_KEY                           ;USER ROUTINE TO MODIFY KEY FOR CUSTOM KEYBOARD
            BIT     7, A                                ;SET ZERO FLAG (THINK ABOUT IT!)
            SCF                                         ;SET CARRY
            LD      (V_KEY), A                          ;STORE INPUT KEY
            RET                                         ;DONE

;THIS ROUTINE IS CALLED ONCE ON EVERY HARD RESET. IT INITIALIZES THE LCD THEN TESTS THAT
;IT IS THERE (IT CANNOT DO IT THE OTHER WAY AROUND AS THE LCD NEEDS TO BE INITIALIZED
;BEFORE IT WILL RESPOND INTELLIGENTLY). IF THE LCD IS FITTED THEN THE ROUTINE WILL READ
;IN AN ASCII SPACE CHARACTER (20H) OR IF THE LCD IS NOT, JUNK FROM THE DATA BUSS.
;20H IS SUBTRACTED FROM WHATEVER IS READ IN AND THE RESULT IS STORED IN THE LCD ENABLE
;BUFFER. IF THE RESULT IS ZERO THEN THE LCD IS ENABLED. IT IS VITAL TO KNOW IF THE LCD IS
;FITTED, OTHERWISE THE ROUTINE WHICH READS THE BUSY FLAG MAY LOOP FOREVER.

LCD_RESET:  LD      HL, LCDRST_TBL                      ;POINT HL TO LCD INITIALIZE TABLE
            LD      BC, 0x0404                          ;B=4 BYTES, C=PORT 4
L06DE:      LD      DE, 0500H                           ;DELAY BETWEEN
L06E1:      DEC     DE                                  ;EACH BYTE
            LD      A, D                                ;AS PER
            OR      E                                   ;LCD MANUFACTER'S
            JR      NZ, L06E1                           ;INSTRUCTIONS
            OUTI                                        ;OUTPUT (HL) TO (C). HL=HL+1,B=B-1
            JR      NZ, L06DE                           ;JUMP IF B NOT 0
L06EA:      DJNZ    L06EA                               ;SHORT DELAY
            IN      A, (P_LCDDATA)                      ;INPUT FROM LCD TO SEE IF IT'S THERE
            SUB     0x20                                ;SUBTRACT ASCII SPACE, IF LCD FITTED
            LD      (V_LCD), A                          ;RESULT WILL BE ZERO: STORE THIS IN
            RET                                         ;LCD MASK: DONE
            
            DB      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF  ;FILL 
            DB      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF  ;FILL 

;AT 0700 IS THE MAIN MENU JUMP TABLE.
ORG     0x0700
MAIN_JP_TBL:
            JP      J_SIO_TRANS                        ;SIO TRANSFER IN
            JP      J_SIO_TRANS                        ;SIO TRANSFER OUT
            JP      J_INTEL_IN                         ;SIO INTEL HEX FILE INPUT
            JP      J_ALT_KEY                          ;SWITCH BETWEEN ALTERNATE KEYBOARD LAYOUT
            JP      J_MSG_SCRL                         ;MESSAGE SCROLL ROUTINE
            JP      J_MINT                             ;MINT PROGRAMMING LANGUAGE
            JP      J_BASIC                            ;TINY BASIC PROGRAMMING LANGUAGE
            JP      J_GAMES                            ;GAMES FOR THE TEC-1F

;BELOW ARE THE JMON DEFAULT RESET VARIABLES (A ZERO IS THE ACTIVE RAM
;STATE UNLESS OTHERWISE STATED). LOCATION
;* DENOTES CONTROL BYTES DESIGNED TO BE USER ALTERED (IN RAM).

ORG     $0718
DEF_VARS:   DB      0x00                                ;KEY BUFFER 3F20
L0719:      DB      0x00                                ;LCD ON/OFF FLAG 3F21*
L071A:      DB      0x00                                ;SOUND ON/OFF 3F22*
L071B:      DB      0xFF                                ;GO AT ALTERNATE GO ADDRESS IF AA 3F23*
L071C:      DB      0xFF                                ;STEPPER KEY CONTROL/TIMER 3F24
L071D:      DB      0x00                                ;KEY PRESSED FLAG 3F25
L071E:      DB      0x55                                ;ALTERNATIVE KEYBOARD LAYOUT FLAG 3F26
L071F:      DB      0x00                                ;AUTO INCREMENT ON/OFF 3F27*
L0720:      DB      0x00, 0x20                          ;ALT GO ADDR/SOFT RESET EDIT LOCATION ($2000) 3F28*
L0722:      DB      0x70                                ;AUTO KEY REPEAT TIMER 3F2A
L0723:      DB      0x00                                ;MONITOR CONTROL BYTE 3F2B
L0724:      DB      0x00, 0x3F                          ;DISPLAY BUFFER ADDRESS 3F2C*
L0726:      DB      0x00, 0x20                          ;INITIAL EDITING LOCATION 3F2E

;BELOW ARE THE JMON INDIRECT JUMP ADDRESSES. THIS TABLE IS SHIFTED DOWN TO 3F30 ON A HARD RESET.
L0728:      JP      J_HL2CODE                           ;CONVERT HL TO DISPLAY CODE 3F30
L072B:      JP      J_A2CODE                            ;CONVERT A TO DISPLAY CODE 3F33
L072E:      JP      J_LEDSCAN                           ;LED SCAN ROUTINE 3F36
L0731:      JP      J_SETDOTS                           ;SET LED DOTS 3F39
L0734:      JP      J_TONEX2                            ;RESET TONES 3F3C
L0737:      JP      J_TONE                              ;TONE 3F3F
L073A:      JP      J_SCANKEY                           ;SCAN/KEY/LCD/PATCH LOOP 3F42
L073D:      JP      J_DISPUPD                           ;SOFT JMON ENTRY L3F45
L0740:      JP      J_LCD                               ;LCD ROUTINE 3F48

;BELOW ARE THE DISPLAY TABLES FOR THE MAIN MENU ADDRESS DISPLAYS
MAIN_AD_TBL:
            DB      0xA7, 0x28, 0xEB, 0x04              ;"SIO-"
            DB      0xA7, 0x28, 0xEB, 0x04              ;"SIO-"
            DB      0x28, 0x6B, 0xC6, 0xC7              ;"INtE"
            DB      0x6F, 0xC2, 0xC6, 0x67              ;"ALTK"
            DB      0xEF, 0x6F, 0x6B, 0x6B              ;"BANN"
;EXTENDED MENU
            DB      0x61, 0x28, 0x6B, 0xC6              ;"MINT"
            DB      0xEF, 0x6F, 0xA7, 0x28              ;"BASI"
            DB      0xE3, 0x6F, 0x61, 0xC7              ;"GAME"

;INTEL PASS/FAIL MESSAGE
LOAD_AD_P:  DB      0x4F, 0x6F, 0xA7, 0xA7              ;"PASS"
LOAD_AD_F:  DB      0x47, 0x6F, 0x28, 0xC2              ;"FAIL"

;BELOW ARE THE MAIN MENU DATA DISPLAYS.
MAIN_DA_TBL:
            DB      0x20, 0x64                          ;"in"
            DB      0xE4, 0xC6                          ;"ot"
            DB      0xC2, 0x00                          ;"L "
            DB      0xC7, 0xAE                          ;"EY"
            DB      0xC7, 0x4B                          ;"ER"
;EXTENDED MENU
            DB      0x00, 0x00                          ;"  "
            DB      0xC3, 0x00                          ;"C "
            DB      0xC7, 0xA7                          ;"ES"
;INTEL PASS/FAIL MESSAGE
LOAD_DA_P:  DB      0x04, 0x04                          ;"--"
LOAD_DA_F:  DB      0xC2, 0xEC                          ;"Ld"

;BELOW IS THE PERIMETER HANDLER COMMAND STRING FOR THE SIO ROUTINES.
ORG      $077F
SIO_P_DRIVER:
            DB      0xFF,0xFF                           ;BLANK
            DW      PERM_DA_TBL                         ;LED DISPLAY FOR DATA, 2 BYTES EACH
            DB      0x99,0x3F                           ;STORE KEYED INFO HERE AT 0X3F98
            DB      0x00,0x01                           ;NUMBER OF PERIMETER ITEMS, =2
            DB      0xFF,0xFF                           ;FUNCTION TO CALL WHEN GO PRESSED (FILLED IN BY MENU)
                                                        ;SEE 0426-044E).

;0789 - 078B ;(RESERVED FOR COMMAND STRING EXPANSION).
            DB      0xFF,0xFF,0xFF

;BELOW IS THE MAIN MENU DRIVER COMMAND STRING.
ORG      $078C
MAIN_M_DRIVER:
            DB      0xFF,0xFF                           ;BLANK
            DB      0x00,0x07                           ;FIRST MENU ITEM AND TOTAL NUMBER IF ENTRIES
            DW      MAIN_JP_TBL                         ;JUMP TABLE FOR MENU ITEMS
            DW      MAIN_AD_TBL                         ;MENU ADDRESS LED DISPLAY TABLE
            DW      MAIN_DA_TBL                         ;MENU DATA LED DISPLAY TABLE
            DB      0xC9                                ;MAIN MENU DATA KEY HANDLER
                                                        ;ROUTINE JUMP VECTOR (A RETURN INSTRUCTION).
;BELOW IS THE STEPPERS DATA DISPLAY CODES.
ORG     $0797
SEGREG_TBL: DB      0x4F, 0xC3                          ;"PC"
            DB      0x6F, 0x47                          ;"AF"
            DB      0xE6, 0xC3                          ;"BC"
            DB      0xEC, 0xC7                          ;"DE"
            DB      0x6E, 0xC2                          ;"HL"
            DB      0x28, 0x6E                          ;"IX"
            DB      0x28, 0xAE                          ;"IY"
            DB      0x7F, 0x57                          ;“AF'"
            DB      0xF6, 0xD3                          ;"BC'"
            DB      0xFC, 0xD7                          ;"DE'"
            DB      0x7E, 0xD2                          ;"HL'"
            DB      0xA7, 0x4F                          ;"SP"
            DB      0xFF                                ;(UNUSED)

;START OF STAGGERED TABLE OF JMON MODE WORDS FOR LCD
ORG     $07B0
LCDFNC_TBL: DB      0x44, 0x61, 0x74, 0x61              ;"Data"
            DB      0x41, 0x64, 0x64, 0x72              ;"Addr"

;LCD INITIALIZATION CODES
ORG     $07B8
LCDRST_TBL: DB      0x38, 0x01, 0x06, 0x0C              ;0X38 - 8-BIT MODE, 2 LINES, 5x8 DOTS
                                                        ;0x01 - CLEAR DISPLAY
                                                        ;0x06 - CURSOR TO RIGHT,NO SHIFT
                                                        ;0x0C - DISPLAY ON, CURSOR OFF

;THE REST OF THE JMON MODE WORD TABLE FOR LCD *THIS TABLE NEEDS TO BE 12 BYTES FROM LCDFNC_TBL
ORG     $07BC
L07B9:      DB      0x46, 0x73, 0x2D, 0x20              ;"Fs- "

;ADDRESS TABLE OF THE LCD PROMPT LOCATIONS.
ORG     $07C0
LCDPMT_TBL: DB      0x84, 0x87, 0x8A, 0x8D, 0xC4, 0xC7, 0xCA, 0xCD, 0x80

;SIO PERIMETER HANDLER DATA DISPLAYS
ORG     $07C9
PERM_DA_TBL:
            DB      0x04, 0xA7                          ;"-S" - ADDRESS START LOCATION
            DB      0x04, 0xC7                          ;"-E" - ADDRESS END LOCATION

            DB      0xFF, 0xFF, 0xFF                    ;(UNUSED)

;BELOW ARE THE DISPLAY CODE EQUIVALENTS OF THE HEX DIGITS 0 TO F LISTED IN ASCENDING ORDER.
ORG     $07D0
SEG_TBL:    DB      0xEB, 0x28, 0xCD, 0xAD, 0x2E, 0xA7, 0xE7, 0x29, 0xEF, 0x2F, 0x6F, 0xE6, 0xC3, 0xEC
            DB      0xC7, 0x47                      ;MJ: Split out to allow for a Label that is used

;FINALLY AT 07E0 IS THE FUNCTION-1 AND SHIFT JUMP ADDRESSES.  ACCESS BY PRESSING "SHIFT" + "NUMBER"
;OR "ADDRESS", then "+", then "NUMBER" TO ENTER FUNCTION-! MODE
ORG     $07E0
L07E0:      DW      FN_MENU                             ;#0 MAIN MENU SETUP TO MENU DRIVER
            DW      FN_BACK1                            ;#1 MOVE ADDRESS BACK ONE LOCATION
            DW      FN_STEPPER                          ;#2 STEPPER ROUTINE
            DW      0xFFFF                              ;#3 SPARE
            DW      FN_FORW4                            ;#4 MOVE ADDRESS FORWARD FOUR LOCATIONS
            DW      FN_S_RST                            ;#5 DO A SOFT RESET
            DW      FN_BACK4                            ;#6 MOVE ADDRESS BACK FOUR LOCATIONS
            DW      FN_REGDIS                           ;#7 DISPLAY REGISTERS
            DW      FN_FORW8                            ;#8 MOVE ADDRESS FORWARD EIGHT LOCATIONS
            DW      FN_FORW1                            ;#9 MOVE ADDRESS FORWARD ONE LOCATION
            DW      FN_BACK8                            ;#A MOVE ADDRESS BACK EIGHT LOCATIONS
            DW      J_BASIC                             ;#B TINY BASIC
            DW      J_GAMES                             ;#C GAMES
            DW      PLAY_TUNE                           ;#D TUNES ROUTINE
            DW      ASCII_SCRL                          ;#E ASCII SCROLL ROUTINE
            DW      J_MINT                              ;#F MINT
