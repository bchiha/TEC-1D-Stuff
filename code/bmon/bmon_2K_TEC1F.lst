# File /Users/slarti/Documents/TEC1x/TEC-1D-Stuff/code/bmon/bmon_2K_TEC1F.z80
0000			;  
0000			;BMON - THE BIG (BRIAN'S) MONITOR (2K VERSION TEC-1F)  
0000			;BY BRIAN CHIHA AND JIM ROBINSON  
0000			;  
0000			;THIS IS A MODIFIED VERSION OF JMON (JIM'S MONITOR).  IT KEEPS ALL THE GOOD THINGS OF  
0000			;THE MONITOR, LIKE AUTO INCREMENT, MENU AND PERIMETER HANDLERS, BREAK POINTS AND   
0000			;SINGLE STEPPER.  WHAT HAS BEEN CHANGED IS THAT THE TAPE HANDLING ROUTINES HAVE BEEN  
0000			;REPLACED WITH 'BIT BANGED' SERIAL COMMUNICATION, A KEYBOARD MOD FEATURE AND ASCII  
0000			;BANNER FOR THE SEVEN SEGMENTS.  
0000			;  
0000			;BMON HAS BEEN WRITTEN FOR THE TEC-1F WITH INTERGRATED SERIAL COMMUNICATION.  THE CONCEPT  
0000			;IS THAT PROGRAMMING/DEBUGGING IS DONE ON AN EXTERNAL Z80 COMIPLER AND THE PROGRAM IS THEN   
0000			;TRANSFERED TO THE TEC-1F VIA THE SERIAL COMMUNICATION PORT.  COMMUNICATION IS DONE   
0000			;VIA BIT 7 OF THE KEYBOARD BUFFER (IN PORT 0) AND BIT 6 OF THE SEVEN SEGEMENT ACTIVE PORT (OUT PORT 1)  
0000			;  
0000			;TO ENTER THE FEATURES, PRESS "SHIFT-0" ON THE KEYPAD.  CHOOSE THE MENU ITEM BY PRESSING  
0000			;PLUS OR MINUS, THEN HIT GO TO RUN THE ROUTINE.  (HIT ADDRESS TO ESCAPE).  THE NEW MENU  
0000			;ITEMS ARE:  
0000			;  
0000			;SIO-IN - SERIAL INPUT.  SELECT START AND END ADDRESS TO LOAD FROM YOUR COMPUTER TO THE TEC  
0000			;SIO-OT - SERIAL OUTPUT. SELECT START AND END ADDRESS TO SEND TEC DATA TO YOUR COMPUTER  
0000			;INTEL - INTEL HEX FILE INPUT.  SEND AN INTEL HEX FILE FROM YOUR COMPUTER TO THE TEC  
0000			;ALTKEY - CHANGE BETWEEN STANDARD KEYBOARD LAYOUT OR MARK JELIC'S ALTERNATE KEYPAD LAYOUT  
0000			;BANNER - ASCII BANNER TICKER DISPLAY, SELECT A START ADDRESS AND A BANNER WILL BE DISPLAYED  
0000			;  
0000			;SO THAT THE ALTERNATE KEYBOARD WILL RETAIN ON A RESET, A HARD RESET WILL ONLY OCCUR ON   
0000			;FIRST START UP AND WHEN THE RESET BUTTON IS PRESSED AT THE SAME TIME ANOTHER KEY IS PRESSED  
0000			;OTHERWISE ALL RESETS WILL BE SOFT AND RETAIN ANY USER SET UPS OR FLAGS.  
0000			;  
0000			;BIT BANG SERIAL ROUTINES 'TRANSMIT BYTE' AND 'RECEIVE BYTE' CAN BE CALLED EXTERNALLY BY  
0000			;DOING A CALL 004A AND CALL 004D.  SERIAL TRANSMISSION IS SET AT 4800-8-N-2  
0000			;  
0000			;THE FOLLOWING IS FROM THE JMON INSTRUCTIONS.  
0000			;  
0000			;GLOSSARY  
0000			;  
0000			;CURRENT EDITING LOCATION (082E)  
0000			;THIS IS THE ADDRESS THAT IS USUALLY DISPLAYED IN THE ADDRESS SECTION ON THE TEC LED  
0000			;DISPLAY. IT IS THE ADDRESS THAT IS SUBJECT TO MODIFICATION BY JMON.  
0000			;  
0000			;MONITOR CONTROL BYTE (MCB) (082B)  
0000			;THIS BYTE CONTAINS THE INFORMATION OF THE CURRENT WORKING STATE OF JMON. THE INFORMATION  
0000			;HELD IN THIS BYTE IS:  
0000			;1 - THE CURRENT MODE OF JMON.  
0000			;E.G. DATA, ADDRESS OR FUNCTION (NOT SHIFT AS SHIFT IS TESTED AND HANDLED DURING THE DATA  
0000			;KEY HANDLER ROUTINE). BITS 4 AND 5 ENCODE THE CURRENT MODE IN THE FOLLOWING WAY. BOTH  
0000			;BITS ARE LOW FOR THE DATA MODE, BIT 4 IS HIGH FOR THE ADDRESS MODE, BITS 4 AND 5 ARE HIGH  
0000			;FOR THE FUNCTION MODE. BIT 4 IS CALLED THE ADDRESS/FUNCTION BIT As THE SOFTWARE ONLY  
0000			;NEEDS TO TEST THIS BIT TO FIND IF EITHER THE ADDRESS OR FUNCTION MODE IS ACTIVE. BIT 5  
0000			;IS THE FUNCTION MODE ENABLED BIT.  
0000			;2 - THE NUMBER OF THE CURRENT FUNCTION I.E. 1,2 OR 3.  
0000			;THIS IS ENCODED IN BITS 2 AND 3. IF NO FUNCTION OR FUNCTION-1 IS ENABLED THEN BOTH BITS  
0000			;ARE LOW. IF FUNCTION-2 IS SELECTED THEN BIT 2 IS HIGH AND BIT 3 IS LOW. IF FUNCTION-3 IS  
0000			;SELECTED THEN BIT 3 IS HIGH AND BIT 2 IS LOW.  
0000			;3 - THE NUMBER OF NIBBLES ENTERED  
0000			;THIS IS ENCODED IN BITS 0 AND 1. IF NO NIBBLES HAVE BEEN ENTERED IN THE CURRENT EDITING  
0000			;LOCATION THEN BOTH BIT ARE LOW. IF ONE NIBBLE HAS BEEN ENTERED THEN BIT 0 IS HIGH AND  
0000			;BIT 1 IS LOW IS TWO NIBBLES HAVE BEEN ENTERED THEN BIT 0 IS LOW AND BIT 1 IS HIGH. JMON  
0000			;USES THESE BITS WHEN DECIDING ON THE AUTO-INCREMENT FEATURE. BITS 6 AND 7 ARE NOT USED.  
0000			;  
0000			;DISPLAY BUFFER ADDRESS - (082C/D)  
0000			;THE CONTENTS OF 082C/D POINTS TO THE LOCATION IN MEMORY OF THE 6 BYTE DISPLAY BUFFER  
0000			;(0800 FOR JMON AND 0806 FOR THE STEPPER). THE DISPLAY BUFFER ADDRESS POINTS TO THE LOWEST  
0000			;ADDRESS OF THE DISPLAY BUFFER WHICH CONTAINS THE LOW ORDER DATA DISPLAY BYTE.  
0000			;  
0000			;KEY PLANT  
0000			;THE KEY PLANT IS A FAKE KEY STROKE THAT MAY BE GENERATED BY THE "DURING SCAN/REY LOOP"  
0000			;USER PATCH. THE PLANT ALLOWS JMON'S MONITOR FUNCTIONS TO BE SOFTWARE CONTROLLED E.G. YOU  
0000			;MAY WISH TO VIEW THE CONTENTS ,OF MEMORY BYTE BY BYTE. WITH THE KEY PLANT YOU CAN SET JMON  
0000			;UP TO AUTOMATICALLY INCREMENT THE CURRENT EDIT LOCATION EVERY FEW SECONDS.  
0000			;THE PLANT IS IDENTIFIED BY THE USER PATCH STORING THE REQUIRED KEY VALUE IN, AND SETTING  
0000			;BIT 7 OF THE INPUT KEY BUFFER (0820).  
0000			;  
0000			;AUTO KEY STATUS BYTE (082A)  
0000			;THIS BYTE HOLDS THE INFORMATION REQUIRED FOR THE AUTO KEY REPEAT SECTION. THE INFORMATION  
0000			;HELD IN THIS BYTE IS EITHER ONE OF THE FOLLOWING:  
0000			;A "NEXT KEY DETECTION WILL BE A FIRST DETECTION" SO JMON WILL PROCESS THE KEY IMMEDIATELY  
0000			;(BIT 7 HIGH) . A TIMER (BITS 0-6) THAT COUNTS, A DELAY FOR THE AUTO. REPEAT TIMING.  
0000			;  
0000			;KEY PRESS FLAG (0825)  
0000			;THIS FLAG IS USED TO REMEMBER IF THE ONE KEY PRESS HAS ALREADY BEEN DETECTED AND PROCESSED.  
0000			;THIS PREVENTS THE SAME KEY BEING PROCESSED EACH TIME THE SOFTWARE FINDS THAT IT IS PUSHED.  
0000			;THIS IS THE WAY IT WORKS:  
0000			;THE KEY PRESS FLAG 1S ZEROED BY THE JMON DEFAULT VARIABLES AND THIS FLAGS A "NO KEY  
0000			;PRESSED" STATE. WHEN A KEY IS DETECTED THEN THIS FLAG IS TESTED AND IF ZERO THEN THE KEY  
0000			;IS ACCEPTED AS A FIRST KEY PRESS. IN THIS CASE THE KEY PRESS FLAG IS THEN SET TO FF TO  
0000			;REMEMBER THAT THE KEY PRESS HAS BEEN DETECTED. IF A KEY IS DETECTED AND THIS FLAG BYTE  
0000			;IS NOT ZERO, THEN THE KEY IS IGNORED. WHEN THE SOFTWARE FINDS THAT NO KEY IS BEING PRESSED,  
0000			;THEN THIS FLAG IS CLEARED TO ALLOW THE NEXT KEY PRESS DETECTED TO BE PROCESSED.  
0000			;THIS FLAG IS USED BY THE RST 08, RST 10 RST 18 AND RST 20 KEYBOARD ROUTINES AS DESCRIBED  
0000			;IN ISSUE 15 TALKING ELECTRONICS AND ALSO THE STEPPER SOFTWARE.  
0000			;THE AUTO KEY REPEAT ROUTINE DOES NOT USE THIS FLAG BYTE, DO NOT CONFUSE THIS FLAG WITH  
0000			;THE AUTO KEY STATUS BYTE WHICH IS USED BY THE AUTO KEY REPEAT SECTION.  
0000			;  
0000			;"NEXT PC" BUFFER  
0000			;THIS IS A TEMPORARY PLACE TO SAVE THE RETURN ADDRESS WHICH IS THEN USED AS THE ACTUAL PC  
0000			;VALUE FOR THE NEXT INSTRUCTION STEPPED.  
0000			;  
0000			;FORCED HARD RESET  
0000			;THIS IS ACHIEVED BY HOLDING DOWN A KEY WHEN RELEASING THE RESET. THE HARD RESET CAUSES  
0000			;JMON TO RE-BOOT ITS VARIABLES AND ALSO MASK OFF ALL THE USER PATCHES (EXCEPT THE RESET  
0000			;PATCH). THE MAIN PURPOSE OF A FORCED HARD RESET IS TO RECOVER THE TEC IF A USER PATCH  
0000			;ENTERS A CONTINUOUS LOOP.  
0000			;  
0000			;  
0000			;PRECOMPILE SETUP FOR STANDARD TEC-1D (OR BELOW) OR TEC-1F  
0000			;** NOTE: USER MUST CHANGE THE MACHINE LABEL FOR TARGET MACHINE **  
0000			TEC_1F:     EQU     0x1F                                ;TEC 1F MACHINE  
0000			TEC_1D:     EQU     0x1D                                ;TEC 1D MACHINE  
0000			TEC_1C:     EQU     0x1C                                ;TEC 1C MACHINE  
0000			TEC_1B:     EQU     0x1B                                ;TEC 1B MACHINE  
0000			TEC_1A:     EQU     0x1A                                ;TEC 1A MACHINE  
0000			TEC_1:      EQU     0x01                                ;TEC 1 MACHINE  
0000			  
0000			;BIT BANG BAUD RATES CONSTANTS FOR 4MHz  
0000			B300:	    EQU	    0x220                               ;BAUD 0300  
0000			B1200:	    EQU	    0x80                                ;BAUD 1200  
0000			B2400:	    EQU	    0x3F                                ;BAUD 2400  
0000			B4800:	    EQU	    0x1B                                ;BAUD 4800  
0000			B9600:	    EQU	    0x0B                                ;BAUD 9600  
0000			DEF_BAUD:   EQU     B4800                               ;DEFAULT BAUD TO 4800  
0000			  
0000			REG_TBL:    EQU     0794H - 2                           ;BASE OF REGISTER NAME TABLE  
0000			DISP_BUFF:  EQU     0800H                               ;Current displayed Address Buffer  
0000			DISP_DBUFF: EQU     0804H                               ;Current displayed Data Buffer  
0000			DISP_D2BUF: EQU     0805H                               ;Character #2 of the Data Display Buffer  
0000			DISP_STEP:  EQU     0806H                               ;Stepper's 6 Byte Display Buffer  
0000			  
0000			;USER VARIABLE START LOCATION  
0000			V_KEY:      EQU     0820H                               ;KEY BUFFER  
0000			V_LCD:      EQU     0821H                               ;LCD ON/OFF FLAG  
0000			V_BEEP:     EQU     0822H                               ;SOUND ON/OFF  
0000			V_ALT_ADDF: EQU     0823H                               ;GO AT ALTERNATE GO ADDRESS IF AA  
0000			V_STEP_TMR: EQU     0824H                               ;STEPPER KEY CONTROL/TIMER  
0000			V_KEY_PRES: EQU     0825H                               ;KEY PRESS FLAG  
0000			V_ALT_KEYB: EQU     0826H                               ;ALTERNATIVE KEYBOARD LAYOUT FLAG  
0000			V_AUTO:     EQU     0827H                               ;AUTO INCREMENT ON/OFF  
0000			V_ALT_ADDR: EQU     0828H                               ;ALT GO ADDR/SOFT RESET EDIT LOCATION  
0000			V_KAUTO:    EQU     082AH                               ;AUTO KEY STATUS BYTE  
0000			V_MCB:      EQU     082BH                               ;MONITOR CONTROL BYTE (MCB)  
0000			V_DISPLAY:  EQU     082CH                               ;DISPLAY BUFFER ADDRESS (using 7seg Display codes)  
0000			V_CEL:      EQU     082EH                               ;CURRENT EDITING LOCATION (CEL)  
0000			  
0000			;The following are the JUMP addresses that a CALLED by JMON,  
0000			;after they are copied from the ROM (starting @ 071Fh) to the RAM @ 0830h, on a Hard Reset.  
0000			;They point back to routines in the ROM, so not sure why this was done.  
0000			HL_2_DIS:   EQU     0830H                               ;CONVERT HL TO DISPLAY CODE @ 01D5h  
0000			A_2_DISP:   EQU     0833H                               ;CONVERT A TO DISPLAY CODE @ 01DAh  
0000			LED_SCAN:   EQU     0836H                               ;LED SCAN ROUTINE @ 01BAh  
0000			SET_DOTS:   EQU     0839H                               ;SET LED DOTS @ 01EEh  
0000			BEEPBEEP:   EQU     083CH                               ;RESET TONES @ 0224h (TWO BEEPS)  
0000			BEEP:       EQU     083FH                               ;TONE @ 0227h  
0000			SCAN_IO:    EQU     0842H                               ;SCAN/KEY/LCD/PATCH LOOP @ 0181h  
0000			DO_DISP:    EQU     0845h                               ;SOFT JMON ENTRY L0845 @ 00B2h  
0000			LCD_DISP:   EQU     0848H                               ;LCD ROUTINE @ 023Ch  
0000			  
0000			;Various other Monitor Locations to help with its functionality  
0000			PATCH_BEF:  EQU     084BH                               ;PRE-SCAN USER PATCH  
0000			PATCH_DUR:  EQU     084EH                               ;USER "DURING LOOP" PATCH  
0000			PATCH_AFT:  EQU     0851H                               ;USER "AFTER KEY" PATCH  
0000			PATCH_KEY:  EQU     0854H                               ;USER "KEYBOARD" PATCH  
0000			STEP_NEXT:  EQU     0858H                               ;ADDRESS OF INSTRUCTION JUST STEPPED  
0000			STEP_CREG:  EQU     085AH                               ;CURRENT REG No. BUFFER  
0000			RE_ENTRY:   EQU     0860H                               ;RE-ENTRY ADDRESS BUFFER  
0000			STEP_PREV:  EQU     0868H                               ;"NEXT PC" BUFFER  
0000			STEP_REGS:  EQU     086Ah                               ;SHIFT 7 ROUTINE START (REG DISPLAY)  
0000			HL_SAVE:    EQU     086EH                               ;HL SAVE ON RESET  
0000			STEP_HL:    EQU     0870H                               ;STEPPER INITIAL HL  
0000			STEP_SP:    EQU     087EH                               ;Stack Pointer Save Buffer  
0000			PERI_SETUP: EQU     0880H                               ;PERIMITER MENU SETUP  
0000			PERI_D_TBL: EQU     0882H                               ;PERIMITER DATA SEGMENT TABLE  
0000			PERI_W_ADD: EQU     0884H                               ;PERIMITER WINDOW ENTRY START LOCATION  
0000			PERI_W_CUR: EQU     0886H                               ;CURRENT PERIMETER WINDOW  
0000			PERI_W_MAX: EQU     0887H                               ;TOTAL PERIMETER WINDOWS  
0000			PERI_J_ADR: EQU     0888H                               ;PERIMITER GO JUMP ADDRESS  
0000			PERI_W_AC1: EQU     088CH                               ;PERIMITER ACTIVE WINDOW + 1  
0000			MENU_SETUP: EQU     088DH                               ;MENU SETUP START  
0000			MENU_NO:    EQU     088FH                               ;MENU ENTRY NUMBER  
0000			MENU_J_TBL: EQU     0891H                               ;MENU JUMP TABLE  
0000			MENU_A_TBL: EQU     0893H                               ;MENU ADDRESS SEGMENT TABLE  
0000			MENU_D_TBL: EQU     0895H                               ;MENU DATA SEGMENT TABLE  
0000			MENU_KEYRN: EQU     0897H                               ;MENU DATA KEY RETURN HANDLER (USE C9 IF N/A)  
0000			SIO_START:  EQU     0898H                               ;START OF SIO TRANSFER ADDRESS  
0000			SIO_END:    EQU     089AH                               ;SEND OF SIO TRANSFER ADDRESS  
0000			  
0000			BAUD:       EQU     08A4H                               ;BAUD RATE DELAY FOR SIO  
0000			HEX_ADDR:   EQU     08A6H                               ;INTEL HEX START ADDRESS  
0000			HEX_CHKSUM: EQU     08A8H                               ;INTEL HEX CHECKSUM  
0000			PATCH_REQ:  EQU     08B0H                               ;RESET PATCH REQUIRED IF 0xAA IS HERE  
0000			PATCH_STA:  EQU     08B1H                               ;RESET PATCH START ADDRESS. 0x08B1-0x08B2  
0000			PATCH_VAR:  EQU     08B3H                               ;RESET PATCH VARIABLE.  0X08B4 Size of Patch  
0000			PATCH_CHK:  EQU     08B5h                               ;RESET PATCH CHECKSUM  
0000			PATCH_ADR:  EQU     08B6H                               ;RESET PATCH ADDRESS. 0x08B6-0x08B7  
0000			USER_TBL:   EQU     08C0H - 2                           ;User Table -2  
0000			RST_FLAG:   EQU     08FFH                               ;Reset Flag  
0000			JMON_UTIL:  EQU     3800H                               ;JMON UTILITIES ADDRESS START LOCATION   
0000			JMON_JUMP:  EQU     381Eh                               ;START OF THE JUMP TABLE IN THE JMON UTILITIES  
0000			  
0000			;IO Port ASSIGNMENTS  
0000			KEYBOARD:   EQU     0x00                                ;KEYBOARD ENCODER  
0000			DSCAN:      EQU     0x01                                ;DISPLAY CATHODE DRIVER LATCH  
0000			DSEGMENT:   EQU     0x02                                ;DISPLAY SEGMENT DRIVER LATCH  
0000			  
0000			;DAT BOARD  
0000			P_DAT:      EQU     0x00                                ;DAT BOARD LATCH COMBINED ON KEYBOARD LATCH  
0000			P_LCDDATA:  EQU     0x84                                ;LCD DATA REGISTER  
0000			P_LCDINST:  EQU     0x04                                ;LCD INSTRUCTION REGISTER  
0000			  
0000			;KEYBOARD REFERENCES  
0000			K_PLUS:     EQU     0x10                                ;+ KEY  
0000			K_MINUS:    EQU     0x11                                ;- KEY  
0000			K_GO:       EQU     0x12                                ;GO KEY  
0000			K_ADDR:     EQU     0x13                                ;ADDRESS KEY  
0000			  
0000			  
0000			;AT THE START OF JMON, HL IS SAVED IN ITS SINGLE STEPPER BUFFER ADD THE SOFT RESET DISPLAY  
0000			;VALUE IS PLACED IN THE CURRENT EDIT LOCATION BUFFER. THE ROUTINE THEN IS CONTINUED AT $0068.  
0000			ORG     $0000  
0000 22 6e 08		            LD      (HL_SAVE), HL                       ;SAVE HL PART OF REGISTER SAVE  
0003 2a 28 08		            LD      HL, (V_ALT_ADDR)                    ;GET SOFT RESET INITIAL EDIT  
0006 18 63		            JR      MON_START                           ;LOCATION AND CONTINUE AT 006B  
0008			  
0008			;RST 08 AND RST 10 (CF AND D7)  
0008			;THESE TWO COMBINE TOGETHER TO SIMULATE A HALT INSTRUCTION. THIS IS DONE BY LOOPING UNTIL  
0008			;THE CURRENT (IF ANY) KEY PRESS IS RELEASED (RST 08), AND THEN LOOPING UNTIL A NEW KEY  
0008			;PRESS IS DETECTED (RST 10).  
0008			  
0008 e7			RST08:      RST     20H                                 ;TEST FOR KEY PRESS  
0009 28 fd		            JR      Z, RST08                            ;LOOP IF KEY PRESSED  
000b 00			            NOP                                         ;ELSE  
000c 00			            NOP                                         ;MOVE  
000d 00			            NOP                                         ;TO  
000e 00			            NOP                                         ;NEXT  
000f 00			            NOP                                         ;RST  
0010 e7			RST10:      RST     20H                                 ;TEST FOR KEY AGAIN  
0011 20 fd		            JR      NZ, RST10                           ;LOOP IF KEY NOT PRESSED  
0013 e6 1f		            AND     0x1F                                ;MASK OFF JUNK BITS  
0015 ed 47		            LD      I, A                                ;STORE IN INTERRUPT REGISTER  
0017 c9			            RET                                         ;DONE  
0018			  
0018			;RST 18 (DF) AND RST 20 (E7)  
0018			;RST 18 CALLS THE LED SCAN ROUTINE ONCE THEN MOVES ON INTO RST 20 THAT THEN CALLS A KEYBOARD  
0018			;READ ROUTINE.  
0018			;THE KEYBOARD MUST BE READ CONTINUOUSLY OVER A PERIOD OF TIME, AS THE DATA AVAILABLE SIGNAL  
0018			;(BIT 6, PORT 3) (USUALLY) PULSES, WHEN A KEY IS PRESSED, IN TIME WITH THE KEY ENCODER  
0018			;CHIP'S SCANNING. IF THE KEY BOARD IS READ ONLY ONCE EVERY SECOND, THEN THE SOFTWARE MAY  
0018			;AND PROBABLY) WILL TARE SEVERAL SECONDS TO DETECT THE KEY.  
0018			;THE NUMBER OF READ CYCLES FOR THE KEYBOARD IS LOADED INTO B.  
0018			  
0018 e5			RST18:      PUSH    HL                                  ;SAVE HL  
0019 d5			            PUSH    DE                                  ;AND DE  
001a cd 36 08		            CALL    LED_SCAN                            ;CALL SCAN ROUTINE  
001d d1			            POP     DE                                  ;RECOVER DE  
001e e1			            POP     HL                                  ;AND HL  
001f 00			            NOP                                         ;NEXT RST  
0020 c5			RST20:      PUSH    BC                                  ;SAVE BC  
0021 06 20		            LD      B, 0x20                             ;B = NUMBER OF KEYBOARD SCAN LOOPS  
0023 cd ad 06		            CALL    KEY_READ                            ;CALL KEY READER/VALIDATER  
0026 c1			            POP     BC                                  ;RECOVER BC  
0027 c9			            RET                                         ;DONE  
0028			  
0028			;RST 28 (EF)  
0028			;START STEPPING FROM THE INSTRUCTION FOLLOWING THE RST 28  
0028 e3			RST28:      EX      (SP), HL                            ;GET RETURN ADDRESS FROM THE STACK  
0029 22 58 08		            LD      (STEP_NEXT), HL                     ;PUT IN "NEXT PC" BUFFER  
002c e3			            EX      (SP), HL                            ;FIX UP STACK  
002d fb			            EI                                          ;ENABLE INTERRUPTS  
002e c9			            RET                                         ;STEPPING WILL OCCUR AFTER RETURN  
002f ff			            DB      0xFF                                ;SPARE  
0030			  
0030			;RST 30 (F7)  
0030			;TEST THE BUSY STATE OF THE LCD AND LOOP WHILE BUSY  
0030 db 04		RST30:      IN      A, (P_LCDINST)                      ;READ STATUS BIT FROM LCD  
0032 07			            RLCA                                        ;PUT IN CARRY  
0033 38 fb		            JR      C, RST30                            ;LOOP IF LCD BUSY  
0035 c9			            RET                                         ;DONE  
0036 ff ff		            DB      0xFF,0xFF                           ;SPARE  
0038			  
0038			;RST 38 (FF)  
0038			;INTERRUPT HANDLER FOR STEPPER AND BREAK-POINTS  
0038 c3 12 03		RST38:      JP      STEPPER                             ;JUMP TO STEPPER ROUTINE  
003b ff ff ff ff ff ff	            DB      0xFF,0xFF,0xFF,0xFF,0xFF,0xFF       ;SPARE  
0041			  
0041			;JUMP TABLE FOR EXTERNAL SOFTWARE TO USE JMON ROUTINES  
0041 c3 dd 03		L0041:      JP      MENU_RTN                            ;MENU ROUTINE  
0044 c3 79 04		L0044:      JP      PERI_RTN                            ;PERIMETER HANDLER ENTRY  
0047 c3 ed 03		L0047:      JP      MENU_SFT                            ;SOFT MENU ENTRY  
004a c3 f0 04		L004A:      JP      TXCHAR                              ;TRANSMIT BYTE  
004d c3 1b 05		L004D:      JP      RXCHAR                              ;RECIEVE BYTE  
0050 c3 a3 04		L0050:      JP      PERI_SFT                            ;SOFT PERIMETER HANDLER ENTRY  
0053 ff ff ff ff ff ff ff	            DB      0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF  ;SPARE  
005a ff ff ff ff	            DB      0xFF,0xFF,0xFF,0xFF                 ;SPARE  
005e			  
005e			;SHIFT-2 ROUTINE  
005e			;THIS STORES THE CURRENT EDIT LOCATION IN THE "NEXT PC" BUFFER. THE INTERRUPTS ARE THEN  
005e			;ENABLED AND THE PROGRAM JUMPS TO THE USER ROUTINE TO BE STEPPED. STEPPING OCCURS AT THE  
005e			;CURRENT EDIT LOCATION (CEL).  
005e 2a 2e 08		FN_STEPPER: LD      HL, (V_CEL)                         ;PUT CURRENT EDIT LOCATION IN  
0061 22 58 08		            LD      (STEP_NEXT), HL                     ;"NEXT PC" BUFFER  
0064 fb			            EI                                          ;ENABLE INTERRUPTS  
0065 e9			            JP      (HL)                                ;START STEPPING  
0066			  
0066			;NMI HANDLER (IMMEDIATE RETURN)  
0066 ed 45		            RETN                                        ;IGNORE NMI  
0068 ff			            RST     38H                                 ;RESERVED  
0069 ff			            RST     38H                                 ;FOR A "Post Burn"  
006a ff			            RST     38H                      
006b			  
006b			;CONTINUATION OF MONITOR  
006b ed 56		MON_START:  IM      1                                   ;SET INTERRUPT MODE 1 FOR STEPPER  
006d 22 2e 08		            LD      (V_CEL), HL                         ;STORE SOFT RESET INITIAL CEL  
0070 21 76 00		            LD      HL, MON_START2                      ;LOAD HL WITH RE-ENTRY ADDRESS  
0073 c3 18 03		            JP      SAVE_REGS                           ;JUMP TO SAVE REGISTERS  
0076			  
0076			  
0076			;RE-ENTRY POINT AFTER SAVING REGISTERS  
0076 31 20 08		MON_START2: LD      SP, V_KEY                           ;SET STACK (to the Keyboard Buffer??)  
0079			            ;CALL    RST_PATCH                           ;CALL RESET PATCH HANDLER  
0079 00			            NOP  
007a 00			            NOP  
007b e7			            RST     20H                                 ;LOOK FOR FORCED HARD RESET  
007c 28 07		            JR      Z, HARD_RST                         ;JUMP KEY PRESSED TO HARD RESET  
007e 3a ff 08		            LD      A, (RST_FLAG)                       ;CHECK HARD/RESET FLAG  
0081 fe aa		            CP      0xAA                                ;FOR AA  
0083 28 1d		            JR      Z, SOFT_RST                         ;JUMP TO SOFT RESET IF AA  
0085			  
0085			;HARD RESET  
0085			;MONITOR DEFAULT VARIABLES ARE RE-BOOTED AND USER PATCHES MASKED OFF.  
0085			  
0085 21 0f 07		HARD_RST:   LD      HL, DEF_VARS                        ;LOAD HL WITH START OF JMON DEFAULT  
0088 11 20 08		            LD      DE, V_KEY                           ;VARIABLES ROM TABLE  
008b 01 2b 00		            LD      BC, 0x002B                          ;DE IS THE RAM DE(stination)  
008e ed b0		            LDIR                                        ;AND BC THE COUNT: MOVE TABLE  
0090 06 04		            LD      B, 0x04                             ;MASK OF THE FOUR USER PATCHES  
0092 3e c9		            LD      A, 0xC9                             ;BY PUTTING A RETURN AT THE FIRST  
0094 12			L0095:      LD      (DE), A                             ;LOCATION OF EACH  
0095 13			            INC     DE                                  ;  
0096 13			            INC     DE                                  ;  
0097 13			            INC     DE                                  ;  
0098 10 fa		            DJNZ    L0095                               ;  
009a cd d8 06		            CALL    LCD_RESET                           ;INITIALIZE/TEST FOR THE LCD  
009d 3e aa		            LD      A, 0xAA  
009f			           ; XOR     A                                   ;CLEAR HARD/SOFT  
009f 32 ff 08		            LD      (RST_FLAG), A                       ;RESET FLAG  
00a2			  
00a2			;THIS SECTION IS THE SOFT RESET SECTION. IT IS ALSO PART OF THE HARD RESET SECTION.  
00a2 21 00 38		SOFT_RST:   LD      HL, JMON_UTIL                       ;TEST FOR JMON UTILITIES ROM  
00a5 7e			            LD      A, (HL)  
00a6 fe c3		            CP      0xC3                                ;AND CALL ITS RESET ROUTINE  
00a8 cc 00 38		            CALL    Z, JMON_UTIL                        ;IF REQUIRED  
00ab cd 3c 08		            CALL    BEEPBEEP                            ;CALL RESET TONE ROUTINE (BEEP BEEP)  
00ae af			FN_S_RST:   XOR     A                                   ;CLEAR MONITOR CONTROL BYTE  
00af 32 2b 08		            LD      (V_MCB), A                          ;0 = DATA MODE, NO NIBBLES ENTERED  
00b2			  
00b2			;EACH TIME A KEYBOARD INPUT OR USER PATCH "PLANT", IS PROCESSED, THE PROGRAM JUMPS BACK  
00b2			;TO HERE SO THE DISPLAYS MAY BE UP-DATED.  
00b2			  
00b2 2a 2e 08		J_DISPUPD:  LD      HL, (V_CEL)                         ;GET CURRENT EDIT LOCATION (CEL)  
00b5 ed 4b 2c 08	            LD      BC, (V_DISPLAY)                     ;AND DISPLAY BUFFER ADDRESS  
00b9 cd 30 08		            CALL    HL_2_DIS                            ;AND CONVERT CEL TO DISPLAY CODE  
00bc 7e			            LD      A, (HL)                             ;AND THEN CONVERT CONTENTS OF  
00bd cd 33 08		            CALL    A_2_DISP                            ;CEL TO DISPLAY CODE  
00c0 cd 39 08		            CALL    SET_DOTS                            ;CALL THE SET DOTS ROUTINE  
00c3 cd 42 08		            CALL    SCAN_IO                             ;CALL SCAN/KEY/LCD/PATCH ROUTINE  
00c6			  
00c6			;THE SECTION BELOW IS EXECUTED WHEN EITHER A KEY OR KEY "PLANT" IS DETECTED IN THE  
00c6			;SCAN/KEY/LCD/PATCH ROUTINE ROUTINE  
00c6			KEY_MGMT:  
00c6 2a 2e 08		            LD      HL, (V_CEL)                         ;POINT HL TO CURRENT EDIT LOCATION  
00c9 4f			            LD      C, A                                ;PRESERVE INPUT KEY IN C  
00ca 3a 2b 08		            LD      A, (V_MCB)                          ;GET MONITOR CONTROL BYTE (MCB)  
00cd cb 67		            BIT     4, A                                ;TEST FOR ADDRESS OR FUNCTION MODE  
00cf 47			            LD      B, A                                ;STORE MCB IN B  
00d0 79			            LD      A, C                                ;GET INPUT KEY BACK IN A  
00d1 20 2f		            JR      NZ, KEY_ADDR                        ;JUMP IF ADDRESS OR FUNCTION MODE  
00d3 fe 10		KEY_PLUS:   CP      K_PLUS                              ;TEST FOR "+"  
00d5 20 0c		            JR      NZ, KEY_MINUS                       ;JUMP IF NOT TO TEST FOR "-"  
00d7			  
00d7			;"+" KEY HANDLER-(WHEN IN DATA MODE ONLY)  
00d7			  
00d7 23			            INC     HL                                  ;ADD 1 TO CURRENT EDIT LOCATION  
00d8			  
00d8			;COMMON CEL AND MCB UP-DATER  
00d8			;SEVERAL SECTIONS JUMP HERE TO STORE AN UP-DATED CEL AND CLEAR THE NIBBLE COUNTER.  
00d8			  
00d8 22 2e 08		L00D8:      LD      (V_CEL), HL                         ;STORE CEL  
00db 78			            LD      A, B                                ;GET MCB  
00dc			  
00dc			;COMMON MCB UP-DATER  
00dc			;SOME KEY HANDLER SECTION THAT DON'T REQUIRE.A NEW CEL (OR HAVE ALREADY STORED IT) JUMP HERE.  
00dc			  
00dc e6 fc		L00DC:      AND     0xFC                                ;CLEAR NIBBLE COUNTER  
00de 32 2b 08		            LD      (V_MCB), A                          ;STORE MCB  
00e1 18 cf		L00E1:      JR      J_DISPUPD                           ;JUMP BACK TO UPDATE DISPLAY  
00e3 fe 11		KEY_MINUS:  CP      K_MINUS                             ;TEST FOR "-"  
00e5 20 03		            JR      NZ, KEY_GO                          ;JUMP IF NOT TO TEST FOR "GO"  
00e7			  
00e7			;"-" KEY HANDLER (WHEN IN DATA MODE ONLY)  
00e7 2b			            DEC     HL                                  ;DECREASE CEL ADDRESS BY ONE  
00e8 18 ee		            JR      L00D8                               ;JUMP TO COMMON CEL AND MCB UP-DATER  
00ea fe 12		KEY_GO:     CP      K_GO                                ;TEST FOR GO  
00ec 20 14		            JR      NZ, KEY_ADDR                        ;JUMP IF NOT TO TEST FOR "AD"  
00ee			  
00ee			;"GO" HANDLER (WHEN IN DATA MODEONLY)  
00ee 3a 23 08		            LD      A, (V_ALT_ADDF)                     ;TEST FOR ALTERNATE GO ADDRESS  
00f1 fe aa		            CP      0xAA                                ;IF (0823)=AA  
00f3 28 05		            JR      Z, L00FA                            ;JUMP IF SET FOR ALTERNATE GO ADDR  
00f5 2a 2e 08		            LD      HL, (V_CEL)                         ;ELSE GET CURRENT EDIT LOCATION  
00f8 18 03		            JR      L00FD                               ;SKIP ALTERNATE JUMP ADDRESS FETCH  
00fa 2a 28 08		L00FA:      LD      HL, (V_ALT_ADDR)                    ;GET ALTERNATE GO ADDRESS  
00fd 11 45 08		L00FD:      LD      DE, DO_DISP                         ;PUT RETURN ADDRESS ON STACK  
0100 d5			            PUSH    DE  
0101 e9			            JP      (HL)                                ;START USER EXECUTION  
0102			  
0102			;TEST HERE FOR ADDRESS KEY. IF THE KEY PRESSED IS NOT THE ADDRESS KEY, THEN A JUMP IS  
0102			;PERFORMED. OTHERWISE THE ADDRESS KEY IS PROCESSED.  
0102			  
0102 fe 13		KEY_ADDR:   CP      0x13                                ;TEST FOR ADDRESS KEY  
0104 20 0b		            JR      NZ, L0111                           ;0= IF NOT TO DATA KEY HANDLER  
0106 78			            LD      A, B                                ;GET MONITOR CONTROL BYTE (MCB)  
0107 cb 68		            BIT     5, B                                ;TEST FOR FUNCTION MODE AND JUMP TO  
0109 20 02		            JR      NZ, L010D                           ;CLEAR FUNCTION MODE BITS IF SO  
010b ee 10		            XOR     0x10                                ;ELSE TOGGLE ADDRESS MODE BIT  
010d e6 d3		L010D:      AND     0xD3                                ;CLEAR ALL FUNCTION MODE BITS  
010f 18 cb		            JR      L00DC                               ;LOOP BACK TO COMMON MCB UP-DATER  
0111			  
0111			;A TEST FOR ADDRESS/FUNCTION MODE IS DONE. IF IN ADDRESS OR FUNCTION MODE A JUMP IS PERFORMED.  
0111 78			L0111:      LD      A, B                                ;GET MCB  
0112 cb 67		            BIT     4, A                                ;TEST FOR ADDRESS OR FUNCTION MODE  
0114 20 25		            JR      NZ, KEY_CTRL                        ;JUMP IF EITHER MODE  
0116			  
0116			;A TEST FOR SHIFT IS DONE AND A JUMP IS PERFORMED IF IN THE SHIFT MODE TO THE FUNCTION/SHIFT HANDLER.  
0116 db 00		            IN      A, (KEYBOARD)                       ;TEST FOR THE SHIFT KEY  
0118 cb 6f		            BIT     5, A                                ;AND JUMP IF SHIFT IS PRESSED  
011a 28 34		            JR      Z, KEY_FUNC                         ;TO THE FUNCTION HANDLER  
011c			  
011c			;ANY TIME A DATA KEY IS PRESSED WHILE IN THE DATA MODE, IT IS PROCESSED STARTING HERE.  
011c 78			KEY_DATA:   LD      A, B                                ;GET MCB  
011d e6 03		            AND     0x03                                ;MASK IT DOWN TO BYTE COUNTER  
011f fe 02		            CP      0x02                                ;AND TEST FOR TWO NIBBLES ENTERED  
0121 78			            LD      A, B                                ;INPUT KEY VALUE BACK IN A  
0122 20 0e		            JR      NZ, L0132                           ;JUMP IF NOT READY FOR AUTO INC  
0124 f5			            PUSH    AF                                  ;SAVE MCB  
0125 3a 27 08		            LD      A, (V_AUTO)                         ;TEST AUTO INC MASK  
0128 b7			            OR      A                                   ;IF NOT ZERO THEN JUMP AS USER  
0129 20 04		            JR      NZ, L012F                           ;HAS SWITCHED OFF AUTO INC MODE  
012b 23			            INC     HL                                  ;ELSE INCREMENT CEL BEFORE ENTERING  
012c 22 2e 08		            LD      (V_CEL), HL                         ;NEW NIBBLE AND STORE NEW CEL  
012f f1			L012F:      POP     AF                                  ;RECOVER MON CONTROL BYTE IN A  
0130 e6 fc		            AND     0xFC                                ;CLEAR BYTE COUNTER (BITS 0 AND 1)  
0132 3c			L0132:      INC     A                                   ;ADD ONE TO NIBBLE COUNTER  
0133 32 2b 08		            LD      (V_MCB), A                          ;STORE IT  
0136 3a 20 08		            LD      A, (V_KEY)                          ;GET INPUT KEY FROM INPUT BUFFER  
0139 18 11		            JR      L014C                               ;JUMP TO ENTER IT  
013b			  
013b			;TEST HERE FOR A CONTROL KEY WHILE IN EITHER THE ADDRESS OR FUNCTION MODE AND JUMP TO  
013b			;ENCODE THE FUNCTION NUMBER BITS (2 AND 3 OF MCB). IF NOT A CONTROL KEY, THEN TEST FOR  
013b			;THE FUNCTION MODE AND JUMP TO FUNCTION JUMP CONTROL IF SO, ELSE SERVICE DATA KEY FOR  
013b			;ADDRESS MODE.  
013b			  
013b 3a 20 08		KEY_CTRL:   LD      A, (V_KEY)                          ;GET INPUT KEY FROM INPUT BUFFER  
013e cb 67		            BIT     4, A                                ;TEST FOR CONTROL KEY (+,- OR GO)  
0140 20 2f		            JR      NZ, ENC_FUNC                        ;JUMP IF CONTROL TO FUNCTION ENCODER  
0142 cb 68		            BIT     5, B                                ;TEST FUNCTION MODE  
0144 20 0a		            JR      NZ, KEY_FUNC                        ;JUMP IF SO TO FUNCTION JUMP CONTROL  
0146			  
0146			;DATA KEY PRESS WHILE IN THE ADDRESS MODE  
0146 21 2e 08		            LD      HL, V_CEL                           ;POINT HL TO CEL BUFFER  
0149 ed 6f		            RLD                                         ;AND SHIFT IN THE NEW NIBBLE  
014b 23			            INC     HL                                  ;AND MOVE THE OTHERS ACROSS  
014c ed 6f		L014C:      RLD                                         ;THIS RLD USED BY DATA MODE ALSO  
014e 18 91		L014E:      JR      L00E1                               ;JUMP (VIA A JUMP) TO UP-DATE DISPLAYS  
0150			  
0150			;FUNCTION AND SHIFT JUMP CONTROL  
0150			;BITS 2 AND 3 OF THE MONITOR CONTROL BYTE (MCB) ARE THE FUNCTION IDENTIFIER BITS.  
0150			;IF BOTH ARE ZERO THEN EITHER FUNCTION 1 IS SELECTED OR NO FUNCTION IS SELECTED. BECAUSE  
0150			;THIS IS THE ALSO THE NO FUNCTION MODE ENABLED STATE, THE SHIFT KEY, WHICH DOES NOT AFFECT  
0150			;THE MONITOR CONTROL BYTE, WILL ALSO WILL INVOKE FUNCTION 1. (THEREFORE THIS ROUTINE DOES  
0150			;NOT NEED TO TEST FOR THE SHIFT KEY).  
0150			;IF BIT 2 IS HIGH THEN FUNCTION 2 IS SELECTED AND IF BIT 3 IS HIGH THEN FUNCTION 3 IS  
0150			;SELECTED.  
0150			;DURING THIS ROUTINE, HL IS LOADED TO THE BASE OF THE REQUIRED JUMP TABLE MINUS TWO BYTES  
0150			;(ONE ENTRY). THIS IS BECAUSE THE OFFSET PROVIDED FROM THE KEYBOARD HAS BEEN INCREMENTED  
0150			;BY ONE. THIS SAVES TESTING FOR ZERO INPUT WHICH WOULD NOT ALLOW THE TABLE ACCESSING TO  
0150			;WORK CORRECTLY. THE REQUIRED BASE IS FOUND BY EXAMINING THE STATE OF THE BITS 2 AND 3 OF  
0150			;THE MONITOR CONTROL BYTE (MCB) AND LOADING HI, ACCORDINGLY.  
0150			;AS EACH ENTRY IS TWO BYTES LONG, THE TABLE POINTER (THE VALUE INSIDE HL), IS INCREMENTED  
0150			;TWICE FOR EACH DECREMENT OF THE INPUT VALUE (FROM THE KEYBOARD). WHEN THE REQUIRED TABLE  
0150			;ENTRY IS FOUND, 17 IS PUT' INSIDE CEL (VIA_ DE) AND THE ROUTINE JUMPS TO PART OF THE "GO"  
0150			;KEY ROUTINE TO CREATE A RETURN ADDRESS ON THE STACK AND EXECUTE THE SELECTED ROUTINE.  
0150			  
0150 78			KEY_FUNC:   LD      A, B                                ;PUT MONITOR CONTROL BYTE IN A  
0151 e6 0c		            AND     0x0C                                ;MASK IT DOWN TO FUNCTION BITS  
0153 21 de 07		            LD      HL, L07E0 - 2                       ;JMON FUNCTION JUMP TABLE BASE -2  
0156 28 0a		            JR      Z, L0162                            ;JUMP IF FUNCTION 1 OR SHIFT  
0158 21 be 08		            LD      HL, USER_TBL                        ;LOAD HL WITH USER TABLE -2  
015b			                                                        ;*** Value is 08BE as User Table is at 08C0  
015b fe 04		            CP      0x04                                ;TEST FOR FUNCTION 2  
015d 28 03		            JR      Z, L0162                            ;JUMP IF FUNCTION 2 (USER FUNCTION)  
015f 21 1e 38		            LD      HL, JMON_JUMP                       ;OTHERWISE MUST BE FUNCTION 3  
0162 3a 20 08		L0162:      LD      A, (V_KEY)                          ;GET INPUT KEY FROM INPUT BUFFER  
0165 3c			            INC     A                                   ;ADD ONE IN CASE IT WAS ZERO  
0166 47			            LD      B, A                                ;PUT IN B TO USE AS A LOOP COUNTER  
0167 23			L0167:      INC     HL                                  ;LOOK THROUGH TABLE  
0168 23			            INC     HL                                  ;FOR RIGHT JUMP VECTOR  
0169 10 fc		            DJNZ    L0167  
016b 5e			            LD      E, (HL)                             ;PUT IT IN HL  
016c 23			            INC     HL                                  ;VIA DE  
016d 56			            LD      D, (HL)  
016e eb			            EX      DE, HL                              ;JUMP TO CREATE RETURN ADDRESS AND  
016f 18 8c		            JR      L00FD                               ;EXECUTE SELECTED ROUTINE  
0171			  
0171			;FUNCTION NUMBER ENCODER  
0171			;THIS SECTION ENCODES THE FUNCTION IDENTIFIER BITS (BITS 2 AND 3) IN THE MONITOR CONTROL  
0171			;BYTE (BITS 2 AND 3) THEN SETS THE FUNCTION ENABLE BIT (BIT 5).  
0171			;THE FUNCTION IDENTIFIER BITS ARE DERIVED FROM THE LEAST TWO SIGNIFICANT BITS OF THE INPUT  
0171			;CONTROL KEY (+, AND GO). THESE ARE SHIFTED LEFT TWICE TO ALIGN THEM TO THE FUNCTION  
0171			;SELECT BITS (BITS 2 AND 3) IN THE MCB. THE INPUT CONTROL KEY IS IN THE ACCUMULATOR ON  
0171			;ENTRY AND THE MONITOR CONTROL BYTE (MCB) IN B.  
0171			  
0171 e6 03		ENC_FUNC:   AND     0x03                                ;MASK DOWN CONTROL KEY  
0173 07			            RLCA                                        ;SHIFT IT LEFT TWICE TO ALIGN BITS 0  
0174 07			            RLCA                                        ;AND 1 TO FUNCTION IDENTITY BITS IN MCB  
0175 f6 20		            OR      0x20                                ;SET FUNCTION MODE ENABLED FLAG  
0177 4f			            LD      C, A                                ;SAVE IN C  
0178 78			            LD      A, B                                ;GET CURRENT MCB  
0179 e6 d3		            AND     0xD3                                ;CLEAR ANY PREVIOUS FUNCTION BITS  
017b b1			            OR      C                                   ;MERGE TOGETHER  
017c 32 2b 08		            LD      (V_MCB), A                          ;STORE MCB  
017f 18 cd		            JR      L014E                               ;JUMP VIA JUMPS TO UP-DATE DISPLAYS  
0181			  
0181			;THIS IS THE SCAN/KEY/LCD/PATCH ROUTINE. THIS ROUTINE LOOPS SCANNING THE LED DISPLAY AND  
0181			;SERVICING THE "DURING LOOP" USER PATCH UNTIL A KEY PRESS IS VALIDATED BY THE AUTO-KEY  
0181			;REPEAT SECTION. THE INPUT KEY IS RETURNED IN THE ACCUMULATOR AND IN THE INPUT BUFFER AT  
0181			;0820 WITH THE ZERO FLAG SET AND CARRY CLEARED.  
0181			;THREE PATCHES ARE SUPPORTED IN THIS ROUTINE. THEY ARE A PATCH BEFORE LOOP, A PATCH DURING  
0181			;THE LOOP AND A PATCH AFTER A VALID KEY PRESS.  
0181			;THE "PLANT" IS A VALUE INSERTED INTO THE INPUT BUFFER (0820) BY THE DURING LOOP PATCH.  
0181			;THE "PLANT" VALUE IS IDENTIFIED BY BIT 7 OF THE INPUT BUFFER BEING SET. BIT 7 IS RESET  
0181			;BEFORE RETURNING TO SERVICE THE PLANT.  
0181			;THIS ROUTINE USES A BYTE AT 082A, CALLED THE AUTO KEY STATUS BYTE AS A FLAG AND TIMER  
0181			;TO GENERATE THE AUTO REPEAT DELAY.  
0181			J_SCANKEY:  
0181 cd 48 08		            CALL    LCD_DISP                            ;CALL LCD ROUTINES  
0184 cd 4b 08		            CALL    PATCH_BEF                           ;CALL PRE-SCAN USER PATCH  
0187 cd 36 08		L0187:      CALL    LED_SCAN                            ;CALL SCAN  
018a cd 4e 08		            CALL    PATCH_DUR                           ;CALL USER "DURING LOOP" PATCH  
018d 21 20 08		            LD      HL, V_KEY                           ;TEST KEY INPUT BUFFER BIT 7 FOR A  
0190 cb 7e		            BIT     7, (HL)                             ;"PLANT" INSERTED BY USER DURING  
0192 cb be		            RES     7, (HL)                             ;PATCH: RESET BIT 7 RETURN TO  
0194 c0			            RET     NZ                                  ;SERVICE "PLANT" IF BIT 7 NOT ZERO  
0195 e7			            RST     20H                                 ;TEST FOR KEY PRESS VIA RST 20  
0196 21 2a 08		            LD      HL, V_KAUTO                         ;SET HL TO POINT TO AUTO KEY STATUS  
0199 38 04		            JR      C, L019F                            ;JUMP IF A KEY IS PRESSED  
019b 36 80		            LD      (HL), 0x80                          ;ELSE SET AUTO KEY STATUS TO  
019d 18 e8		            JR      L0187                               ;NO KEY STATE AND CONTINUE LOOP  
019f cd ca 06		L019F:      CALL    KEY_GET                             ;CALL UNIVERSAL KEY INPUTTER  
01a2 cb 7e		            BIT     7, (HL)                             ;TEST AUTO KEY STATUS FOR FIRST KEY  
01a4 20 10		            JR      NZ, L01B6                           ;JUMP IF SO TO SET LONG KEY DELAY  
01a6 35			            DEC     (HL)                                ;ELSE COUNT DOWN KEY DELAY  
01a7 20 de		            JR      NZ, L0187                           ;LOOP IF NOT READY FOR KEY REPEAT  
01a9 36 0c		            LD      (HL), 0x0C                          ;ELSE SET SHORT TIME DELAY BETWEEN  
01ab cd 51 08		L01AB:      CALL    PATCH_AFT                           ;KEYS: CALL USER "AFTER KEY" PATCH  
01ae cd 3f 08		            CALL    BEEP                                ;CALL KEY TONE  
01b1 af			            XOR     A                                   ;SET ZERO FLAG AND CLEAR CARRY  
01b2 3a 20 08		            LD      A, (V_KEY)                          ;PUT INPUT KEY IN A  
01b5 c9			            RET                                         ;AND RETURN FOR KEY SERVICE  
01b6 36 70		L01B6:      LD      (HL), 0x70                          ;SET KEY TIMER FOR LONG DELAY  
01b8 18 f1		            JR      L01AB                               ;JUMP TO SERVICE PATCH, TONE ETC.  
01ba			  
01ba			;THIS IS THE LED SCAN ROUTINE.  
01ba			J_LEDSCAN:  
01ba 06 20		            LD      B, 20H                              ;B IS THE SCAN BIT  
01bc 2a 2c 08		            LD      HL, (V_DISPLAY)                     ;GET ADDRESS OF DISPLAY BUFFER  
01bf 7e			L01BF:      LD      A, (HL)                             ;GET FIRST BYTE  
01c0 d3 02		            OUT     (DSEGMENT), A                       ;AND OUTPUT IT TO SEGMENTS  
01c2 78			            LD      A, B                                ;GET SCAN BIT  
01c3 d3 01		            OUT     (DSCAN), A                          ;OUTPUT IT TO COMMONS  
01c5 06 40		            LD      B, 40H                              ;CREATE SHORT  
01c7 10 fe		L01C7:      DJNZ    L01C7                               ;DELAY IN B  
01c9 23			            INC     HL                                  ;INCREASE HL TO NEXT DISPLAY BYTE  
01ca 47			            LD      B, A                                ;GET SCAN BIT BACK IN B  
01cb af			            XOR     A                                   ;CLEAR THE LAST PORT OUTPUTTED TO  
01cc d3 01		            OUT     (DSCAN), A                          ;TO PREVENT "GHOSTING"  
01ce cb 08		            RRC     B                                   ;SHIFT SCAN BIT ACROSS TO NEXT  
01d0 30 ed		            JR      NC, L01BF                           ;COMMON: WHEN SCAN BIT FALLS INTO  
01d2 d3 02		            OUT     (DSEGMENT), A                       ;CARRY SCAN IS TERMINATED: CLEAR  
01d4 c9			            RET                                         ;PORT 2 AND RETURN  
01d5			  
01d5			;THIS ROUTINE CONVERTS HL TO DISPLAY CODE AND STORE THE DISPLAY CODE IN A BUFFER POINTED  
01d5			;TO BY BC.  
01d5			J_HL2CODE:  
01d5 7c			            LD      A, H                                ;PUT H IN A  
01d6 cd 33 08		            CALL    A_2_DISP                            ;CONVERT A TO DISPLAY CODE  
01d9 7d			            LD      A, L                                ;NOW DO FOR L  
01da			  
01da			;THIS SECTION CONVERTS THE BYTE IN A TO TWO DISPLAY BYTES.  
01da			J_A2CODE:  
01da f5			            PUSH    AF                                  ;SAVE A  
01db 07			            RLCA                                        ;SHIFT MSN TO LSN PLACE  
01dc 07			            RLCA                                        ;FOR NIBBLE AT A TIME CONVERSION  
01dd 07			            RLCA  
01de 07			            RLCA  
01df cd e3 01		            CALL    L01E3                               ;CONVERT FIRST NIBBLE  
01e2 f1			            POP     AF                                  ;RECOVER A TO CONVERT SECOND NIBBLE  
01e3 e6 0f		L01E3:      AND     0x0F                                ;MASK OF HIGH NIBBLE  
01e5 11 d0 07		            LD      DE, SEG_TBL                         ;SET DE TO BASE OF CONVERSION  
01e8 83			            ADD     A, E                                ;TABLE: ADD A TO BASE  
01e9 5f			            LD      E, A                                ;UPDATE POINTER  
01ea 1a			            LD      A, (DE)                             ;GET DISPLAY CODE  
01eb 02			            LD      (BC), A                             ;STORE IN DISPLAY BUFFER  
01ec 03			            INC     BC                                  ;INCREMENT DISPLAY BUFFER POINTER  
01ed c9			            RET                                         ;NIBBLE CONVERSION DONE  
01ee			  
01ee			;SET DOTS  
01ee			;THIS ROUTINE SETS THE DOTS IN THE DISPLAY BUFFER. IF IN ADDRESS MODE THEN 4 DOTS ARE SET  
01ee			;IN THE ADDRESS DISPLAY BUFFER, IF IN A FUNCTION MODE, THEN ONE DOT IN THE ADDRESS DISPLAY  
01ee			;- RIGHT MOST FOR FUNCTION 1 SECOND RIGHT FOR FUNCTION 2 AND THIRD RIGHT FOR FUNCTION 3.  
01ee			;IF IN THE DATA MODE THEN 2 DOTS IN THE DATA DISPLAY BUFFER OR ONE DOT, ON THE RIGHTMOST  
01ee			;DISPLAY, IF TWO NIBBLES HAVE BEEN ENTERED AND IN THE AUTO-INCREMENT MODE.  
01ee			J_SETDOTS:  
01ee 06 02		            LD      B, 0x02                             ;SET B FOR 2 DOTS  
01f0 2a 2c 08		            LD      HL, (V_DISPLAY)                     ;PUT DISPLAY BUFFER IN HL  
01f3 3a 2b 08		            LD      A, (V_MCB)                          ;GET MONITOR CONTROL BYTE (MCB)  
01f6 cb 67		            BIT     4, A                                ;TEST FOR ADDRESS OR FUNCTION MODE  
01f8 28 1a		            JR      Z, L0214                            ;JUMP IF NOT TO DO DATA DOTS  
01fa cb 6f		            BIT     5, A                                ;TEST ONLY FOR FUNCTION MODE  
01fc 20 08		            JR      NZ, L0206                           ;JUMP IF FUNCTION MODE  
01fe 06 04		            LD      B, 4                                ;ADDRESS MODE SO SET B FOR 4 DOTS  
0200 cb e6		L0200:      SET     4, (HL)                             ;SET DOT IN DISPLAY BUFFER  
0202 23			            INC     HL                                  ;NEXT LOCATION  
0203 10 fb		            DJNZ    L0200                               ;DO 4 TIMES  
0205 c9			            RET                                         ;DONE  
0206			  
0206 05			L0206:      DEC     B                                   ;FUNCTION MODE: SET B FOR ONE DOT  
0207 cb 5f		            BIT     3, A                                ;TEST FOR FUNCTION 3  
0209 20 06		            JR      NZ, L0211                           ;JUMP IF FUNCTION 3 TO ADD HL+1  
020b cb 57		            BIT     2, A                                ;TEST FOR FUNCTION 2  
020d 20 01		            JR      NZ, L0210                           ;JUMP IF FUNCTION 2 TO ADD HL+2  
020f 23			L020F:      INC     HL                                  ;INCREMENT HL TO POINT TO THE  
0210 23			L0210:      INC     HL                                  ;REQUIRED DISPLAY BYTE  
0211 23			L0211:      INC     HL                                  ;  
0212 18 ec		            JR      L0200                               ;JUMP TO SET DOT  
0214 23			L0214:      INC     HL                                  ;DATA MODE: HL NOW POINTS TO SECOND  
0215 4f			            LD      C, A                                ;LEFT MOST DISPLAY BUFFER: SAVE MCB  
0216 3a 27 08		            LD      A, (V_AUTO)                         ;IN C: TEST AUTO INCREMENT ENABLE  
0219 b7			            OR      A                                   ;FLAG  
021a 20 f3		            JR      NZ, L020F                           ;JUMP IF NO AUTO INCREMENT TO SET BOTH  
021c cb 49		            BIT     1, C                                ;DATA DOTS: TEST BYTE COUNTER FOR 2  
021e 28 ef		            JR      Z, L020F                            ;NIBBLES: JUMP IF NOT TO SET BOTH DATA  
0220 23			            INC     HL                                  ;DOTS: ELSE SKIP DOT ON ONE DISPLAY  
0221 05			            DEC     B                                   ;AND DECREASE DOT COUNT FROM 2 TO 1  
0222 18 eb		            JR      L020F                               ;JUMP TO ADJUST HL AND SET DOTS  
0224			  
0224			;MASKABLE RESET TONE ROUTINE  
0224			;IF 0822 IS NOT ZERO THEN NO TONE  
0224			J_TONEX2:  
0224 cd 3f 08		            CALL    BEEP                                ;CALL TONE  
0227			  
0227			J_TONE:  
0227			;MASKABLE TONE ROUTINE  
0227 3a 22 08		            LD      A, (V_BEEP)                         ;TEST SOUND MASK  
022a b7			            OR      A                                   ;  
022b c0			            RET     NZ                                  ;NO TONE IF NOT ZERO  
022c 0e 40		            LD      C, 0x40                             ;LOAD C WITH PERIOD  
022e 2e 31		            LD      L, 0x31                             ;LOAD L WITH NUMBER OF CYCLES  
0230 af			            XOR     A                                   ;CLEAR A  
0231 d3 01		L0231:      OUT     (DSCAN), A                          ;OUT TO SPEAKER  
0233 41			            LD      B, C                                ;  
0234 10 fe		L0234:      DJNZ    L0234                               ;DELAY FOR PERIOD  
0236 ee 80		            XOR     0x80                                ;TOGGLE SPEAKER BIT  
0238 2d			            DEC     L                                   ;DECREMENT CYCLE COUNT  
0239 20 f6		            JR      NZ, L0231                           ;LOOP UNTIL ZERO  
023b c9			            RET                                         ;DONE  
023c			  
023c			;LCD ROUTINE  
023c			;IF 0821 IS NOT ZERO, THEN LCD HAS BEEN MASKED OFF BY EITHER THE USER OR THE LCD  
023c			;INTIALIZER/TESTER ROUTINE AND NO ACTION IS TAKEN ON THE LCD. THE RST 30 (F7) IS USED  
023c			;EXTENSIVELY TO TEST AND WAIT FOR THE LCD BUSY FLAG. THROUGHOUT THESE NOTES, THE INVISIBLE  
023c			;INTERNAL CURSOR ON THE LCD IS REFERRED TO AS THE CURSOR, WHILE THE ">" ON THE LCD IS  
023c			;REFERRED TO AS THE PROMPT.  
023c			J_LCD:  
023c 3a 21 08		            LD      A, (V_LCD)                          ;TEST LCD MASK  
023f b7			            OR      A  
0240 c0			            RET     NZ                                  ;NOT ZERO = LCD NOT REQUIRED OR FITTED  
0241 3e 80		            LD      A, 0x80                             ;SET LCD CURSOR TO HOME  
0243 d3 04		            OUT     (P_LCDINST), A  
0245 f7			            RST     30H                                 ;WAIT UNTIL LCD READY  
0246 cd 53 02		            CALL    LCD_LINE1                           ;CALL SET-UP AND OUTPUT FIRST LINE  
0249 3e c0		            LD      A, 0xC0                             ;SET CURSOR TO BOTTOM LINE  
024b d3 04		            OUT     (P_LCDINST), A  
024d f7			            RST     30H                                 ;WAIT  
024e cd 5a 02		            CALL    LCD_LINE2                           ;CALL ROUTINE TO OUTPUT BOTTOM LINE  
0251 18 33		            JR      LCD_PROMPT                          ;JUMP TO PROMPT ROUTINE  
0253			  
0253			;SET-UP  
0253			;MODIFY CURRENT EDIT LOCATION ADDRESS IN HL SO THAT IT POINTS TO A BYTE AT AN ADDRESS  
0253			;ENDING IN EITHER 0 OR 8.  
0253			  
0253 2a 2e 08		LCD_LINE1:  LD      HL, (V_CEL)                         ;GET CEL AND PUT LOW BYTE IN A  
0256 7d			            LD      A, L                                ;THEN MASK OFF THE 3 LOWEST BITS  
0257 e6 f8		            AND     0xF8                                ;AS THE ADDR OF THE FIRST BYTE ON  
0259 6f			            LD      L, A                                ;THE LCD WILL END WITH 0 OR 8  
025a			  
025a			;OUTPUT A LINE.  FIRST DISPLAY BASE ADDRESS THEN THE NEXT FOUR BYTES. EG:  
025a			;   0900>FF AA FF FF  
025a			;WHERE A RIGHT ARROW WILL BE PLACED ON THE CURRENT ADDRESS BYTE  
025a cd 6c 02		LCD_LINE2:  CALL    HL_2_LCD                            ;CALL "HI TO ASCII OUTPUT"  
025d 06 04		            LD      B, 04                               ;SET B FOR 4 BYTES ON A LINE  
025f 3e 20		L025F:      LD      A, 0x20                             ;LOAD A WITH ASCII SPACE  
0261 d3 84		            OUT     (P_LCDDATA), A                      ;CHARATER AND OUTPUT IT  
0263 f7			            RST     30H                                 ;WAIT  
0264 7e			            LD      A, (HL)                             ;GET BYTE TO DISPLAY  
0265 cd 71 02		            CALL    A_2_LCD                             ;CONVERT AND OUTPUT IT  
0268 23			            INC     HL                                  ;POINT TO NEXT BYTE  
0269 10 f4		            DJNZ    L025F                               ;DO FOR 4 BYTES  
026b c9			            RET                                         ;DONE  
026c			  
026c			;CONVERT HL TO ASCII (VIA CONVERT A) AND OUTPUT IT  
026c 7c			HL_2_LCD:   LD      A, H                                ;CONVERT AND  
026d cd 71 02		            CALL    A_2_LCD                             ;OUTPUT H  
0270 7d			            LD      A, L                                ;THEN L  
0271			  
0271			;CONVERT A TO ASCII AND OUTPUT IT  
0271 f5			A_2_LCD:    PUSH    AF                                  ;SAVE A FOR SECOND NIBBLE  
0272 0f			            RRCA                                        ;SHIFT HIGH NIBBLE ACROSS  
0273 0f			            RRCA                                        ;  
0274 0f			            RRCA                                        ;  
0275 0f			            RRCA                                        ;  
0276 cd 7a 02		            CALL    LCD_NIBBLE                          ;CALL NIBBLE CONVERTER  
0279 f1			            POP     AF                                  ;RECOVER LOW NIBBLE  
027a e6 0f		LCD_NIBBLE: AND     0x0F                                ;MASK OFF HIGH NIBBLE  
027c c6 90		            ADD     A, 0x90                             ;CONVERT TO  
027e 27			            DAA                                         ;ASCII  
027f ce 40		            ADC     A, 0x40                             ;USING THIS  
0281 27			            DAA                                         ;AMAZING ROUTINE  
0282 d3 84		LCD_OUT:    OUT     (P_LCDDATA), A                      ;OUTPUT IT  
0284 f7			            RST     30H                                 ;WAIT  
0285 c9			            RET                                         ;DONE  
0286			  
0286			;LCD PROMPT AND MODE WORD OUTPUT  
0286			;THE 3 LOWEST BITS OF THE CURRENT EDIT LOCATION (CEL) ARE USED AS A DISPLACEMENT WHICH IS  
0286			;ADDED TO A TABLE BASE. THE TABLE ENTRIES ARE THE LCD ADDRESSES OF THE PROMPT LOCATIONS.  
0286			;IF THE AUTO INCREMENT MODE IS ON AND 2 NIBBLES HAVE BEEN ENTERED, THE DISPLACEMENT IS  
0286			;INCREMENTED SO THAT THE NEXT PROMPT ADDRESS TABLE ENTRY WILL BE ACCESSED TO MOVE THE  
0286			;PROMPT TO ITS NEXT SCREEN LOCATION. THE TABLE IS 9 ENTRIES LONG. 8 ARE FOR THE SPACES  
0286			;BETWEEN THE DATA BYTES AND THE NINTH IS TO PARK THE PROMPT AT THE TOP LEFT-HAND CORNER  
0286			;WHEN A SCREEN CHANGE IS DUE  
0286			  
0286 3a 2e 08		LCD_PROMPT: LD      A, (V_CEL)                          ;GET LOW BYTE OF CEL  
0289 e6 07		            AND     0x07                                ;MASK IT DOWN TO THE 3 LOWEST BITS  
028b 4f			            LD      C, A                                ;SAVE IN C  
028c 3a 27 08		            LD      A, (V_AUTO)                         ;TEST FOR AUTO INCREMENT MODE  
028f b7			            OR      A                                   ;O=ON  
0290 3a 2b 08		            LD      A, (V_MCB)                          ;GET MCB  
0293 57			            LD      D, A                                ;PUT MCB IN D  
0294 20 05		            JR      NZ, L029B                           ;JUMP IF AUTO INCREMENT MODE OFF  
0296 cb 4f		            BIT     1, A                                ;TEST FOR 2 NIBBLES ENTERED: JUMP  
0298 28 01		            JR      Z, L029B                            ;IF NOT: ELSE INCREMENT  
029a 0c			            INC     C                                   ;DISPLACEMENT TO ADVANCE TO  
029b 79			L029B:      LD      A, C                                ;NEXT PROMPT LOCATION ADDRESS  
029c 21 bd 07		            LD      HL, LCDPMT_TBL                      ;LOAD HL WITH BASE OF PROMPT  
029f 85			            ADD     A, L                                ;TABLE AND ADD DISPLACEMENT  
02a0 6f			            LD      L, A                                ;PUT LOW BYTE OF TABLE ADDRESS  
02a1 7e			            LD      A, (HL)                             ;IN L AND GET PROMPT ADDRESS IN A  
02a2 d3 04		            OUT     (P_LCDINST), A                      ;AND OUTPUT PROMPT ADDRESS TO LCD  
02a4 f7			            RST     30H                                 ;WAIT  
02a5 3e 3e		            LD      A, 0x3E                             ;LOAD A WITH ASCII FOR ">"  
02a7 d3 84		            OUT     (P_LCDDATA), A                      ;OUTPUT PROMPT  
02a9 f7			            RST     30H                                 ;WAIT  
02aa			  
02aa			;OUTPUT MODE WORD TO BOTTOM LEFT CORNER OF THE LCD.  
02aa			;IF THE MODE IS EITHER DATA OR ADDR, THEN THE FOUR ASCII BYTES ARE OUTPUTTED. IF IN THE  
02aa			;FUNCTION MODE, THEN ONLY THREE BYTES FROM THE TABLE ARE OUTPUTTED AND THEN THE FUNCTION  
02aa			;NUMBER IS CALCULATED AND OUTPUTTED.  
02aa			;NOTICE THAT FROM THE TABLE BASE THE FIRST ENTRY (DATA) HAS A ZERO DISPLACEMENT WHILE THE  
02aa			;SECOND (ADDR) HAS A DISPLACEMENT OF 4 AND THE THIRD (Fs-) HAS A DISPLACEMENT OF 12.  
02aa			;IF YOU LOOK AT THE TABLE AT 07AD, YOU WILL SEE THAT IT IS STAGGERED WITH THE THIRD ENTRY  
02aa			;12 BYTES AWAY FROM THE BASE.  
02aa			  
02aa 3e c0		            LD      A, 0xC0                             ;SET CURSOR TO BOTTOM LINE  
02ac d3 04		            OUT     (P_LCDINST), A                      ;OUTPUT  
02ae f7			            RST     30H                                 ;AND WAIT  
02af 7a			            LD      A, D                                ;PUT MONITOR CONTROL BYTE (MCB) IN A  
02b0 0f			            RRCA                                        ;SHIFT MODE BITS TO BITS 2 AND 3  
02b1 0f			            RRCA                                        ;TO USE AS TABLE DISPLACEMENT  
02b2 57			            LD      D, A                                ;SAVE IN D AND MASK OFF ALL BITS  
02b3 e6 0c		            AND     0x0C                                ;EXCEPT THE 2 THAT FLAG BETWEEN DATA,  
02b5 21 ad 07		            LD      HL, LCDFNC_TBL                      ;ADDR AND FUNCTION: A=0 IF DATA, 4 IF  
02b8 85			            ADD     A, L                                ;ADDR, 12 IF FUNCTION, NOTE THAT TABLE  
02b9 6f			            LD      L, A                                ;IS STAGGERED (SEE 07AD): ADD A TO BASE  
02ba fe b9		            CP      0xB9                                ;IF A=B9 THEN MODE IS FUNCTION MODE  
02bc 01 84 04		            LD      BC, 0484H                           ;LOAD C WITH PORT, B WITH BYTE COUNT  
02bf 28 06		            JR      Z, L02C7                            ;JUMP IF FUNCTION MDDE TO OUT 3 BYTES  
02c1 ed a3		L02C1:      OUTI                                        ;OUT (HL) TO (C) B=B-1  
02c3 f7			            RST     30H                                 ;HL=HL+1: WAIT FOR LCD BUSY FLAG  
02c4 20 fb		            JR      NZ, L02C1                           ;LOOP UNTIL B=0  
02c6 c9			            RET                                         ;DONE  
02c7			  
02c7 06 03		L02C7:      LD      B, 0x03                             ;ONLY THREE BYTES FOR FUNCTION MODE  
02c9 cd c1 02		            CALL    L02C1                               ;CALL THE OUTPUT ROUTINE ABOVE  
02cc 7a			            LD      A, D                                ;PUT MCB (SHIFTED RIGHT TWICE) IN A  
02cd e6 03		            AND     0x03                                ;MASK IT DOWN TO GET JUST THE FUNCTION  
02cf c6 31		            ADD     A, 0x31                             ;NUMBER BITS: ADD ASCII "1"  
02d1 18 af		            JR      LCD_OUT                             ;JUMP TO OUTPUT FUNCTION NUMBER  
02d3			  
02d3			;-END OF MONITOR ROUTINES- (EXCEPT KEYBOARD READER AT 06AD)  
02d3			  
02d3			;LCD PROMPT MOVING ROUTINES. (SHIFT AND FUNCTION 1)  
02d3			;THESE ROUTINES ALTER THE CURRENT EDIT LOCATION ADDRESS AND STORE IT IN ITS BUFFER. WHEN  
02d3			;THE RETURN IS DONE, JMON IS RE-ENTERED AT 00132 (VIA THE SOFT RE-ENTRY JUMP AT L0845, THE  
02d3			;ADDRESS OF WHICH HAS BEEN PLACED ON THE STACK BY PART OF THE "GO" ROUTINE).  
02d3 11 04 00		FN_FORW4:   LD      DE, 0x0004                          ;DE= +4  
02d6 2a 2e 08		L02D6:      LD      HL, (V_CEL)                         ;PUT CEL IN HL  
02d9 19			            ADD     HL, DE                              ;ADD TO GET NEW CEL  
02da 22 2e 08		            LD      (V_CEL), HL                         ;STORE IN CEL BUFFER  
02dd c9			            RET                                         ;DONE  
02de			  
02de 11 fc ff		FN_BACK4:   LD      DE, 0xFFFC                          ;DE= -4  
02e1 18 f3		            JR      L02D6                               ;JUMP TO ADD  
02e3 11 ff ff		FN_BACK1:   LD      DE, 0xFFFF                          ;DE= -1  
02e6 18 ee		            JR      L02D6                               ;JUMP TO ADD  
02e8 11 01 00		FN_FORW1:   LD      DE, 0x0001                          ;DE= +1  
02eb 18 e9		            JR      L02D6                               ;JUMP TO ADD  
02ed 11 08 00		FN_FORW8:   LD      DE, 0x0008                          ;DE= +8  
02f0 18 e4		            JR      L02D6                               ;JUMP TO ADD  
02f2 11 f8 ff		FN_BACK8:   LD      DE, 0xFFF8                          ;DE= -8  
02f5 18 df		            JR      L02D6                               ;JUMP TO ADD  
02f7			  
02f7			;RESET PATCH CHECKER.  
02f7			;TESTS FOR PATCH REQUIREMENT AND UP TO THE FIRST 256 BYTES OF THE PATCH ROUTINE. THE  
02f7			;CHECKSUM FEATURE ENSURES A WAY TO CHECK THAT THE PATCH OR PATCH VARIABLES HAVE NOT BEEN  
02f7			;CORRUPTED BY A SYSTEM CRASH, OTHERWISE YOU MAY NEVER REGAIN CONTROL OF THE COMPUTER UNLESS  
02f7			;YOU TURN IT OFF, (AND LOSE THE CONTENTS OF YOUR MEMORY - YOU CANNOT RECOVER IT BY A FORCED  
02f7			;HARD RESET AS THE USER PATCH IS EXECUTED BEFORE THE FORCED HARD RESET TEST). (A FORCED  
02f7			;HARD RESET IS WHEN A KEY IS HELD DOWN WHEN THE RESET KEY IS RELEASED).  
02f7			;IF YOU HAVE A NON VOLATILE MEMORY AT 2000 THE SITUATION WOULD BE ABSOLUTELY HOPELESS  
02f7			;WITHOUT THIS CHECKER ROUTINE.  
02f7			;A VARIABLE CAN BE PASSED TO YOUR PATCH ROUTINE IN THE "C" REGISTER. TO DO THIS THE VARIABLE  
02f7			;IS PLACED AT ADDRESS LOCATION 08B3.  
02f7			  
02f7 3a b0 08		RST_PATCH:  LD      A, (PATCH_REQ)                      ;TEST FOR RESET PATCH REQUIRED  
02fa fe aa		            CP      0xAA  
02fc c0			            RET     NZ                                  ;RETURN IF NOT  
02fd ed 4b b3 08	            LD      BC, (PATCH_VAR)                     ;PUT NO OF BYTES IN B VARIABLE IN C  
0301 2a b1 08		            LD      HL, (PATCH_STA)                     ;START IN HL  
0304 af			            XOR     A                                   ;CLEAR A  
0305 86			L0305:      ADD     A, (HL)                             ;ADD CHECKSUM  
0306 23			            INC     HL  
0307 10 fc		            DJNZ    L0305                               ;UNTIL B=0  
0309 21 b5 08		            LD      HL, PATCH_CHK                       ;POINT TO REQUIRED CHECKSUM  
030c be			            CP      (HL)                                ;TEST FOR EQUAL  
030d c0			            RET     NZ                                  ;ABORT IF NOT  
030e 2a b6 08		            LD      HL, (PATCH_ADR)                     ;ELSE GET START ADDR  
0311 e9			            JP      (HL)                                ;AND DO RESET PATCH  
0312			  
0312			;STEPPER ROUTINE  
0312			;THE STEPPER ROUTINE IS BROKEN UP INTO SEVERAL SECTIONS. THE FIRST IS THE REGISTER SAVE,  
0312			;WHERE ALL THE Z80 USER REGISTERS ARE STORED IN MEMORY.  
0312			  
0312 22 70 08		STEPPER:    LD      (STEP_HL), HL                       ;STORE HL IN ITS REGISTER STACK SPOT  
0315 21 44 03		            LD      HL, STEP_CONT                       ;LOAD HL WITH RETURN ADDRESS - Was 0x0344  
0318			  
0318			;MONITOR JUMPS TO HERE ON RESET TO PRESERVE USER REGISTERS.  
0318 22 60 08		SAVE_REGS:  LD      (RE_ENTRY), HL                      ;STORE RE-ENTRY ADDRESS IN BUFFER  
031b 2a 58 08		            LD      HL, (STEP_NEXT)                     ;GET ADDRESS OF INSTRUCTION JUST  
031e 22 68 08		            LD      (STEP_PREV), HL                     ;STEPPED AND PUT IT IN "NEXT PC"  
0321 ed 73 7e 08	            LD      (STEP_SP), SP                       ;BUFFER: SAVE STACK POINTER VALUE  
0325 e1			            POP     HL                                  ;GET RETURN ADDR, THIS IS THE ADDRESS  
0326 22 58 08		            LD      (STEP_NEXT), HL                     ;OF NEXT BYTE TO STEP: STORE IN  
0329 31 7e 08		            LD      SP, STEP_SP                         ;"NEXT PC" BUFFER: LOAD REGISTER DUMP  
032c 08			            EX      AF, AF'                             ;STACK: PUSH ALTERNATE REGISTERS  
032d d9			            EXX                                         ;FIRST  
032e e5			            PUSH    HL                                  ;SAVE ALL REGISTERS  
032f d5			            PUSH    DE  
0330 c5			            PUSH    BC  
0331 f5			            PUSH    AF  
0332 fd e5		            PUSH    IY  
0334 dd e5		            PUSH    IX  
0336 08			            EX      AF, AF'  
0337 d9			            EXX  
0338 3b			            DEC     SP  
0339 3b			            DEC     SP  
033a d5			            PUSH    DE  
033b c5			            PUSH    BC  
033c f5			            PUSH    AF  
033d 2a 60 08		            LD      HL, (RE_ENTRY)                      ;RE-ENTER CALLING ROUTINE VIA  
0340 e9			            JP      (HL)                                ;THE ADDRESS IT SUPPLIED AT 0860  
0341			FN_REGDIS:  
0341 31 6a 08		            LD      SP, STEP_REGS                       ;SHIFT 7 ROUTINE START (REG DISPLAY)  
0344			  
0344			;THE REGISTERS HAVE BEEN SAVED. NOW THE DISPLAY AND KEYBOARD HANDLER IS SET UP. THE STACK  
0344			;IS DECREMENTED BY TWO TO POINT TO THE "PC" BUFFER. THE ADDRESS IN THE "PC" BUFFER IS THE  
0344			;ADDRESS OF THE INSTRUCTION JUST STEPPED.  
0344			;THE NUMBER OF THE FIRST REGISTER (1 FOR "PC") IS PUT INTO THE CURRENT REGISTER NUMBER  
0344			;BUFFER.  
0344			  
0344 21 06 08		STEP_CONT:  LD      HL, DISP_STEP                       ;CREATE NEW DISPLAY BUFFER  
0347 22 2c 08		            LD      (V_DISPLAY), HL                     ;  
034a 3b			            DEC     SP                                  ;DECREASE SP BY 2 TO POINT TO THE  
034b 3b			            DEC     SP                                  ;"PC" BUFFER  
034c			  
034c			;WHEN UP-DATING THE DISPLAY, THE ROUTINE MAY JUMP BACK TO HERE IF THE FIRST DISPLAY IS REQUIRED.  
034c 3e 01		L034C:      LD      A, 0x01                             ;SET UP FOR THE FIRST REGISTER (PC)  
034e 32 5a 08		            LD      (STEP_CREG), A                      ;DISPLAY  
0351			  
0351			;OR HERE IF IT HAS ALTERED THE CURRENT REGISTER NUMBER IN ITS STORAGE LOCATION (085A).  
0351 3a 5a 08		L0351:      LD      A, (STEP_CREG)                      ;DISPLAY LOOP STARTS HERE  
0354			  
0354			;HL IS LOADED WITH THE STACK POINTER VALUE, (WHICH POINTS TO THE "PC" BUFFER), MINUS TWO.  
0354			;THE TWO IS SUBTRACTED BECAUSE AN EXTRA TWO WILL BE ADDED TO HL DURING THE REGISTER BUFFER  
0354			;CALCULATOR (IMMEDIATELY BELOW) AS THE NUMBER OF THE FIRST REGISTER IS 1 AND NOT ZERO.  
0354 21 fe ff		            LD      HL, 0xFFFE                          ;HL=-2  
0357 39			            ADD     HL, SP                              ;HL=SP-2  
0358 23			L0358:      INC     HL                                  ;INCREMENT HL TO POINT TO THE  
0359 23			            INC     HL                                  ;CURRENT REGISTER BUFFER  
035a 3d			            DEC     A                                   ;INDICATED BY THE NUMBER IN A  
035b 20 fb		            JR      NZ, L0358  
035d			  
035d			;HL NOW POINTS TO THE CURRENT REGISTER BUFFER. THIS SECTION PUTS THE REGISTER(S) CONTENT(S)  
035d			;INTO HL AND CONVERTS IT TO DISPLAY CODE AND STORE THE DISPLAY CODE IN THE DISPLAY BUFFER.  
035d			  
035d 7e			            LD      A, (HL)                             ;GET 16 BIT VALUE  
035e 23			            INC     HL                                  ;AND PUT IT  
035f 66			            LD      H, (HL)                             ;BACK INTO  
0360 6f			            LD      L, A                                ;HL  
0361 ed 4b 2c 08	            LD      BC, (V_DISPLAY)                     ;PUT DISPLAY BUFFER ADDRESS IN BC  
0365 cd 30 08		            CALL    HL_2_DIS                            ;CALL HL TO DISPLAY CODE ROUTINE  
0368			  
0368			;THIS SECTION CALCULATES THE ADDRESS OF THE REGISTER NAME FOR THE DATA DISPLAYS. THESE  
0368			;ARE STORED IN A TABLE. THE REQUIRED REGISTER NAME IS THEN TRANSFERRED TO THE DISPLAY  
0368			;BUFFER.  
0368			  
0368 3a 5a 08		            LD      A, (STEP_CREG)                      ;GET REGISTER NUMBER  
036b c5			            PUSH    BC                                  ;PUT NEXT DISPLAY BUFFER  
036c d1			            POP     DE                                  ;LOCATION INTO DE(stination)  
036d 01 02 00		            LD      BC, 0x0002                          ;BC IS THE NUMBER OF DATA DISPLAYS  
0370 21 92 07		            LD      HL, REG_TBL                         ;HL=THE BASE OF THE NAME TABLE (MINUS 2)  
0373 09			L0373:      ADD     HL, BC                              ;ADD TO HL 2 FOR EACH  
0374 3d			            DEC     A                                   ;REGISTER NUMBER TO ACCESS THE  
0375 20 fc		            JR      NZ, L0373                           ;CURRENT REGISTER NAME  
0377 ed b0		            LDIR                                        ;MOVE REGISTER NAME INTO RAM  
0379			  
0379			;THE SCAN AND KEYBOARD ROUTINE ARE NOW CALLED (VIA THE RST 18). IF A VALID KEY IS PRESSED,  
0379			;THEN THE ZERO FLAG IS SET WHEN THE RST RETURNS.  
0379			  
0379 df			STEP_DISP:  RST     18H                                 ;SCAN/KEY READ RST  
037a 21 24 08		            LD      HL, V_STEP_TMR                      ;(HL)=AUTO STEP CONTROL/TIMER BYTE  
037d 28 0b		            JR      Z, STEP_KEY                         ;JUMP IF VALID KEY PRESSED  
037f			  
037f			;NO KEY IS PRESSED SO THE ROUTINE CHECKS FOR THE AUTO REPEAT MODE ENABLED FLAG (BIT 7 AUTO  
037f			;STEP CONTROL/TIMER BYTE, ZERO IS AUTO STEP ENABLED) AND DECREMENTS THE COUNTER IF IT IS.  
037f			;IF THE COUNTER REACHES ZERO, THEN IT IS RELOADED AND THE ROUTINE JUMPS TO RECOVER THE  
037f			;REGISTERS AND STEP THE NEXT INSTRUCTION. IF NOT IN THE AUTO MODE OR THE COUNTER DOES NOT  
037f			;REACH ZERO, THEN THE ROUTINE LOOPS BACK TO SCAN THE DISPLAY AND WAIT FOR EITHER A KEY  
037f			;PRESS OR FOR THE COUNTER TO REACH ZERO.  
037f			  
037f cb 7e		            BIT     7, (HL)                             ;TEST FOR AUTO INCREMENT JUMP IF NOT  
0381 20 f6		            JR      NZ, STEP_DISP                       ;ENABLED TO SCAN/KEY READ LOOP  
0383 35			            DEC     (HL)                                ;DECREMENT COUNTER: LOOP TO  
0384 20 f3		            JR      NZ, STEP_DISP                       ;SCAN/KEY READ UNTIL COUNT=0  
0386			  
0386			;AT THIS POINT THE AUTO-STEP DELAY HAS REACHED ZERO AND IS RELOADED WITH THE DELAY VALUE.  
0386			;A JUMP IS THEN DONE TO RECOVER THE REGISTERS AND STEP THE NEXT INSTRUCTION.  
0386 36 30		            LD      (HL), 0x30                          ;RESET AUTO STEP DELAY, JUMP TO RECOVER  
0388 18 22		            JR      STEP_DO_GO                          ;REGISTERS AND STEP NEXT INSTRUCTION  
038a			  
038a			;KEY PROCESSING STARTS HERE  
038a			;THE AUTO-STEP IS DISABLED AND THEN THE KEY IS IDENTIFIED AND HANDLED.  
038a			;THE AUTO-STEP WILL BE RE-ENABLED IF THE KEY PRESSED IS A DATA KEY.  
038a			  
038a 47			STEP_KEY:   LD      B, A                                ;SAVE KEY  
038b 36 ff		            LD      (HL), 0xFF                          ;SET AUTO STEP CONTROL/TIMER BIT 7  
038d 21 5a 08		            LD      HL, STEP_CREG                       ;THUS DISABLING THE AUTO REPEAT MODE  
0390 78			            LD      A, B                                ;POINT HI, TO CURRENT REG No. BUFFER  
0391 fe 10		STEP_PLUS:  CP      K_PLUS                              ;PUT INPUT IN A,TEST IT FOR "+"  
0393 20 08		            JR      NZ, STEP_MINUS                      ;JUMP IF NOT TO TEST FOR "-"  
0395			  
0395			;"+" KEY HANDLER  
0395			;THE CURRENT REGISTER NUMBER IS INCREMENTED AND THEN CHECK TO SEE THAT IT HAS NOT EXCEEDED  
0395			;THE HIGHEST REGISTER NUMBER (OC). IF IT HAS, THE ROUTINE JUMPS TO RESET THE CURRENT  
0395			;REGISTER NUMBER WITH 1, OTHERWISE IT JUMPS TO THE DISPLAY LOOP.  
0395			  
0395 34			            INC     (HL)                                ;INCREMENT REGISTER NUMBER  
0396 7e			            LD      A, (HL)                             ;AND CHECK TO SEE IF IT LARGER  
0397 fe 0d		            CP      0x0D                                ;THAN HIGHEST REG No. (0C): IF LOWER  
0399 38 b6		            JR      C, L0351                            ;THAN OD JUMP TO DISPLAY LOOP ELSE  
039b 18 af		            JR      L034C                               ;JUMP TO SET REGISTER NUMBER TO 1  
039d			  
039d fe 11		STEP_MINUS: CP      K_MINUS                             ;TEST FOR "-"  
039f 20 07		            JR      NZ, STEP_GO                         ;JUMP IF NOT  
03a1			  
03a1			;"-" HANDLER  
03a1			;ONE IS TAKEN FROM THE CURRENT REGISTER NUMBER AND THEN IT IS CHECKED FOR ZERO. IF IT  
03a1			;BECOMES ZERO, THEN THE CURRENT REGISTER NUMBER IS SET TO THE HIGHEST REGISTER NUMBER (OC)  
03a1			;TO WRAP-AROUND TO DISPLAY THE LAST REGISTER.  
03a1 35			            DEC     (HL)                                ;SUBTRACT 1 FROM REGISTER NUMBER  
03a2 20 ad		            JR      NZ, L0351                           ;JUMP IF NOT 0 TO UP-DATE DISPLAY  
03a4 36 0c		            LD      (HL), 0x0C                          ;ELSE SET TO LAST REGISTER  
03a6 18 a9		            JR      L0351                               ;AND UP-DATE  
03a8			  
03a8			;TEST FOR "GO"  
03a8 fe 12		STEP_GO:    CP      K_GO                                ;TEST FOR "GO" AND JUMP IF NOT  
03aa 20 1a		            JR      NZ, STEP_AD                         ;TO TEST FOR "AD" OR DATA KEY  
03ac			  
03ac			;"GO" KEY  
03ac			;THE GO KEY CAUSES STEPPING EXECUTION TO CONTINUE.  
03ac			;BEFORE STEPPING IS CONTINUED THOUGH, THE KEYBOARD IS READ AND THE PROGRAM LOOPS UNTIL  
03ac			;ALL KEYS ARE RELEASED. THIS IS TO SEPARATE KEY PRESSES MEANT FOR THE STEPPER AND THOSE  
03ac			;FOR THE ROUTINE BEING STEPPED. ONCE ALL KEYS ARE RELEASED, ALL THE REGISTERS ARE POPPED  
03ac			;OF THE REGISTER DISPLAY STACK, THE STACK IS RESTORED TO ITS "REAL" POSITION AND THE  
03ac			;INTERRUPTS RE-ENABLED. THE RETURN ADDRESS FOR THE ROUTINE BEING STEPPED, STILL THERE ON  
03ac			;THE TOP OF THE REAL STACK, IS USED AS THE RETURN ADDRESS.  
03ac			  
03ac e7			STEP_DO_GO: RST     20H                                 ;WAIT UNTIL ALL KEYS ARE RELEASED  
03ad 28 fd		            JR      Z, STEP_DO_GO                       ;BEFORE RESTARTING  
03af e1			            POP     HL                                  ;RECOVER ALL  
03b0 f1			            POP     AF                                  ;REGISTERS  
03b1 c1			            POP     BC                                  ;IN  
03b2 d1			            POP     DE                                  ;THE  
03b3 e1			            POP     HL                                  ;REVERSE  
03b4 dd e1		            POP     IX                                  ;ORDER  
03b6 fd e1		            POP     IY                                  ;TO  
03b8 08			            EX      AF, AF'                             ;HOW  
03b9 d9			            EXX                                         ;THEY  
03ba f1			            POP     AF                                  ;STORED  
03bb c1			            POP     BC  
03bc d1			            POP     DE  
03bd e1			            POP     HL  
03be 08			            EX      AF, AF'  
03bf d9			            EXX  
03c0 ed 7b 7e 08	            LD      SP, (STEP_SP)                       ;AND STACK POINTER  
03c4 fb			            EI                                          ;RE-ENABLE THE INTERRUPTS  
03c5 c9			            RET                                         ;RET TO STEP NEXT INSTRUCTION  
03c6			  
03c6			;TEST FOR "AD" KEY (RETURN TO JMON)  
03c6 fe 13		STEP_AD:    CP      K_ADDR                              ;TEST FOR "ADDR" KEY  
03c8 20 01		            JR      NZ, STEP_DATA                       ;JUMP IF NOT TO ASSUME DATA KEY  
03ca c7			            RST     00H                                 ;RETURN TO MONITOR  
03cb			  
03cb			;DATA KEY HANDLER (ENABLE AUTO STEP)  
03cb 3e 20		STEP_DATA:  LD      A, 0x20                             ;SET AND ENABLE AUTO STEP IN THE  
03cd 32 24 08		            LD      (V_STEP_TMR), A                     ;CONTROL/TIMER BYTE (BIT 7 LOW, 20  
03d0 18 a7		            JR      STEP_DISP                           ;CYCLES): JUMP TO DISPLAY LOOP  
03d2			;-END OF STEPPER-  
03d2			  
03d2			;START OF MENU  
03d2			;MAIN MENU IS SET-UP HERE  
03d2			;THE VARIABLES ARE MOVED FROM ROM TO RAM AND THE DISPLAY BUFFER IS SET TO 0800.  
03d2			  
03d2			;THE MENU CAN BE USED ANYWHERE PROVIDED THAT MENU VARIABLES ARE SET UP AT 0x880  
03d2			FN_MENU:  
03d2 21 7c 07		            LD      HL, SIO_P_DRIVER                    ;LOAD HL WITH START OF MAIN MENU + SIO PERM  
03d5 11 80 08		            LD      DE, PERI_SETUP                      ;VARIABLES: DE IS RAM DE(stination)  
03d8 01 18 00		            LD      BC, 0018H                           ;BC IS THE COUNT  
03db ed b0		            LDIR                                        ;SHIFT VARIABLES  
03dd			  
03dd 21 00 08		MENU_RTN:   LD      HL, DISP_BUFF                       ;PUT DISPLAY BUFFER AT 0800  
03e0 22 2c 08		            LD      (V_DISPLAY), HL  
03e3			  
03e3			;MENU DISPLAY LOOP STARTS HERE  
03e3			;THE MENU ENTRY NUMBER (MEN), HOLDS THE NUMBER OF THE CURRENT MENU ENTRY ON THE DISPLAY.  
03e3			;ALL ACTIONS OF THE MENU DRIVER CENTRE AROUND THIS BYTE.  
03e3			;THE DISPLAY ON THE TEC LED DISPLAY IS GENERATED BY SHIFTING BOTH THE DATA AND ADDRESS  
03e3			;DISPLAY CODES INTO THE RAM DISPLAY BUFFER.  
03e3			;ALL THE POSSIBLE DATA AND ADDRESS DISPLAY CODES ARE STORED IN SEPARATE TABLES IN ROM,  
03e3			;THE BASE OF EACH IS ADDRESSED BY THE CONTENTS OF MEMORY LOCATIONS 0895 (DATA TABLE), AND  
03e3			;0893 (ADDRESS TABLE).  
03e3			;THE FIRST MENU ENTRY IS DENOTED BY A ZERO VALUE IN THE MENU ENTRY NUMBER (MEN). THIS  
03e3			;MEANS THAT THE POSSIBLE ZERO CONDITION MUST BY DETECTED AND THE TABLE ENTRY CALCULATOR  
03e3			;SECTION SKIPPED OVER. WHEN ACCESSING THE DISPLAY TABLES, THE MENU ENTRY NUMBER IS  
03e3			;DECREMENTED UNTIL ZERO AND EACH TIME AN OFFSET EQUAL TO THE LENGTH OF EACH TABLE ENTRY  
03e3			;(4 FOR ADDR AND 2 FOR DATA TABLES) IS ADDED TO THE POINTERS.  
03e3			;AFTER THE REQUIRED ENTRIES ARE FOUND, THEY ARE MOVED INTO THE RAM DISPLAY BUFFER.  
03e3			  
03e3 3a 8f 08		MENU_DISP:  LD      A, (MENU_NO)                        ;GET MENU ENTRY NUMBER (MEN)  
03e6 ed 5b 95 08	MENU_RTNT:  LD      DE, (MENU_D_TBL)                    ;DE POINTS TO DATA DISPLAY TABLE  
03ea 2a 93 08		            LD      HL, (MENU_A_TBL)                    ;HL POINTS TO ADDR DISPLAY TABLE  
03ed 01 04 00		MENU_SFT:   LD      BC, 0004H                           ;BC IS BOTH AN INDEX OFFSET AND  
03f0 b7			            OR      A                                   ;BYTE COUNTER (USED BELOW): TEST  
03f1 28 06		            JR      Z, L03F9                            ;A AND SKIP CALCULATOR IF ZERO  
03f3 09			L03F3:      ADD     HL, BC                              ;ADD 4 TO HL TO POINT TO NEXT ADDR  
03f4 13			            INC     DE                                  ;DISPLAY AND 2 TO DE FOR NEXT DATA  
03f5 13			            INC     DE                                  ;DISPLAY  
03f6 3d			            DEC     A                                   ;DO UNTIL A=0  
03f7 20 fa		            JR      NZ, L03F3  
03f9 e5			L03F9:      PUSH    HL                                  ;SAVE ADDR POINTER (not required)  
03fa d5			            PUSH    DE                                  ;AND DATA POINTER  
03fb 11 00 08		            LD      DE, DISP_BUFF                       ;SHIFT ACROSS ADDR DISPLAY  
03fe ed b0		            LDIR                                        ;TO 0800 (BC-0004 FROM ABOVE)  
0400 e1			            POP     HL                                  ;POP (DE) DATA DISPLAY ADDR INTO HL  
0401 0e 02		            LD      C, 0x02                             ;SET PC TO SHIFT DATA DISPLAY BYTES  
0403 ed b0		            LDIR                                        ;SHIFT THE BYTES TO DISPLAY RAM  
0405 e1			            POP     HL                                  ;CLEAN UP STACK  
0406			  
0406			;THIS SECTION CALLS THE SCAN/KEY/LCD/PATCH ROUTINE.  
0406			;WHEN A KEY IS DETECTED A KEY HANDLER ROUTINE IS CALLED. THIS KEY HANDLER IS COMMON TO  
0406			;BOTH THE MENU DRIVER AND THE PERIMETER HANDLER AND IS DOCUMENTED ON FURTHER.  
0406			;IF THE "GO" KEY WAS PRESSED, THE ZERO FLAG WILL BE SET WHEN THE COMMON KEY HANDLER RETURNS  
0406			;AND THE ROUTINE JUMPS TO THE GO HANDLER. IF NOT, THEN A (UNUSED BY JMON) ROUTINE (AT  
0406			;0897) IS CALLED AND FINDS AN IMMEDIATE RETURN.  
0406			;THE RETURN INSTRUCTION WAS PLACED AT 0897 WHEN THE SIO'S MENU VARIABLES WERE SHIFTED  
0406			;FROM ROM TO RAM (SEE 0793).  
0406			;A JUMP THEN LOOPS BACK TO THE MAIN DISPLAY LOOP TO UP-DATE THE DISPLAYS IN CASE OF A NEW  
0406			;MENU ENTRY NUMBER (MEN) BEING PROVIDED BY THE KEY HANDLER.  
0406			;THE GO HANDLER IS A SIMPLE TABLE ENTRY CALCULATOR THAT USES THE MENU ENTRY NUMBER TO  
0406			;INDEX THROUGH A TABLE OF THREE BYTE JUMPS. LIKE THE DISPLAY CALCULATOR, THE ZERO POSSIBILITY  
0406			;IS TESTED FOR AND THE CALCULATOR SECTION IS SKIPPED OVER IF ZERO. WHEN THE REQUIRED TABLE  
0406			;ENTRY IS POINTED TO BY HL, IT IS THEN JUMPED TO VIA JP (HL), AND THE TABLE ENTRY,,,ITSELF  
0406			;BEING A 3 BYTE JUMP THEN JUMPS TO THE SELECTED MENU ENTRY'S ROUTINE.  
0406			  
0406 cd 42 08		            CALL    SCAN_IO                             ;CALL SCAN/KEY/LCD/PATCH ROUTINE  
0409 21 8f 08		            LD      HL, MENU_NO                         ;POINT HL TO MENU ENTRY NUMBER  
040c cd b2 04		            CALL    MENU_KEY                            ;CALL COMMON KEY HANDLER  
040f 28 05		            JR      Z, MENU_GO                          ;JUMP IF KEY WAS "GO" ELSE CALL TO  
0411 cd 97 08		            CALL    MENU_KEYRN                          ;RETURN INSTRUCTION (UNUSED BY JMON)  
0414 18 cd		            JR      MENU_DISP                           ;LOOP TO MAIN DISPLAY LOOP  
0416			  
0416			;MENU "GO" KEYHANDLER  
0416 2a 91 08		MENU_GO:    LD      HL, (MENU_J_TBL)                    ;POINT HL TO BASE OF JUMP TABLE  
0419 3a 8f 08		            LD      A, (MENU_NO)                        ;GET MENU ENTRY NUMBER  
041c b7			            OR      A                                   ;TEST FOR ZERO  
041d 28 06		            JR      Z, L0425                            ;SKIP CALCULATOR IF ZERO  
041f 23			L041F:      INC     HL                                  ;FIND JUMP VECTOR FOR THE CURRENT  
0420 23			            INC     HL                                  ;MENU HEADING  
0421 23			            INC     HL  
0422 3d			            DEC     A  
0423 20 fa		            JR      NZ, L041F  
0425 e9			L0425:      JP      (HL)                                ;AND JUMP TO THE REQUIRED ROUTINE  
0426			  
0426			;MAIN MENU ROUTINES  
0426			;------------------  
0426			  
0426			ORG     $0426  
0426			;GENERAL SIO TRANSMISION ENTRY POINT.  THIS ROUTINE WILL EXECUTE EITHER THE TRANSMIT OR RECEIVE SIO  
0426			;ROUTINE BASED ON THE MENU NUMBER.  
0426			J_SIO_TRANS:  
0426 21 1b 00		            LD      HL, DEF_BAUD                        ;SET BAUD 4800  
0429 22 a4 08		            LD      (BAUD), HL                          ;SET UP THE BAUD RATE  
042c			              
042c			;CONTINUE WITH PERIMETER SETUP FOR SIO  
042c 3a 8f 08		            LD      A, (MENU_NO)                        ;GET MENU ENTRY NUMBER  
042f b7			            OR      A                                   ;TEST FOR ZERO  
0430 28 05		            JR      Z, L0437                            ;SET FOR INPUT ROUTINE  
0432 21 40 04		            LD      HL, TRANS_RTN                       ;SET FOR TRANSMIT  
0435 18 03		            JR      L043A  
0437			L0437:  
0437 21 59 04		            LD      HL, RECV_RTN                        ;SET FOR RECEIVE  
043a			L043A:  
043a 22 88 08		            LD      (PERI_J_ADR), HL                    ;SAVE PERIMETER CALL  
043d c3 44 00		            JP      0044H                               ;CALL PERIMETER TO GET ADDRESS/LENGTH  
0440			  
0440			;TRANSMIT DATA TO SERIAL.  USES START AND END ADDRESS SET IN PERIMETER HANDLER.  
0440			;FIRST INITIALISE THE SERIAL TRANSMIT LINE TO BE PULLED HIGH.  THEN TRANSMIT THE DATA  
0440			TRANS_RTN:  
0440 21 00 20		            LD      HL, 2000H                           ;POWER UP DELAY  
0443 cd 48 05		            CALL    BITIME                              ;BIT DELAY  
0446 3e 40		            LD      A, 0x40                             ;SET A TO BIT 6   
0448 d3 01		            OUT	    (DSCAN), A                          ;OUTPUT D6 TO HIGH  
044a			  
044a cd 67 04		            CALL    SET_START_END                       ;SET HL TO START AND DE TO END  
044d			TRANS_BYTE:  
044d 7e			            LD      A, (HL)                             ;GET BYTE  
044e cd f0 04		            CALL    TXCHAR                              ;TRANSMIT IT  
0451 23			            INC     HL                                  ;MOVE TO NEXT LOCATION  
0452 b7			            OR      A                                   ;CLEAR CARRY FLAG  
0453 ed 52		            SBC     HL, DE                              ;CHECK IF ANY MORE DATA TO MOVE  
0455 19			            ADD     HL, DE                              ;RESTORE HL  
0456 20 f5		            JR      NZ, TRANS_BYTE                      ;MORE BYTES TO SEND  
0458 c7			            RST     00H                                 ;RESET  
0459			  
0459			;RECEIVE DATA FROM SERIAL.  USES START AND END ADDRESS SET IN PERIMETER HANDLER  
0459			RECV_RTN:  
0459 cd 67 04		            CALL    SET_START_END                       ;SET HL TO START AND DE TO END  
045c			RECV_BYTE:  
045c cd 1b 05		            CALL    RXCHAR                              ;GET BYTE  
045f 77			            LD      (HL), A                             ;LOAD BYTE INTO HL  
0460 23			            INC     HL                                  ;MOVE TO NEXT LOCATION  
0461 ed 52		            SBC     HL, DE                              ;CHECK IF ANY MORE DATA TO MOVE  
0463 19			            ADD     HL, DE                              ;RESTORE HL  
0464 20 f6		            JR      NZ, RECV_BYTE                       ;MORE BYTES TO RECEIVE  
0466 c7			            RST     00H                                 ;RESET  
0467			  
0467			;ROUTINE TO SET HL TO THE SIO START ADDRESS AND DE TO THE SIO_END ADDRESS.  IF START ADDRESS  
0467			;IS GREATER THAN THE END ADDRESS, THEN ADDRESSES ARE SWAPPED.  IF THEY ARE THE SAME, THE END  
0467			;ADDRESS IN INCREMENTED BY ONE.  
0467			SET_START_END:  
0467 2a 98 08		            LD      HL, (SIO_START)                     ;GET START ADDRESS  
046a ed 5b 9a 08	            LD      DE, (SIO_END)                       ;GET END ADDRESS OF DATA TO TRANSMIT  
046e b7			            OR      A                                   ;RESET CARRY FLAG  
046f ed 52		            SBC     HL, DE                              ;SEE WHICH IS LARGER  
0471 19			            ADD     HL, DE                              ;RESTORE HL  
0472 28 03		            JR      Z, L0477                            ;IF THEY ARE THE SAME INC DE BY ONE  
0474 d8			            RET     C                                   ;CARRY IS SET SO HL < DE  
0475 eb			            EX      DE, HL                              ;MAKE HL < DE  
0476 c9			            RET  
0477			L0477:  
0477 13			            INC     DE                                  ;ADD ONE TO DE TO MAKE IT LARGER THAN HL  
0478 c9			            RET  
0479			  
0479			;PERIMETER HANDLER  
0479			;THE PERIMETER HANDLER ROUTINE IS SIMILAR TO THE MENU DRIVER. THE MAJOR DIFFERENCES ARELISTED BELOW:  
0479			;THE PERIMETER HANDLER CREATES ITS OWN ADDRESS DISPLAY CODES BY CONVERTING THE CONTENTS  
0479			;OF THE ACTIVE WINDOW TO DISPLAY CODE AND THEREFORE DOES NOT REQUIRE A TABLE OF ADDRESS DISPLAY CODES.  
0479			;ANOTHER DIFFERENCE IS THE ADDRESS OF THE ROUTINE TO BE EXECUTED ON A "GO" PRESS IS SUPPLIED  
0479			;BY THE CALLING ROUTINE. THEREFORE THE PERIMETER HANDLER DOESN'T REQUIRE A JUMP TABLE AND  
0479			;ASSOCIATED CALCULATER.  
0479			;THE ONLY OTHER MAJOR DIFFERENCE IS THAT THE PERIMETER HANDLER HAS ITS OWN BUILT IN DATA  
0479			;KEY HANDLER WHILE THE MENU DOES NOT.  
0479			;THE FRONT SECTION BELOW CALCULATES THE ADDRESS OF THE ACTIVE WINDOW AND THE ADDRESS OF  
0479			;THE DATA DISPLAY FROM THE DISPLAY TABLE.  
0479			;THE MENU ENTRY NUMBER FROM THE MENU DRIVER HAS AN EQUIVALENT HERE. IT IS THE ACTIVE WINDOW  
0479			;NUMBER AND IS USEDIN IDENTICAL FASHION.  
0479			  
0479			ORG     $0479  
0479 3a 86 08		PERI_RTN:   LD      A, (PERI_W_CUR)                     ;GET NUMBER OF ACTIVE WINDOW  
047c 2a 84 08		            LD      HL, (PERI_W_ADD)                    ;GET ADDRESS OF FIRST (FILE) WINDOW+1  
047f ed 5b 82 08	            LD      DE, (PERI_D_TBL)                    ;GET BASE OF DATA DISPLAY TABLE  
0483 b7			            OR      A                                   ;TEST ACTIVE WINDOW NUMBER FOR ZERO  
0484 28 07		            JR      Z, L048D                            ;SKIP CALCULATOR IF ZERO  
0486 13			L0486:      INC     DE                                  ;FINE CURRENT DATA DISPLAY  
0487 13			            INC     DE                                  ;AND WINDOW  
0488 23			            INC     HL  
0489 23			            INC     HL  
048a 3d			            DEC     A  
048b 20 f9		            JR      NZ, L0486  
048d			  
048d			;AFTER THE ADDRESS+1 OF THE ACTIVE WINDOW IS CALCULATED, IT IS STORED IN A BUFFER (AT  
048d			;088C). EACH TIME A DATA KEY 1S PRESSED, HL IS LOADED FROM THIS BUFFER AND THEREFORE POINTS  
048d			;TO THE ACTIVE WINDOW. THE DATA CAN THEN BE SHIFTED INTO THE ACTIVE WINDOW IMMEDIATELY.  
048d			  
048d 22 8c 08		L048D:      LD      (PERI_W_AC1), HL                    ;STORE ACTIVE WINDOW ADDRESS+l  
0490			  
0490			;BELOW THE DATA DISPLAY BYTES ARE PUT INTO THE DATA SECTION OF THE DISPLAY BUFFER VIA HL.  
0490 eb			            EX      DE, HL                              ;PUT DATA DISPLAY ADDRESS IN HL  
0491 7e			            LD      A, (HL)                             ;GET RIGHT-HAND DISPLAY BYTE IN A  
0492 23			            INC     HL                                  ;AND LEFT-HAND IN H  
0493 66			            LD      H, (HL)                             ;PUT RIGHT-HAND BYTE IN L  
0494 6f			            LD      L, A                                ;HL HOLDS THE DATA DISPLAY BYTES  
0495 22 04 08		            LD      (DISP_DBUFF), HL                    ;STORE DATA DISPLAY IN BUFFER  
0498			  
0498			;BELOW THE 16 BIT CONTENTS OF THE ACTIVE WINDOW ARE CONVERTED TO DISPLAY CODE ARE PLACED  
0498			;IN THE ADDRESS SECTION OF THE DISPLAY BUFFER.  
0498			  
0498 eb			            EX      DE, HL                              ;GET ACTIVE WINDOW ADDRESS FROM DE  
0499 7e			            LD      A, (HL)                             ;AND TRANSFER  
049a 2b			            DEC     HL                                  ;THE 16 BIT CONTENTS OF THE ACTIVE  
049b 6e			            LD      L, (HL)                             ;WINDOW INTO HL  
049c 67			            LD      H, A                                ;READY TO COVERT TO DISPLAY CODE  
049d 01 00 08		            LD      BC, DISP_BUFF                       ;BC=DISPLAY BUFFER START  
04a0 cd 30 08		            CALL    HL_2_DIS                            ;CALL CONVERSION HL TO DISPLAY CODE  
04a3			  
04a3			;THE DISPLAY BUFFER IS NOW SET-UP AND THE SCAN/KEY LOOP IS CALLED. WHEN A KEY IS PRESSED,  
04a3			;A COMMON KEY HANDLER IS CALLED.  
04a3			;THE COMMON KEY HANDLER DOES ALL THE REQUIRED PROCESSING FOR THE "+", "- " AND "AD" KEYS.  
04a3			;IF EITHER THE "GO" OR A DATA KEY IS PRESSED, THEN THE HANDLER RETURNS WITH THE FLAGS SET  
04a3			;TO SIGNIFY THESE KEYS.  
04a3			;IF "GO" IS PRESSED THEN THE ZERO FLAG IS SET AND THE "GO" HANDLER BELOW IS EXECUTED. IF  
04a3			;A DATA KEY IS PRESSED THEN THE ZERO FLAG IS CLEAR (NOT ZERO) AND CARRY FLAG IS CLEAR THE  
04a3			;DATA KEY HANDLER IS EXECUTED IF THESE CONDITIONS ARE MET.  
04a3			  
04a3 cd 42 08		PERI_SFT:   CALL    SCAN_IO                             ;CALL SCAN/KEY/LCD/PATCH ROUTINE  
04a6 21 86 08		            LD      HL, PERI_W_CUR                      ;POINT HL TO ACTIVE WINDOW NUMBER  
04a9 cd b2 04		            CALL    MENU_KEY                            ;CALL COMMON KEY HANDLER  
04ac 20 16		            JR      NZ, PERI_D_KEY                      ;JUMP IF NOT GO KEY TO TEST FOR DATA  
04ae 2a 88 08		            LD      HL, (PERI_J_ADR)                    ;OR CONTROL KEY: ELSE GET JUMP ADDRESS  
04b1 e9			            JP      (HL)                                ;STORED BY SET-UP AND GO  
04b2			  
04b2			;COMMON KEY HANDLER  
04b2			;BECAUSE THE PERIMETER HANDLER AND THE MENU DRIVER ARE VERY SIMILAR, THEY ARE ABLE TO  
04b2			;SHARE A COMMON KEY HANDLER.  
04b2			;THE ACTION OF THE KEY HANDLER IS AS FOLLOWS:  
04b2			;IF THE "AD" KEY IS PRESSED, THEN THE RETURN ADDRESS IS POPPED OFF THE STACK AND A RETURN  
04b2			;IS DONE TO THE CALLING ROUTINE (USUALLY JMON). IF THE "GO" KEY IS PRESSED, THEN THE ZERO  
04b2			;FLAG WILL BE SET AND A RETURN DONE. IT IS THEN UP TO THE CALLING ROUTINE TO SERVICE THE  
04b2			;"GO" KEY.  
04b2			;A DATA KEY WILL BE FLAGGED BY SETTING THE CARRY FLAG AND CLEARING THE ZERO FLAG. LIKE  
04b2			;THE "GO" KEY, THE CALLING ROUTINE MUST DECIDE WHAT IT IS TO DO WITH THE DATA KEY (THERE  
04b2			;IS A BUILT IN DATA KEY HANDLER FOR THE PERIMETER HANDLER).  
04b2			;IF EITHER THE "+" OR "-" KEYS ARE PRESSED THEN A SPECIAL ROUTINE IS CALLED. THIS ROUTINE  
04b2			;WILL ALTER THE CURRENT NUMBER OF THE ACTIVE WINDOW OR MENU ENTRY. THE RESULT IS THAT WHEN  
04b2			;THE DISPLAY IS UP-DATED, THE DISPLAYS WILL BE SHIFTED TO EITHER THE NEXT DISPLAY FOR "+"  
04b2			;OR TO THE PREVIOUS ONE FOR "- " AND WRAP-AROUND IF REQUIRED.  
04b2			  
04b2 fe 10		MENU_KEY:   CP      K_PLUS                              ;IS THE KEY  
04b4 28 1b		            JR      Z, MENU_K_HDL                       ;JUMP IF SO TO "+" HANDLER  
04b6 fe 11		            CP      K_MINUS                             ;IS IT "-"  
04b8 28 17		            JR      Z, MENU_K_HDL                       ;JUMP IF SO TO "-" HANDLER  
04ba fe 13		            CP      K_ADDR                              ;IS IT "AD"  
04bc 20 02		            JR      NZ, L04C0                           ;JUMP IF NOT TO TEST FOR "GO"  
04be e1			            POP     HL                                  ;CLEAN UP STACK  
04bf c9			            RET                                         ;RETURN TO JMON (OR CALLING ROUTINE)  
04c0 fe 12		L04C0:      CP      K_GO                                ;IS IT "GO"  
04c2 3f			            CCF                                         ;CLEAR CARRY IF NOT IF GO C=1 Z=1  
04c3 c9			            RET                                         ;IF DATA SET Z=0 C=0: RETURN  
04c4			  
04c4			;BELOW IS THE PERIMETER HANDLER DATA KEY HANDLER/DISCRIMINATOR  
04c4			;IF THE KEY WAS "+" OR "-" THEN IT HAS ALREADY BEEN HANDLED AND THIS CONDITION IS FLAGGED  
04c4			;BY THE CARRY BEING SET. IN THIS CASE, A JUMP IS DONE BACK TO THE MAIN BODY TO UP-DATE  
04c4			;THE DISPLAY OTHERWISE THE DATA KEY VALUE IS SHIFTED INTO THE ACTIVE WINDOW.  
04c4			  
04c4 38 b3		PERI_D_KEY: JR      C, PERI_RTN                         ;JUMP IF KEY WAS "+" OR "-  
04c6 2a 8c 08		            LD      HL, (PERI_W_AC1)                    ;POINT HL TO ACTIVE WINDOW+1  
04c9 2b			            DEC     HL                                  ;POINT TO LOW ORDER BYTE  
04ca ed 6f		            RLD                                         ;SHIFT IN DATA KEY VALUE  
04cc 23			            INC     HL                                  ;AND SHIFT OTHER NIBBLES  
04cd ed 6f		            RLD                                         ;ACROSS  
04cf 18 a8		            JR      PERI_RTN                            ;JUMP BACK TO UP-DATE DISPLAY  
04d1			  
04d1			;THIS ROUTINE IS CALLED FROM THE COMMON KEY HANDLER IF EITHER "+" OR "-" HAVE BEEN PUSHED.  
04d1			;THIS ROUTINE WILL EITHER INCREMENT OR DECREMENT THE MEMORY LOCATION ADDRESSED BY HL FOR  
04d1			;THE "+" AND "-" KEY RESPECTIVELY. HL WAS LOADED BY THE CALLING ROUTINE TO POINT TO ITS  
04d1			;MAIN CONTROLLING BYTE. THIS IS EITHER THE CURRENT MENU ENTRY NUMBER (MENU DRIVER), OR  
04d1			;THE ACTIVE WINDOW NUMBER (PERIMETER HANDLER) , BOTH OF WHICH HAVE BEEN DESCRIBED PREVIOUSLY.  
04d1			;AFTER INCREMENTING OR DECREMENTING (HL), THIS ROUTINE THEN CHECKS THAT THE VALUE IN (HL)  
04d1			;IS NOT GREATER THAT THE BYTE AT HL+1 (WHICH IS THE MAXIMUM NUMBER OF DISPLAYS LESS 1).  
04d1			;KEEP IN MIND, IF IT UNDERFLOWED FROM ZERO IT WILL BECOME FF AND BE HIGHER THAN (HL). THIS  
04d1			;SECOND BYTE (AT HL+1) IS THE NUMBER OF ALLOWABLE DISPLAYS-1 AND WAS PROVIDED BY THE ROM  
04d1			;TABLE FOR THE (SIO) MENU DRIVER, AND PROVIDED BY THE PERIMETER HANDLER SET-UP ROUTINES  
04d1			;(REFER TO 042A AND 0442).  
04d1			;IF THE FIRST BYTE BECOMES HIGHER THAN THE SECOND., THEN THE ROUTINE CHECKS TO SEE WHICH  
04d1			;KEY WAS PRESSED. IF THE "+" KEY WAS, THEN (HL) IS CLEARED. THIS WILL CAUSE MENU OR  
04d1			;PERIMETER HANDLER TO SHOW ITS FIRST DISPLAY WHEN RE-ENTERED.  
04d1			;IF THE KEY WAS "-", THEN THE MAXIMUM NUMBER OF DISPLAYS-1 (WHICH IS THE SAME AS THE NUMBER  
04d1			;OF THE FINAL DISPLAY) IS TRANSFERRED INTO (HL) (THE NUMBER OF THE CURRENT DISPLAY). THIS  
04d1			;WILL CAUSE THE LAST DISPLAY TO BE SHOWN WHEN THE MENU DRIVER OR PERIMETER HANDLER IS  
04d1			;RE-ENTERED.  
04d1			;IF THERE IS NO UNDERFLOW OR OVERFLOW THEN THE ROUTINE RETURNS JUST AFTER IT HAS EITHER  
04d1			;INCREMENTED OR DECREMENTED THE CURRENT NUMBER OF THE MENU ENTRY NUMBER OR ACTIVE WINDOW  
04d1			;NUMBER.  
04d1			;WHEN THE MENU DRIVER OR PERIMETER HANDLER ARE RE-ENTERED, THEY WILL SHOW THE NEXT DISPLAY  
04d1			;FOR "+" OR THE PREVIOUS FOR "-" AND WRAP-AROUND AUTOMATICALLY IF REQUIRED.  
04d1			  
04d1			ORG     $04D1  
04d1 4f			MENU_K_HDL: LD      C, A                                ;SAVE INPUT KEY VALUE IN C  
04d2 23			            INC     HL                                  ;PUT MAX NUMBER OF DISPLAYS-1  
04d3 46			            LD      B, (HL)                             ;IN B  
04d4 2b			            DEC     HL                                  ;RESET HL TO POINT TO CURRENT NUMBER  
04d5 0f			            RRCA                                        ;WAS KEY "+" OR "-"? BIT 0 WILL TELL  
04d6 7e			            LD      A, (HL)                             ;PUT CURRENT NUMBER IN A  
04d7 38 02		            JR      C, L04DB                            ;JUMP IF KEY WAS "-"  
04d9 3c			            INC     A                                   ;INCREASE A BY 2  
04da 3c			            INC     A                                   ;  
04db 3d			L04DB:      DEC     A                                   ;DECREASE A BY ONE  
04dc 04			            INC     B                                   ;ADD 1 TO MAX NUMBER-1: IS CURRENT  
04dd b8			            CP      B                                   ;NUMBER EQUAL OR GREATER THAN MAX?  
04de 30 05		            JR      NC, L04E5                           ;JUMP IF SO TO UNDER/OVERFLOW HANDLER  
04e0 77			L04E0:      LD      (HL), A                             ;ELSE STORE UPDATED CURRENT NUMBER  
04e1 af			            XOR     A                                   ;SET ZERO FLAG  
04e2 3d			            DEC     A                                   ;CHANGE ZERO FLAG TO 0  
04e3 37			            SCF                                         ;AND SET CARRY  
04e4 c9			            RET                                         ;DONE  
04e5 cb 41		L04E5:      BIT     0, C                                ;TEST FOR "+" OR "-"  
04e7 20 03		            JR      NZ, L04EC                           ;JUMP IF "-" TO SET CURRENT NUMBER  
04e9 af			            XOR     A                                   ;TO LAST DISPLAY: ELSE SET FIRST  
04ea 18 f4		            JR      L04E0                               ;DISPLAY: JUMP TO STORE NEW NUMBER  
04ec 05			L04EC:      DEC     B                                   ;CORRECT MAX NUMBER-1  
04ed 78			            LD      A, B                                ;SET A TO LAST DISPLAY NUMBER  
04ee 18 f0		            JR      L04E0                               ;JUMP TO STORE LAST DISPLAY NUMBER  
04f0			  
04f0			ORG     $04F0  
04f0			  
04f0			;BIT BANG SERIAL TRANSMIT ROUTINE.  THIS ROUTINE WILL SEND ONE BYTE VIA THE SERIAL PORT  
04f0			;(DSCAN BIT 6).  IT FIRST TRANSMITS A START BIT BUT PULLING D6 LOW, THEN EACH BIT OF THE  
04f0			;BYTE TO TRANSMIT.  WHEN ALL EIGHT BITS ARE SENT, A STOP BIT IS SENT BY PULLING D6 HIGH  
04f0			;REGISTER 'A' IS THE BYTE TO BE SENT  
04f0			TXCHAR:  
04f0 f5			            PUSH	AF                                  ;SAVE AF, BC AND HL  
04f1 c5			            PUSH	BC  
04f2 e5			            PUSH	HL  
04f3 2a a4 08		            LD	    HL,(BAUD)                           ;HL HOLDS THE BIT TIME DELAY  
04f6 4f			            LD	    C,A                                 ;SAVE BYTE TO TRANSMIT IN C  
04f7			  
04f7 af			            XOR	    A                                   ;TRANSMIT THE START BIT  
04f8 d3 01		            OUT	    (DSCAN), A                          ;BY PULLING D6 LOW  
04fa cd 48 05		            CALL	BITIME                              ;CALL BAUD DELAY  
04fd			  
04fd 06 08		            LD	    B, 0x08                             ;TRANSMIT 8 BITS  
04ff cb 09		            RRC	    C                                   ;MOVE FIRST BIT INTO CARRY AND D7  
0501			NXTBIT:	  
0501 cb 09		            RRC	    C	                                ;SHIFT BIT TO D6  
0503 79			            LD	    A,C	                                ;COPY C TO A FOR SENDING  
0504 e6 40		            AND	    0x40                                ;MASK OUT ALL BUT D6  
0506 d3 01		            OUT	    (DSCAN), A                          ;OUTPUT THE BIT  
0508 cd 48 05		            CALL	BITIME                              ;CALL BAUD DELAY  
050b 10 f4		            DJNZ	NXTBIT                              ;DO EIGHT TIMES  
050d			  
050d 3e 40		            LD	    A, 0x40                             ;SEND THE STOP BITS  
050f d3 01		            OUT	    (DSCAN), A                          ;OUTPUT D6 TO HIGH  
0511 cd 48 05		            CALL	BITIME                              ;CALL BAUD DELAY  
0514 cd 48 05		            CALL	BITIME                              ;CALL BAUD DELAY X 2  
0517 e1			            POP   	HL                                  ;RESTORE AF, BC AND HL  
0518 c1			            POP  	BC  
0519 f1			            POP 	AF  
051a c9			            RET  
051b			  
051b			;BIT BANG SERIAL RECEIVED ROUTINE.  THIS ROUTINE WILL RECEIVE ONE BYTE VIA THE SERIAL PORT  
051b			;(KEYBOARD BIT 7).  IT WAITS FOR A START BIT (BIT 7) TO GO LOW.  THEN IT WILL GET THE 8 BITS AND  
051b			;CONSTRUCT ONE BYTE FROM THE BITS.  WHEN ALL BITS ARE RECIEVED, REGISTER A IS RETURNED WITH THE   
051b			;BYTE.  
051b			RXCHAR:  
051b c5			            PUSH	BC                                  ;SAVE BC AND HL  
051c e5			            PUSH	HL  
051d			STARTBIT:  
051d db 00		            IN	    A, (KEYBOARD)                       ;WAIT FOR THE START BIT   
051f cb 7f		            BIT	    7, A                                ;HIGH TO LOW TRANSISION  
0521 20 fa		            JR	    NZ, STARTBIT                        ;NO START BIT YET  
0523			  
0523			;START BIT DETECTED  
0523 2a a4 08		            LD	    HL, (BAUD)                          ;DELAY FOR HALF A  
0526 cb 3c		            SRL	    H                                   ;BIT TIME TO SAMPLE THE MIDDLE  
0528 cb 1d		            RR	    L 	                                ;OF THE BIT CELL  
052a cd 48 05		            CALL	BITIME                              ;CALL BAUD DELAY  
052d db 00		            IN	    A, (KEYBOARD)                       ;GET THE START BIT  
052f cb 7f		            BIT	    7, A                                ;CHECK THE START BIT IS STILL LOW  
0531 20 ea		            JR	    NZ, STARTBIT                        ;START BIT TOO SHORT, TRY AGAIN  
0533			  
0533			;VALID START BIT DETECTED  
0533 06 08		            LD	    B, 0x08                             ;RECEIVE EIGHT BITS  
0535			GETBITS:	  
0535 2a a4 08		            LD	    HL, (BAUD)                          ;SET BAUD DELAY  
0538 cd 48 05		            CALL	BITIME                              ;CALL BAUD DELAY  
053b db 00		            IN	    A, (KEYBOARD)                       ;GET BIT  
053d cb 17		            RL    	A                                   ;PUT BIT 7 IN CARRY FLAG  
053f cb 19		            RR	    C                                   ;SHIFT BIT INTO OUTPUT REGISTER  
0541 10 f2		            DJNZ	GETBITS                             ;GET MORE BITS  
0543 79			            LD	    A, C                                ;LOAD OUTPUT REGISTER TO A  
0544 b7			            OR	    A                                   ;CLEAR CARRY FLAG  
0545 e1			            POP	    HL                                  ;RESTORE HL AND BC  
0546 c1			            POP	    BC  
0547 c9			            RET  
0548			  
0548			;BIT TIME DELAY IS THE MANAGE THE DELAY TIME FOR ONE BIT SENT/RECEIVED BASED ON  
0548			;BAUD RATE.  HL = IS THE DELAY TIME  
0548			BITIME:  
0548 e5			            PUSH    HL                                  ;SAVE HL AND DE  
0549 d5			            PUSH    DE  
054a 11 01 00		            LD      DE, 0001H                           ;SET DE TO 1 TO SUBTRACT FROM HL  
054d			BITIME1:    
054d ed 52		            SBC     HL, DE                              ;SUBTRACT 1 FROM DELAY TIME  
054f d2 4d 05		            JP      NC, BITIME1                         ;KEEP GOING UNTL DELAY TIME IS ZERO  
0552 d1			            POP     DE                                  ;RESTORE HL AND DE  
0553 e1			            POP     HL  
0554 c9			            RET  
0555			  
0555			;ASCII TO SEVEN SEGMENT LOOKUP TABLE,  PLACED HERE SO TO BE SITTING IN THE SAME PAGE  
0555			;OF MEMORY, 0555H TO 055B4H  
0555			ASCII_SEG_TBL:  
0555 00 38 0a ee a7 5c 2c 02	            DB      0x00, 0x38, 0x0A, 0xEE, 0xA7, 0x5C, 0x2C, 0x02 ;  ! " # $ % & '  
055d 83 89 a3 46 40 04 10 4c	            DB      0x83, 0x89, 0xA3, 0x46, 0x40, 0x04, 0x10, 0x4C ;( ) * + , - . /  
0565 eb 28 cd ad 2e a7 e7 29	            DB      0xEB, 0x28, 0xCD, 0xAD, 0x2E, 0xA7, 0xE7, 0x29 ;0 1 2 3 4 5 6 7  
056d ef af 81 a1 07 84 0d 5d	            DB      0xEF, 0xAF, 0x81, 0xA1, 0x07, 0x84, 0x0D, 0x5D ;8 9 : ; < = > ?  
0575 ed 6f e6 c3 ec c7 47 e3	            DB      0xED, 0x6F, 0xE6, 0xC3, 0xEC, 0xC7, 0x47, 0xE3 ;@ A B C D E F G  
057d 6e 42 e8 67 c2 61 6b eb	            DB      0x6E, 0x42, 0xE8, 0x67, 0xC2, 0x61, 0x6B, 0xEB ;H I J K L M N O  
0585 4f 8f 4b a7 c6 ea ea 8a	            DB      0x4F, 0x8F, 0x4B, 0xA7, 0xC6, 0xEA, 0xEA, 0x8A ;P Q R S T U V W  
058d 6e ae cd c3 26 a9 0b 80	            DB      0x6E, 0xAE, 0xCD, 0xC3, 0x26, 0xA9, 0x0B, 0x80 ;X Y Z [ \ ] ^ _  
0595 08 ed e6 c4 ec cf 47 af	            DB      0x08, 0xED, 0xE6, 0xC4, 0xEC, 0xCF, 0x47, 0xAF ;` a b c d e f g  
059d 66 40 a0 67 42 60 64 e4	            DB      0x66, 0x40, 0xA0, 0x67, 0x42, 0x60, 0x64, 0xE4 ;h i j k l m n o  
05a5 4f 2f 44 a7 c6 e0 e0 60	            DB      0x4F, 0x2F, 0x44, 0xA7, 0xC6, 0xE0, 0xE0, 0x60 ;p q r s t u v w  
05ad 6e ae cd 2c 42 46 01 00	            DB      0x6E, 0xAE, 0xCD, 0x2C, 0x42, 0x46, 0x01, 0x00 ;x y z { | } ~    
05b5			  
05b5			;THIS ROUTINE DISPLAYS ASCII CHARACTERS ON THE SEVEN SEGMENTS AND SCROLLS THE MESSAGE   
05b5			;FROM RIGHT TO LEFT.  TO CREATE A MESSAGE, ENTER IN ASCII IN HEXADECIMAL AND ONCE  
05b5			;COMPLETE, TERMINATE WITH A CARRIAGE RETURN (0x0D), THEN CALL THIS ROUTINE AND   
05b5			;ENTER THE START ADDRESS OF THE ASCII DATA.  HIT 'GO' AND THE ASCII  
05b5			;WILL BE DISPLAYED AND SCROLLED.  THE MESSAGE WILL REPEAT ONCE A CARRIAGE RETURN IS  
05b5			;SEEN.  THIS IS 0x0D.  
05b5			J_MSG_SCRL:  
05b5 21 be 05		            LD      HL, ASCII_SCRL                      ;SET THE PERIMITER GO CALL  
05b8 22 88 08		            LD      (PERI_J_ADR), HL                    ;SAVE PERIMETER CALL  
05bb c3 44 00		            JP      0044H                               ;CALL PERIMETER TO GET START/END  
05be			  
05be			ASCII_SCRL:  
05be 21 00 08		            LD      HL, DISP_BUFF                       ;PUT DISPLAY BUFFER AT 0800  
05c1 22 2c 08		            LD      (V_DISPLAY), HL  
05c4 af			            XOR     A                                   ;RESET A TO BLANK  
05c5 06 06		            LD      B, 06H                              ;ALL SIX DISPLAYS  
05c7			SL1:  
05c7 77			            LD      (HL), A                             ;CLEAR DISPLAY  
05c8 23			            INC     HL                                  ;MOVE TO NEXT DISPLAY  
05c9 10 fc		            DJNZ    SL1                                 ;REPEAT SIX FIVE TIMES  
05cb			  
05cb 2a 98 08		            LD      HL, (SIO_START)                     ;GET START ADDRESS  
05ce			ASCII_SHIFT:  
05ce 06 05		            LD      B,05H                               ;SHIFT DOWN DISPLAY  
05d0 dd 21 00 08	            LD      IX, DISP_BUFF                       ;POINT IX TO DISPLAY BUFFER START  
05d4			SL2:  
05d4 dd 7e 01		            LD      A,(IX+1)                            ;GET THE NEXT VALUE TO THE RIGHT   
05d7 dd 77 00		            LD      (IX+0),A                            ;PLACE IT IN THE POSITION TO THE LEFT  
05da dd 23		            INC     IX                                  ;MOVE TO NEXT SEGMENT  
05dc 10 f6		            DJNZ    SL2                                 ;REPEAT SO THAT ALL FIVE SEGMENTS HAVE MOVE   
05de 7e			            LD      A,(HL)                              ;GET THE NEXT ASCII VALUE  
05df fe 0d		            CP      0x0D                                ;IS IT A CARRIAGE RETURN?  
05e1 28 db		            JR      Z, ASCII_SCRL                       ;YES, GO BACK TO START AND REPEAT MESSAGE  
05e3 d6 20		            SUB     0x20                                ;ADJUST FOR ASCII TABLE LOOKUP  
05e5 11 55 05		            LD      DE, ASCII_SEG_TBL                   ;POINT DE TO BASE OF TABLE  
05e8 83			            ADD     A, E                                ;INDEX E REGISTER WITH ASCII VALUE  
05e9 5f			            LD      E, A                                ;UPDATE E WITH INDEXED VALUE  
05ea 1a			            LD      A, (DE)                             ;RETRIEVE ASCII VALUE FOR SEVEN SEGMENT  
05eb 32 05 08		            LD      (DISP_BUFF + 5), A                  ;PLACE IN RIGHT MOST SPOT IN THE DISPLAY  
05ee e5			            PUSH    HL                                  ;SAVE HL TO RETAIN ASCII INDEX POSITION  
05ef 06 ff		            LD      B, 0xFF                             ;DELAY TO SLOW DOWN SCROLL  
05f1			SL3:  
05f1 c5			            PUSH    BC                                  ;SAVE BC  
05f2 cd 36 08		            CALL    LED_SCAN                            ;CALL SEGMENT SCAN ROUTINE  
05f5 c1			            POP     BC                                  ;RESTORE BC FOR DELAY  
05f6 10 f9		            DJNZ    SL3                                 ;REPEAT SCAN  
05f8 e1			            POP     HL                                  ;RESTORE ASCII INDEX POSITION  
05f9 23			            INC     HL                                  ;MOVE TO NEXT ASCII CHARACTER  
05fa 18 d2		            JR      ASCII_SHIFT                         ;LOOP TO SCROLL MESSAGE  
05fc			  
05fc			;THIS ROUTINE USES THE SERIAL IO TO RECIEVE AN INTEL HEX FILE.  CONNECT THE SERIAL TERMINAL  
05fc			;AS 4800-8-N-2. INTEL HEX FILE FORMAT IS A STRING OF ASCII WITH THE FOLLOWING PARTS  
05fc			; MARK | LENGTH | ADDRESS | RECORD TYPE | DATA | CHECKSUM  
05fc			; :10200000210621CD7D20CD98203A00213C320021AF <- EXAMPLE LINE  
05fc			;THE MARK IS A COLON CHARACTER ':', LENGTH IS THE NUMBER OF DATA BYTES PER LINE, ADDRESS  
05fc			;IS THE 2 BYTE ADDRESS OF WHERE THE DATA IS TO BE STORED.  RECORD TYPE IS 00 FOR DATA AND  
05fc			;01 FOR END OF FILE. DATA IS THE DATA OF UPTO 16 BYTES AND THE CHECKSUM IS THE ADDITION OF   
05fc			;ALL BYTES.  
05fc			J_INTEL_IN:  
05fc cd 14 06		            CALL    INTEL_LOADER                        ;CALL THE LOADER ROUTINE  
05ff c2 0a 06		            JP      NZ, INTEL_ERR                       ;IF RETURNS NON ZERO, ERROR  
0602 11 72 07		            LD      DE, LOAD_DA_P                       ;LOAD PASS  
0605 21 5a 07		            LD      HL, LOAD_AD_P                       ;MESSAGE  
0608 18 06		            JR      INTEL_RET                           ;DISPLAY MESSAGE  
060a			INTEL_ERR:  
060a 11 74 07		            LD      DE, LOAD_DA_F                       ;LOAD FAIL  
060d 21 5e 07		            LD      HL, LOAD_AD_F                       ;MESSAGE  
0610			INTEL_RET:  
0610 af			            XOR     A                                   ;RESET A AND ZERO FLAG  
0611 c3 ed 03		            JP      MENU_SFT                            ;DIPSLAY MENU WITH EITHER PASS/FAIL MESSAGE  
0614			  
0614			;THIS IS THE MAIN LOADING ROUTINE.  IT WILL LOAD ONE LINE OF INTEL HEX.  WHILE THE LOAD IS   
0614			;HAPPENING, THE ADDRESS WHERE THE DATA IS BEING SAVED WILL DISPLAY ON THE SCREEN.   
0614			INTEL_LOADER:  
0614 af			        	XOR	    A                                   ;ZERO A  
0615 4f				        LD      C, A	                            ;CLEAR CHECKSUM  
0616			INTEL_MARK:  
0616 cd 1b 05			        CALL	RXCHAR	                            ;WAIT FOR THE MARK  
0619 fe 3a			        CP	    ':'	                                ;TO BE TRANSMITTED  
061b 20 f9			        JR      NZ, INTEL_MARK	                    ;LOOP UNTIL START OF LINE FOUND  
061d cd 4d 06		        	CALL	ASCII_2_BYTE                        ;GET LINE LENGTH IN BYTES  
0620 47				        LD	    B, A                                ;STORE NUMBER OF DATA BYTES IN B  
0621 cd 4d 06		        	CALL	ASCII_2_BYTE                        ;GET ADDRESS HIGH BYTE  
0624 67			            LD      H, A                                ;STORE HIGH ADDRESS IN H  
0625 cd 4d 06		        	CALL	ASCII_2_BYTE                        ;GET ADDRESS LOW BYTE  
0628 6f			            LD      L, A                                ;STORE LOW ADDRESS IN L  
0629			  
0629 c5			            PUSH    BC                                  ;SAVE BC  
062a ed 4b 2c 08	            LD      BC, (V_DISPLAY)                     ;PUT DISPLAY BUFFER ADDRESS IN BC  
062e cd 30 08		            CALL    HL_2_DIS                            ;CALL HL TO DISPLAY CODE ROUTINE  
0631 c1			            POP     BC                                  ;RESTORE BC  
0632			  
0632 cd 4d 06		        	CALL	ASCII_2_BYTE                        ;GET RECORD TYPE  
0635 20 10		            JR      NZ, CHECKSUM                        ;IF 01 THEN END OF FILE  
0637			INTEL_DATA:  
0637 c5			            PUSH    BC  
0638 df			            RST     18H                                 ;SCAN THE DISPLAY TO SHOW CURRENT LOADING ADDRESS  
0639 c1			            POP     BC    
063a cd 4d 06		        	CALL	ASCII_2_BYTE                        ;GET DATA  
063d 77			            LD      (HL), A                             ;STORE DATA BYTE IN HL  
063e 23			        	INC     HL                                  ;MOVE TO NEXT ADDRESS  
063f 10 f6		            DJNZ    INTEL_DATA                          ;LOAD MORE BYTES  
0641			  
0641 cd 47 06		        	CALL    CHECKSUM                            ;COMPARE CHECK SUM  
0644 28 ce			        JR      Z, INTEL_LOADER	                    ;CHECKSUM OK,NEXT RECORD              
0646 c9			            RET                                         ;EXIT FOR ERROR  
0647			  
0647			CHECKSUM:                                               ;THE SUM OF ALL BYTES INCLUDING CHECKSUM SHOULD EQUAL ZERO  
0647 cd 4d 06		            CALL    ASCII_2_BYTE                        ;GET CHECKSUM BYTE  
064a 79			            LD      A, C         	                    ;CONVERT CHECKSUM TO  
064b b7			            OR      A                                   ;CHECK IF A=0, CHECKSUM IS OKAY  
064c c9			            RET                                         ;RETURN ZERO FLAG  
064d			  
064d			;GET HEX ASCII CHARACTER FROM SERIAL PORT AND CONVERT IT TO A BYTE.  THIS ALSO  
064d			;UPDATES THE HEX_CHECKSUM FOR USE LATER ON  
064d			ASCII_2_BYTE:  
064d cd 56 06		            CALL    A_2_BYTE                            ;GET 2 ASCII CHARS AND CONVERT TYPE BYTE  
0650 b2			            OR      D                                   ;ADD IT TO A TO COMPLETE THE BYTE  
0651 f5			            PUSH    AF                                  ;SAVE BYTE  
0652 81			            ADD     A, C                                ;ADD CHECKSUM TO BYTE  
0653 4f			            LD	    C, A	                            ;STORE BACK IN CHECKSUM  
0654 f1			            POP     AF                                  ;RESTORE BYTE  
0655 c9			            RET  
0656			;THIS ROUTINE GETS THE NEXT TWO ASCII CHARACTERS AND CONVERTS THEM INTO ONE BYTE,  D HOLDS  
0656			;THE FIRST CHARACTER IN THE UPPER NIBBLE, A HOLDS THE LOW NIBBLE.  GET NIBBLE IS CALLED TWICE WITH  
0656			;A FALL TRHOUGH  
0656			A_2_BYTE:  
0656 cd 5e 06		            CALL    GET_NIBBLE                          ;GET THE CHARACTER FROM THE SIO  
0659 07			            RLCA                                        ;MOVE TO UPPER NIBBLE  
065a 07			            RLCA  
065b 07			            RLCA  
065c 07			            RLCA  
065d 57				        LD      D, A                                ;STORE IN HIGH NIBBLE OF D  
065e			GET_NIBBLE:  
065e cd 1b 05			        CALL    RXCHAR                              ;GET ONE CHARACTER  
0661 cb 77			        BIT     6, A                                ;IS THE CHARACTER BETWEEN 30-39 (0-9) OR 41-46 (A-F)  
0663 28 02			        JR      Z, NOTA2F                           ;0-9 JUST MASK OUT UPPER BITS  
0665 c6 09			        ADD     A, 0x09                             ;ADD 0x09 TO FIX FOR A-F  
0667			NOTA2F:  
0667 e6 0f			        AND	    0x0F                                ;MASK OUT HIGH NuBBLE AND CONVERT TO BINARY  
0669 c9			            RET  
066a			  
066a			;THIS ROUTINE SWITCHES BETWEEN THE STANDARD TEC KEYBOARD LAYOUT AND MARK JELIC'S ALTERNATE ONE.  IT  
066a			;CAN BE MODIFED TO SUIT YOUR OWN LAYOUT.  IT WORKS BY USING SETTING THE KEYBOARD PATCH IN THE KEYBOARD  
066a			;ROUTINE TO THE J_KEY_MOD ROUTINE.  THIS WILL MODIFY THE CURRENT KEY PRESSED BEFORE THE KEYBOARD HANDLER  
066a			;RETURNS.   
066a			J_ALT_KEY:  
066a 3a 26 08		            LD      A, (V_ALT_KEYB)                     ;GET THE ALTERNATIVE KEYBOARD FLAG  
066d 2f			            CPL                                         ;SET IT TO EITHER 00 OR FF  
066e b7			            OR      A                                   ;IS IT ZERO (NORMAL KEYPAD)  
066f 32 26 08		            LD      (V_ALT_KEYB), A                     ;SAVE THE ALTERNATE KEYBOARD FLAG  
0672 21 54 08		            LD      HL, PATCH_KEY                       ;LOAD HL WITH THE PATCH KEYBOARD ENTRY  
0675 c2 7d 06		            JP      NZ,SET_ALTK                         ;IF NOT NORNAL, SET ALTERATE  
0678 36 c9		            LD      (HL), 0xC9                          ;JUST SET KEYBOARD PATCH TO EXIT  
067a			EXIT_KEY:  
067a c3 a2 00		            JP      SOFT_RST                            ;DO A SOFT RESET  
067d			SET_ALTK:  
067d 36 c3		            LD      (HL), 0xC3                          ;SET THE KEYBOARD PATCH TO CALL  
067f 01 88 06		            LD      BC, J_KEY_MOD                       ;THE J_KEY_MOD ROUTINE  
0682 ed 43 55 08	            LD      (PATCH_KEY+1), BC   
0686 18 f2		            JR      EXIT_KEY                            ;DO A SOFT RESET  
0688			  
0688			;HERE IS THE KEYBOARD MOD ROUTINE.  IT TAKES IN THE KEY KEY PRESSED STORED IN THE 'A'  
0688			;REGISTER AND USES THIS KEY TO INDEX A TABLE TO MODIFY IT TO AN ALTERNATE KEY.  HERE ARE  
0688			;THE TWO KEYBOARD LAYOUT FOR REFERENCE.  ARGUABLY THE ALTERNATE LAYOUT MAKES MORE SENSE.  
0688			;FEEL FREE TO CHANGE THIS TO SUIT YOUR OWN SETUP!  
0688			;  
0688			;    STANDARD LAYOUT           ALTERNATE LAYOUT  
0688			; |----|---|---|---|---|    |----|---|---|---|---|  
0688			; | AD | 3 | 7 | B | F |    | AD | 7 | 8 | 9 | A |   
0688			; |----|---|---|---|---|    |----|---|---|---|---|  
0688			; | GO | 2 | 6 | A | E |    | GO | 4 | 5 | 6 | B |   
0688			; |----|---|---|---|---|    |----|---|---|---|---|  
0688			; | -  | 1 | 5 | 9 | D |    | -  | 1 | 2 | 3 | C |   
0688			; |----|---|---|---|---|    |----|---|---|---|---|  
0688			; | +  | 0 | 4 | 8 | C |    | +  | 0 | F | E | D |   
0688			; |----|---|---|---|---|    |----|---|---|---|---|  
0688			J_KEY_MOD:  
0688 e5			            PUSH    HL                                  ;SAVE HL  
0689 21 91 06		            LD      HL, ALT_KEY_TBL                     ;POINT HL TO ALTERNATE KEYBOARD TABLE  
068c 85			            ADD     A, L                                ;INDEX L WITH A  
068d 6f			            LD      L, A                                ;SAVE L  
068e 7e			            LD      A, (HL)                             ;RETRIEVE NEW KEY  
068f e1			            POP     HL                                  ;RESTORE HL  
0690 c9			            RET                                         ;EXIT  
0691			  
0691			ALT_KEY_TBL:  
0691 00 01 04 07 0f 02 05 08	            DB      0x00, 0x01, 0x04, 0x07, 0x0F, 0x02, 0x05, 0x08 ; 0 1 4 7 F 2 5 8  
0699 0e 03 06 09 0d 0c 0b 0a	            DB      0x0E, 0x03, 0x06, 0x09, 0x0D, 0x0C, 0x0B, 0x0A ; E 3 6 9 D C B A  
06a1 10 11 12 13	            DB      0x10, 0x11, 0x12, 0x13                         ; + - GO AD  
06a5			  
06a5 ff ff		            DB      0xFF, 0xFF                          ;SPARE  
06a7 ff ff ff ff ff ff	            DB      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF  ;FILL   
06ad			              
06ad			  
06ad			;THIS ROUTINE IS THE KEYBOARD READER/VALIDATER  
06ad			;THE ACTION IS AS FOLLOWS:  
06ad			;A SHORT LOOP LOOKS FOR A KEY PRESS. IF NO KEY IS PRESSED, THEN THE KEY PRESS BUFFER (0825)  
06ad			;IS CLEARED THE ZERO AND THE CARRY FLAG CLEARED AND THE ROUTINE RETURNS.  
06ad			;IF A KEY IS FOUND, THEN THE REMAINING LOOP COUNTS ARE WORKED OFF IN A DUMMY LOOP TO ENSURE  
06ad			;EQUAL TIME IN EXECUTING THE ROUTINE.  
06ad			;IF IT IS THE FIRST TIME.THAT THE KEY HAS BEEN DETECTED, THEN THE KEY PRESS FLAG WILL BE  
06ad			;CLEAR. (IT WAS CLEARED BY THE MONITOR VARIABLES ON RESET). THE ROUTINE TESTS FOR THIS  
06ad			;CONDITION AND IF TRUE THEN THE KEY IS ACCEPTED AS "VALID" AND FLAGGED BY A SET CARRY AND  
06ad			;SET ZERO FLAG AND THE KEY PRESS FLAG IS SET TO INDICATE THE A KEY HAS BEEN DETECTED. THE  
06ad			;INPUT IS THEN PLACED IN BOTH THE "I" REGISTER AND THE ACCUMULATOR. IF A KEY IS DETECTED  
06ad			;BUT FOUND NOT TO BE VALID, I.E. IT HAS ALREADY BEEN DETECTED AND PROCESSED, THEN THE  
06ad			;CARRY WILL BE SET BUT THE ZERO CLEARED. THIS ALLOWS THE AUTO KEY REPEAT SECTION TO KNOW  
06ad			;THAT A KEY IS STILL BEING HELD DOWN. THE AUTO KEY REPEAT SECTION MAKE UP ITS OWN MIND  
06ad			;WHETHER IT IS VALID OR NOT.  
06ad			  
06ad			ORG     $06AD  
06ad db 00		KEY_READ:   IN      A, (P_DAT)                          ;TEST FOR KEY PRESSED  
06af cb 77		            BIT     6, A  
06b1 28 08		            JR      Z, L06BB                            ;DA IS LOW = KEYPRESS  
06b3 10 f8		            DJNZ    KEY_READ                            ;LOOP LOOKING FOR KEY UNTIL B=0  
06b5 af			            XOR     A                                   ;CLEAR KEY PRESS FLAG  
06b6 32 25 08		            LD      (V_KEY_PRES), A  
06b9 3d			            DEC     A                                   ;SET A TO FF AND CLEAR ZERO FLAG  
06ba c9			L06BA:      RET                                         ;DONE  
06bb 3a 25 08		L06BB:      LD      A, (V_KEY_PRES)                     ;GET KEY PRESS FLAG  
06be b7			            OR      A                                   ;TEST FOR ZERO  
06bf 20 00		            JR      NZ, L06C1                           ;DUMMY JUMP TO EQUALIZE TIME  
06c1 10 f8		L06C1:      DJNZ    L06BB                               ;FINISH LOOP  
06c3 37			            SCF                                         ;SET CARRY  
06c4 20 f4		            JR      NZ, L06BA                           ;DUMMY JUMP TO RETURN  
06c6 3d			            DEC     A                                   ;SET KEY PRESS FLAG TO FF  
06c7 32 25 08		            LD      (V_KEY_PRES), A  
06ca db 00		KEY_GET:    IN      A, (KEYBOARD)                       ;GET INPUT KEY FROM ENCODER CHIP  
06cc e6 1f		            AND     0x1F                                ;MASK OFF UNUSED BITS  
06ce cd 54 08		            CALL    PATCH_KEY                           ;USER ROUTINE TO MODIFY KEY FOR CUSTOM KEYBOARD  
06d1 cb 7f		            BIT     7, A                                ;SET ZERO FLAG (THINK ABOUT IT!)  
06d3 37			            SCF                                         ;SET CARRY  
06d4 32 20 08		            LD      (V_KEY), A                          ;STORE INPUT KEY  
06d7 c9			            RET                                         ;DONE  
06d8			  
06d8			;THIS ROUTINE IS CALLED ONCE ON EVERY HARD RESET. IT INITIALIZES THE LCD THEN TESTS THAT  
06d8			;IT IS THERE (IT CANNOT DO IT THE OTHER WAY AROUND AS THE LCD NEEDS TO BE INITIALIZED  
06d8			;BEFORE IT WILL RESPOND INTELLIGENTLY). IF THE LCD IS FITTED THEN THE ROUTINE WILL READ  
06d8			;IN AN ASCII SPACE CHARACTER (20H) OR IF THE LCD IS NOT, JUNK FROM THE DATA BUSS.  
06d8			;20H IS SUBTRACTED FROM WHATEVER IS READ IN AND THE RESULT IS STORED IN THE LCD ENABLE  
06d8			;BUFFER. IF THE RESULT IS ZERO THEN THE LCD IS ENABLED. IT IS VITAL TO KNOW IF THE LCD IS  
06d8			;FITTED, OTHERWISE THE ROUTINE WHICH READS THE BUSY FLAG MAY LOOP FOREVER.  
06d8			  
06d8 21 b5 07		LCD_RESET:  LD      HL, LCDRST_TBL                      ;POINT HL TO LCD INITIALIZE TABLE  
06db 01 04 04		            LD      BC, 0x0404                          ;B=4 BYTES, C=PORT 4  
06de 11 00 05		L06DE:      LD      DE, 0500H                           ;DELAY BETWEEN  
06e1 1b			L06E1:      DEC     DE                                  ;EACH BYTE  
06e2 7a			            LD      A, D                                ;AS PER  
06e3 b3			            OR      E                                   ;LCD MANUFACTER'S  
06e4 20 fb		            JR      NZ, L06E1                           ;INSTRUCTIONS  
06e6 ed a3		            OUTI                                        ;OUTPUT (HL) TO (C). HL=HL+1,B=B-1  
06e8 20 f4		            JR      NZ, L06DE                           ;JUMP IF B NOT 0  
06ea 10 fe		L06EA:      DJNZ    L06EA                               ;SHORT DELAY  
06ec db 84		            IN      A, (P_LCDDATA)                      ;INPUT FROM LCD TO SEE IF IT'S THERE  
06ee d6 20		            SUB     0x20                                ;SUBTRACT ASCII SPACE, IF LCD FITTED  
06f0 32 21 08		            LD      (V_LCD), A                          ;RESULT WILL BE ZERO: STORE THIS IN  
06f3 c9			            RET                                         ;LCD MASK: DONE  
06f4			              
06f4 ff ff ff ff ff ff	            DB      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF  ;FILL   
06fa ff ff ff ff ff ff	            DB      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF  ;FILL   
0700			  
0700			;AT 0700 IS THE MAIN MENU JUMP TABLE.  
0700			ORG     0x0700  
0700			MAIN_JP_TBL:  
0700 c3 26 04		            JP      J_SIO_TRANS                        ;SIO TRANSFER IN  
0703 c3 26 04		            JP      J_SIO_TRANS                        ;SIO TRANSFER OUT  
0706 c3 fc 05		            JP      J_INTEL_IN                         ;SIO INTEL HEX FILE INPUT  
0709 c3 6a 06		            JP      J_ALT_KEY                          ;SWITCH BETWEEN ALTERNATE KEYBOARD LAYOUT  
070c c3 b5 05		            JP      J_MSG_SCRL                         ;MESSAGE SCROLL ROUTINE  
070f			  
070f			;BELOW ARE THE JMON DEFAULT RESET VARIABLES (A ZERO IS THE ACTIVE RAM  
070f			;STATE UNLESS OTHERWISE STATED). LOCATION  
070f			;* DENOTES CONTROL BYTES DESIGNED TO BE USER ALTERED (IN RAM).  
070f			  
070f			ORG     $070F  
070f 00			DEF_VARS:   DB      0x00                                ;KEY BUFFER 0820  
0710 00			L0710:      DB      0x00                                ;LCD ON/OFF FLAG 0821*  
0711 00			L0711:      DB      0x00                                ;SOUND ON/OFF 0822*  
0712 ff			L0712:      DB      0xFF                                ;GO AT ALTERNATE GO ADDRESS IF AA 0823*  
0713 ff			L0713:      DB      0xFF                                ;STEPPER KEY CONTROL/TIMER 0824  
0714 00			L0714:      DB      0x00                                ;KEY PRESSED FLAG 0825  
0715 00			L0715:      DB      0x00                                ;ALTERNATIVE KEYBOARD LAYOUT FLAG 0826  
0716 00			L0716:      DB      0x00                                ;AUTO INCREMENT ON/OFF 0827*  
0717 00 09		L0717:      DB      0x00, 0x09                          ;ALT GO ADDR/SOFT RESET EDIT LOCATION ($2000) 0828*  
0719 70			L0719:      DB      0x70                                ;AUTO KEY REPEAT TIMER 082A  
071a 00			L071A:      DB      0x00                                ;MONITOR CONTROL BYTE 082B  
071b 00 08		L071B:      DB      0x00, 0x08                          ;DISPLAY BUFFER ADDRESS 082C*  
071d 00 09		L071D:      DB      0x00, 0x09                          ;INITIAL EDITING LOCATION 082E  
071f			  
071f			;BELOW ARE THE JMON INDIRECT JUMP ADDRESSES. THIS TABLE IS SHIFTED DOWN TO 0830 ON A HARD RESET.  
071f c3 d5 01		L071F:      JP      J_HL2CODE                           ;CONVERT HL TO DISPLAY CODE 0830  
0722 c3 da 01		L0722:      JP      J_A2CODE                            ;CONVERT A TO DISPLAY CODE 0833  
0725 c3 ba 01		L0725:      JP      J_LEDSCAN                           ;LED SCAN ROUTINE 0836  
0728 c3 ee 01		L0728:      JP      J_SETDOTS                           ;SET LED DOTS 0839  
072b c3 24 02		L072B:      JP      J_TONEX2                            ;RESET TONES 083C  
072e c3 27 02		L072E:      JP      J_TONE                              ;TONE 083F  
0731 c3 81 01		L0731:      JP      J_SCANKEY                           ;SCAN/KEY/LCD/PATCH LOOP 0842  
0734 c3 b2 00		L0734:      JP      J_DISPUPD                           ;SOFT JMON ENTRY L0845  
0737 c3 3c 02		L0737:      JP      J_LCD                               ;LCD ROUTINE 0848  
073a			  
073a			;BELOW ARE THE DISPLAY TABLES FOR THE MAIN MENU ADDRESS DISPLAYS  
073a			MAIN_AD_TBL:  
073a a7 28 eb 04	            DB      0xA7, 0x28, 0xEB, 0x04              ;"SIO-"  
073e a7 28 eb 04	            DB      0xA7, 0x28, 0xEB, 0x04              ;"SIO-"  
0742 28 6b c6 c7	            DB      0x28, 0x6B, 0xC6, 0xC7              ;"INtE"  
0746 6f c2 c6 67	            DB      0x6F, 0xC2, 0xC6, 0x67              ;"ALTK"  
074a ef 6f 6b 6b	            DB      0xEF, 0x6F, 0x6B, 0x6B              ;"BANN"  
074e			;EXTENDED MENU  
074e 61 28 6b c6	            DB      0x61, 0x28, 0x6B, 0xC6              ;"MINT"  
0752 ef 6f a7 28	            DB      0xEF, 0x6F, 0xA7, 0x28              ;"BASI"  
0756 e3 6f 61 c7	            DB      0xE3, 0x6F, 0x61, 0xC7              ;"GAME"  
075a			  
075a			;INTEL PASS/FAIL MESSAGE  
075a 4f 6f a7 a7	LOAD_AD_P:  DB      0x4F, 0x6F, 0xA7, 0xA7              ;"PASS"  
075e 47 6f 28 c2	LOAD_AD_F:  DB      0x47, 0x6F, 0x28, 0xC2              ;"FAIL"  
0762			  
0762			;BELOW ARE THE MAIN MENU DATA DISPLAYS.  
0762			MAIN_DA_TBL:  
0762 20 64		            DB      0x20, 0x64                          ;"in"  
0764 e4 c6		            DB      0xE4, 0xC6                          ;"ot"  
0766 c2 00		            DB      0xC2, 0x00                          ;"L "  
0768 c7 ae		            DB      0xC7, 0xAE                          ;"EY"  
076a c7 4b		            DB      0xC7, 0x4B                          ;"ER"  
076c			;EXTENDED MENU  
076c 00 00		            DB      0x00, 0x00                          ;"  "  
076e c3 00		            DB      0xC3, 0x00                          ;"C "  
0770 c7 a7		            DB      0xC7, 0xA7                          ;"ES"  
0772			;INTEL PASS/FAIL MESSAGE  
0772 04 04		LOAD_DA_P:  DB      0x04, 0x04                          ;"--"  
0774 c2 ec		LOAD_DA_F:  DB      0xC2, 0xEC                          ;"Ld"  
0776			  
0776 ff ff ff ff ff ff	L0772:      DB      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF      ;(UNUSED)  
077c			  
077c			;BELOW IS THE PERIMETER HANDLER COMMAND STRING FOR THE SIO ROUTINES.  
077c			ORG      $077C  
077c			SIO_P_DRIVER:  
077c ff ff		            DB      0xFF,0xFF                           ;BLANK  
077e c6 07		            DW      PERM_DA_TBL                         ;LED DISPLAY FOR DATA, 2 BYTES EACH  
0780 99 08		            DB      0x99,0x08                           ;STORE KEYED INFO HERE AT 0X3F98  
0782 00 01		            DB      0x00,0x01                           ;NUMBER OF PERIMETER ITEMS, =2  
0784 ff ff		            DB      0xFF,0xFF                           ;FUNCTION TO CALL WHEN GO PRESSED (FILLED IN BY MENU)  
0786			                                                        ;SEE 0426-044E).  
0786			  
0786			;0786 - 0788 FF ;(RESERVED FOR COMMAND STRING EXPANSION).  
0786 ff ff ff		            DB      0xFF,0xFF,0xFF  
0789			  
0789			;BELOW IS THE MAIN MENU DRIVER COMMAND STRING.  
0789			ORG      $0789  
0789			MAIN_M_DRIVER:  
0789 ff ff		            DB      0xFF,0xFF                           ;BLANK  
078b 00 04		            DB      0x00,0x04                           ;FIRST MENU ITEM AND TOTAL NUMBER IF ENTRIES  
078d 00 07		            DW      MAIN_JP_TBL                         ;JUMP TABLE FOR MENU ITEMS  
078f 3a 07		            DW      MAIN_AD_TBL                         ;MENU ADDRESS LED DISPLAY TABLE  
0791 62 07		            DW      MAIN_DA_TBL                         ;MENU DATA LED DISPLAY TABLE  
0793 c9			            DB      0xC9                                ;MAIN MENU DATA KEY HANDLER  
0794			                                                        ;ROUTINE JUMP VECTOR (A RETURN INSTRUCTION).  
0794			;BELOW IS THE STEPPERS DATA DISPLAY CODES.  
0794			ORG     $0794  
0794 4f c3		SEGREG_TBL: DB      0x4F, 0xC3                          ;"PC"  
0796 6f 47		            DB      0x6F, 0x47                          ;"AF"  
0798 e6 c3		            DB      0xE6, 0xC3                          ;"BC"  
079a ec c7		            DB      0xEC, 0xC7                          ;"DE"  
079c 6e c2		            DB      0x6E, 0xC2                          ;"HL"  
079e 28 6e		            DB      0x28, 0x6E                          ;"IX"  
07a0 28 ae		            DB      0x28, 0xAE                          ;"IY"  
07a2 7f 57		            DB      0x7F, 0x57                          ;AF'"  
07a4 f6 d3		            DB      0xF6, 0xD3                          ;"BC'"  
07a6 fc d7		            DB      0xFC, 0xD7                          ;"DE'"  
07a8 7e d2		            DB      0x7E, 0xD2                          ;"HL'"  
07aa a7 4f		            DB      0xA7, 0x4F                          ;"SP"  
07ac ff			            DB      0xFF                                ;(UNUSED)  
07ad			  
07ad			;START OF STAGGERED TABLE OF JMON MODE WORDS FOR LCD  
07ad			ORG     $07AD  
07ad 44 61 74 61	LCDFNC_TBL: DB      0x44, 0x61, 0x74, 0x61              ;"Data"  
07b1 41 64 64 72	            DB      0x41, 0x64, 0x64, 0x72              ;"Addr"  
07b5			  
07b5			;LCD INITIALIZATION CODES  
07b5			ORG     $07B5  
07b5 38 01 06 0c	LCDRST_TBL: DB      0x38, 0x01, 0x06, 0x0C              ;0X38 - 8-BIT MODE, 2 LINES, 5x8 DOTS  
07b9			                                                        ;0x01 - CLEAR DISPLAY  
07b9			                                                        ;0x06 - CURSOR TO RIGHT,NO SHIFT  
07b9			                                                        ;0x0C - DISPLAY ON, CURSOR OFF  
07b9			  
07b9			;THE REST OF THE JMON MODE WORD TABLE FOR LCD *THIS TABLE NEEDS TO BE 12 BYTES FROM LCDFNC_TBL  
07b9			ORG     $07B9  
07b9 46 73 2d 20	L07B9:      DB      0x46, 0x73, 0x2D, 0x20              ;"Fs- "  
07bd			  
07bd			;ADDRESS TABLE OF THE LCD PROMPT LOCATIONS.  
07bd			ORG     $07BD  
07bd 84 87 8a 8d c4 c7 ca cd 80	LCDPMT_TBL: DB      0x84, 0x87, 0x8A, 0x8D, 0xC4, 0xC7, 0xCA, 0xCD, 0x80  
07c6			  
07c6			;SIO PERIMETER HANDLER DATA DISPLAYS  
07c6			ORG     $07C6  
07c6			PERM_DA_TBL:  
07c6 04 a7		            DB      0x04, 0xA7                          ;"-S" - ADDRESS START LOCATION  
07c8 04 c7		            DB      0x04, 0xC7                          ;"-E" - ADDRESS END LOCATION  
07ca ff ff		            DB      0xFF, 0xFF                          ;(UNUSED)  
07cc ff ff		            DB      0xFF, 0xFF                          ;(UNUSED)  
07ce ff ff		            DB      0xFF, 0xFF                          ;(UNUSED)  
07d0			  
07d0			;BELOW ARE THE DISPLAY CODE EQUIVALENTS OF THE HEX DIGITS 0 TO F LISTED IN ASCENDING ORDER.  
07d0			ORG     $07D0  
07d0 eb 28 cd ad 2e a7 e7 29 ef 2f 6f e6 c3 ec	SEG_TBL:    DB      0xEB, 0x28, 0xCD, 0xAD, 0x2E, 0xA7, 0xE7, 0x29, 0xEF, 0x2F, 0x6F, 0xE6, 0xC3, 0xEC  
07de c7 47		            DB      0xC7, 0x47                      ;MJ: Split out to allow for a Label that is used  
07e0			  
07e0			;FINALLY AT 07E0 IS THE FUNCTION-1 AND SHIFT JUMP ADDRESSES.  ACCESS BY PRESSING "SHIFT" + "NUMBER"  
07e0			;OR "ADDRESS", then "+", then "NUMBER" TO ENTER FUNCTION-! MODE  
07e0			ORG     $07E0  
07e0 d2 03		L07E0:      DW      FN_MENU                             ;#0 MAIN MENU SETUP TO MENU DRIVER  
07e2 e3 02		            DW      FN_BACK1                            ;#1 MOVE ADDRESS BACK ONE LOCATION  
07e4 5e 00		            DW      FN_STEPPER                          ;#2 STEPPER ROUTINE  
07e6 ff ff		            DW      0xFFFF                              ;#3 N/A  
07e8 d3 02		            DW      FN_FORW4                            ;#4 MOVE ADDRESS FORWARD FOUR LOCATIONS  
07ea ae 00		            DW      FN_S_RST                            ;#5 DO A SOFT RESET  
07ec de 02		            DW      FN_BACK4                            ;#6 MOVE ADDRESS BACK FOUR LOCATIONS  
07ee 41 03		            DW      FN_REGDIS                           ;#7 DISPLAY REGISTERS  
07f0 ed 02		            DW      FN_FORW8                            ;#8 MOVE ADDRESS FORWARD EIGHT LOCATIONS  
07f2 e8 02		            DW      FN_FORW1                            ;#9 MOVE ADDRESS FORWARD ONE LOCATION  
07f4 f2 02		            DW      FN_BACK8                            ;#A MOVE ADDRESS BACK EIGHT LOCATIONS  
07f6 ff ff		            DW      0xFFFF                              ;#B N/A  
07f8 ff ff		            DW      0xFFFF                              ;#C N/A  
07fa ff ff		            DW      0xFFFF                              ;#D N/A  
07fc ff ff		            DW      0xFFFF                              ;#E N/A  
07fe ff ff		            DW      0xFFFF                              ;#F N/A  
# End of file /Users/slarti/Documents/TEC1x/TEC-1D-Stuff/code/bmon/bmon_2K_TEC1F.z80
0800
